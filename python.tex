\chapter{Язык программирования Python}
\label{ch:Python}

\section{Операторы}
\label{sec:statements}

\subsubsection{Оператор if}
Общая форма оператора \lstinline{if} выглядит следующим образом:
\begin{pylst}{}{}
if $expression$: $suite$
( elif $expression$: $suite$)*
[ else: $suite$ ]
\end{pylst}

Этот оператор вычисляет последовательно выражения $expression$ до тех пор, пока не будет найдено равное \lstinline{true}. После чего выполняется соответсвующее $suite$. Если все выражения оказались равными \lstinline{false}, то выполняются операторы и выражения из \lstinline{else} ветки. Выполняется не больше одного набора операторов и выражений ($suite$).

\subsubsection{Оператор while}
Общая форма оператора \lstinline{while} выглядит следующим образом:
\begin{pylst}{}{}
while $expression$: $suite_1$
[ else: $suite_2$ ]
\end{pylst}

Выполняет $suite_1$ пока $expression$ истинно. Если в первый раз $expression$ оказалось ложно, выполняется ветка \lstinline{else}, после чего цикл завершается. Оператор \lstinline{break} завершает цикл без выполнения ветки \lstinline{else}. Оператор \lstinline{continue} передает управление на начало цикла.

\subsubsection{Оператор for}
Общая форма оператора \lstinline{for} выглядит следующим образом:
\begin{pylst}{}{}
for $variable$ in $expression$: $suite_1$
[ else: $suite_2$ ]
\end{pylst}

$expression$ вычисляется единожды. Оно должно вычислятся в итерируемый объект. Затем $suite_1$ вычисляется столько раз, сколько объектов в итерируемом объекте, при этом переменной $variable$ присваивается очередной объект. По завершении вычисляется ветка \lstinline{else}.

Оператор \lstinline{break} завершает цикл без выполнения ветки \lstinline{else}. Оператор \lstinline{continue} передает управление на начало цикла или, если больше нет очередного объекта, на ветку \lstinline{else}.

\subsubsection{Оператор try}
Общая форма оператора \lstinline{try} выглядит следующим образом:
\begin{pylst}{}{}
try: suite
( except [expression [ ( as | "," ) target ] ]: suite )+
[ else: suite ]
[ finally: suite ]
\end{pylst}
или
\begin{pylst}{}{}
try: suite
finally: suite
\end{pylst}

Блоки \lstinline{except} определяют обработчики исключительных ситуаций. Если в блоке \lstinline{try} не возникло исключительной ситуации, то ни один из обработчиков не выполняется. В ином случае происходит поиск подходящего обработчика последовательно по блокам \lstinline{except}. Блок \lstinline{except} без выражений $expression$, если таковой присутствует, должен быть последним. При поиске выражения $expression$ вычисляются, и блок выбирается для выполнения, если объект-результат подходит к возникшему исключению, т.е. если объект является классом, который присутствует в списке наследования объекта исключения, или же кортежем, в котором хотя бы один элемент является совместимым с исключением.

Если обработчик не найден, поиск происходит в обрамляющем коде и вверх дальше по стеку, если блок \lstinline{finally} не присутсвует.

Если при выполнении выражений $expression$ возникло исключение, то изначальное исключение отбрасывается, и начинается новый поиск для нового исключения в обрамляющем коде и вверх по стеку.

Если же подходящий блок \lstinline{except} найден, то $target$, если присутствует, присваивается результат вычисления $expression$, и блок исполняется. После чего управление передается, как правило, за пределы оператора \lstinline{try}.

В блоке обработчика можно вызвать \lstinline{sys.exc_info}, которая возвращает кортеж \lstinline{(exc_type, exc_value, exc_traceback)}, где \lstinline{exc_type} --- объект исключения, \lstinline{exc_value} --- параметры, переданные исключению, \lstinline{exc_traceback} --- traceback объект.

Блок \lstinline{else} выполняется в том случае, если управление достигло конца блока \lstinline{try}. Исключения, возникшие в блоке \lstinline{else} не обрабатываются предыдущими ему обработчиками.

Блок \lstinline{finally} выполняется всегда, где бы исключительная ситуация не возникла: внутри блок \lstinline{try}, \lstinline{except} или же \lstinline{else}.
