\chapter{Язык программирования Python}
\label{ch:python}

\section{Операторы}
\label{sec:py-statements}

\subsubsection{Оператор if}
Общая форма оператора \lstinline{if} выглядит следующим образом:
\begin{pylst}{}{}
if $expression$: $suite$
( elif $expression$: $suite$)*
[ else: $suite$ ]
\end{pylst}

Этот оператор вычисляет последовательно выражения $expression$ до тех пор, пока не будет найдено равное \lstinline{true}. После чего выполняется соответсвующее $suite$. Если все выражения оказались равными \lstinline{false}, то выполняются операторы и выражения из \lstinline{else} ветки. Выполняется не больше одного набора операторов и выражений ($suite$).

\subsubsection{Оператор while}
Общая форма оператора \lstinline{while} выглядит следующим образом:
\begin{pylst}{}{}
while $expression$: $suite_1$
[ else: $suite_2$ ]
\end{pylst}

Выполняет $suite_1$ пока $expression$ истинно. Если в первый раз $expression$ оказалось ложно, выполняется ветка \lstinline{else}, после чего цикл завершается. Оператор \lstinline{break} завершает цикл без выполнения ветки \lstinline{else}. Оператор \lstinline{continue} передает управление на начало цикла.

\subsubsection{Оператор for}
Общая форма оператора \lstinline{for} выглядит следующим образом:
\begin{pylst}{}{}
for $variable$ in $expression$: $suite_1$
[ else: $suite_2$ ]
\end{pylst}

$expression$ вычисляется единожды. Оно должно вычислятся в итерируемый объект. Затем $suite_1$ вычисляется столько раз, сколько объектов в итерируемом объекте, при этом переменной $variable$ присваивается очередной объект. По завершении вычисляется ветка \lstinline{else}.

Оператор \lstinline{break} завершает цикл без выполнения ветки \lstinline{else}. Оператор \lstinline{continue} передает управление на начало цикла или, если больше нет очередного объекта, на ветку \lstinline{else}.

\subsubsection{Оператор try}
Общая форма оператора \lstinline{try} выглядит следующим образом:
\begin{pylst}{}{}
try: suite
( except [expression [ ( as | "," ) target ] ]: suite )+
[ else: suite ]
[ finally: suite ]
\end{pylst}
или
\begin{pylst}{}{}
try: suite
finally: suite
\end{pylst}

Блоки \lstinline{except} определяют обработчики исключительных ситуаций. Если в блоке \lstinline{try} не возникло исключительной ситуации, то ни один из обработчиков не выполняется. В ином случае происходит поиск подходящего обработчика последовательно по блокам \lstinline{except}. Блок \lstinline{except} без выражений $expression$, если таковой присутствует, должен быть последним. При поиске выражения $expression$ вычисляются, и блок выбирается для выполнения, если объект-результат подходит к возникшему исключению, т.е. если объект является классом, который присутствует в списке наследования объекта исключения, или же кортежем, в котором хотя бы один элемент является совместимым с исключением.

Если обработчик не найден, поиск происходит в обрамляющем коде и вверх дальше по стеку, если блок \lstinline{finally} не присутсвует.

Если при выполнении выражений $expression$ возникло исключение, то изначальное исключение отбрасывается, и начинается новый поиск для нового исключения в обрамляющем коде и вверх по стеку.

Если же подходящий блок \lstinline{except} найден, то $target$, если присутствует, присваивается результат вычисления $expression$, и блок исполняется. После чего управление передается, как правило, за пределы оператора \lstinline{try}.

В блоке обработчика можно вызвать \lstinline{sys.exc_info}, которая возвращает кортеж \lstinline{(exc_type, exc_value, exc_traceback)}, где \lstinline{exc_type} --- объект исключения, \lstinline{exc_value} --- параметры, переданные исключению, \lstinline{exc_traceback} --- traceback объект.

Блок \lstinline{else} выполняется в том случае, если управление достигло конца блока \lstinline{try}. Исключения, возникшие в блоке \lstinline{else} не обрабатываются предыдущими ему обработчиками.

Блок \lstinline{finally} выполняется всегда, где бы исключительная ситуация не возникла: внутри блок \lstinline{try}, \lstinline{except} или же \lstinline{else}.

\section{Функции}
Ниже приведено тривиальное определение функции:
\begin{pylst}{}{}
def add(a, b):
    return a + b
\end{pylst}

Как видно из примера, определение функции начинается с оператора \lstinline{def}, за которым идет имя функции, а следом --- аргументы, заключенные в круглые скобки. Возврат значения происходит посредством оператора \lstinline{return}. Если возврат из функции происходит из-за того, что управление достигло конца функции, то возвращаемое значение равно \lstinline{None}. Определение функции связывает её имя с объектом функции (обёрткой над действительно исполняемым кодом) в текущем пространсве имён. Объект функции содержит ссылку на текущее глобальное пространство имён, которое будет использоваться при вызове функции.

Определение функции может быть обёрнуто декораторами. Декораторы вычисляются во время определения функции в том же самом контексте, где находится определение функции.

Функция может иметь именованные аргументы, которые имеют значение по умолчанию. При вызове функции не обязательно передавать именованные аргументы, если устраивает значение по умолчанию. В определении функции после именованного аргумента могут идти только именованные аргументы.

Значения по умолчанию для именованных аргументов вычисляются один раз при выполнении определения функции. После чего при любом вызове используется один и тот же объект. Если значение по умолчанию --- изменяемый (mutable) объект, то можно наткнуться на неприятности, что и проиллюстрировано ниже:
\begin{pylst}{}{}
def append(list=[]):
    list.append('a')
    return list

>>> append()
['a']
>>> append()
['a', 'a']
>>> append()
['a', 'a', 'a']
\end{pylst}

Ниже представлена версия, лишенная приведенного недостатка:
\begin{pylst}{}{}
def append(list=None):
    if list is None:
        list = []
    list.append('a')
    return list

>>> append()
['a']
>>> append()
['a']
\end{pylst}

Если в определении функции присутствует форма \lstinline{*identifier}, то \lstinline{identifier} будет равен кортежу, который содержит все аргументы, которые не были явно проименованы. Если же присутствует форма \lstinline{**identifier}, то \lstinline{identifier} будет словарём, который отображет имена аргументов на их значения.

При вызове если происходит ошибка разбора аргументов, их нехватка или избыток и так далее, то порождается исключение \lstinline{TypeError}. Если при вызове присутствует форма \lstinline{*identifier}, то \lstinline{identifier} должен вычисляться в последовательность, элементы которой будут считаться дополнительными позиционными аргументами. Если же при вызове присутсвует форма \lstinline{**identifier}, то \lstinline{identifier} должен вычисляться в словарь, ключи которого будут использоваться в качестве именованных аргументов, а значения --- в качестве значений этих аргументов.

Обе формы могут присутствовать одновременно как при определении функции, так и при вызове.

\subsubsection{Анонимные функции}
\emph{Анонимные (безымянные) функции} в Python --- объекты функций, которые не имеют имени ни в каком пространстве имён после \emph{непосредственного} определения. Они определяются с помощью лямбда-выражений:
\begin{pylst}{}{}
lambda [ $parameters$ ]: $expression$
\end{pylst}

В отличии от обычного определения функции лямбда-выражение не может содержать операторов (statements).
\begin{pylst}{}{}
>>> map(lambda i: i + 1, [1, 2, 3])
[2, 3, 4]
\end{pylst}

\section{Функциональное программирование}
В Python возможно использовать некоторые идеи и концепции функционального программирования.

\subsection{Функции высшего порядка}
Функция высшего порядка --- функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата.
\begin{pylst}{}{}
def f(x):
    return x + 3
 
def g(function, x):
    return function(x) * function(x)
 
>>> g(f, 7)
100
\end{pylst}

Ниже представлены наиболее общеупотребимые функции высшего порядка, определенные в Python.

\subsubsection{Функция map}
\lstinline{map} --- функция высшего порядка, которая применяет переданную функция к элементам одной или нескольких последовательностей. Количество аргументов переданной функции должно быть равно количеству переданных последовательностей. Если последовательности не одинаковой длины, то вместо недостающих элементов используется \lstinline{None}. Длина результирующего списка равна длине наибольшего списка. Если вместо функции передается \lstinline{None}, тогда элементы последовательностей никак не преобразуются, а используются как есть. Если последовательностей --- несколько, то результатом будет список кортежей.
\begin{pylst}{}{}
map(function, sequence[, sequence, ...]) -> list

>>> map(lambda x, y: x + y, [1, 2, 3], [2, 3, 4])
[3, 5, 7]
>>> map(None, [1, 2], [3])
[(1, 3), (2, None)]
\end{pylst}

\subsubsection{Функция filter}
\lstinline{filter} --- функция высшего порядка, которая конструирует итоговый список из элементов переданной последовательности, если конкретный элемент удовлетворяет функции-предикату. Если в качестве последовательности передается строка или кортеж, то и тип результата будет строка или кортеж, соответственно. Если функция равна \lstinline{None}, то возвращаются элементы, которые истинны.
\begin{pylst}{}{}
filter(function or None, sequence) -> list, tuple, or string

>>> filter(lambda x: x % 2, [1, 2, 3, 4, 5])
[1, 3, 5]
\end{pylst}

\subsubsection{Функция reduce}
\lstinline{reduce} --- функция высшего порядка, которая делает свёртку последовательности, в результате чего получается, как правило, значение типа элемента последовательности. Функция свёртки обычно принимает три аргумента: комбинирующую функцию \lstinline{function}, начальное значение \lstinline{initial} и последовательность \lstinline{sequence}.
\begin{pylst}{}{}
reduce(function, sequence[, initial]) -> value
\end{pylst}

$4!$ можно вычислить следующим образом, используя функцию \lstinline{reduce}:
\begin{pylst}{}{}
>>> reduce(lambda res, x: res * x, range(2, 4 + 1), 1)
24
\end{pylst}

Вычисление происходит следующим образом:
\begin{center}
  \begin{tikzpicture}[level/.style={sibling distance=50mm/#1}]
    \node [circle, draw] {$*$}
      child { node [circle, draw] {$*$}
        child { node [circle, draw] {$*$} 
          child { node [circle, draw] {$1$} }
          child { node [circle, draw] {$2$} } }
        child { node [circle, draw] {$3$} } }
      child { node [circle, draw] {$4$} };
  \end{tikzpicture}
\end{center}

Другая иллюстрация:
\begin{pylst}{}{}
(((1 * 2) * 3) * 4)
\end{pylst}

\subsection{Рекурсия}
Хоть в Python и существует рекурсия, но в наиболее популярной реализации этого языка --- CPython --- она не православна, так как там нет оптимизации хвостовых вызовов (tail call optimization, TCO).

Хвостовая рекурсия --- специальный случай рекурсии, при котором последней операцией, выполняемой рекурсивной функцией, является вызов самой себя. Подобный вид рекурсии примечателен тем, что может быть легко и автоматически заменён на итерацию, что и делают многие оптимизирующие компиляторы. Подобные рассуждения справедливы и для взаимно рекурсивных функций, хоть TCO для них в компиляторах встречается еще реже.

\begin{pylst}{}{}
def infinite():
    infinite()

# shortly somewhere in a far far away galaxy
>>> infinite()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
...
RuntimeError: maximum recursion depth exceeded
\end{pylst}

Получить и установить максимальное возможное количество рекурсивные вызовов можно с помощью функцией \lstinline{sys.getrecursionlimit} и \lstinline{sys.setrecursionlimit(limit)}.

\subsection{Замыкания}
Замыкание --- первоклассная функция со свободными переменными, которые связаны с определенными значениями в своем лексическом окружении. Свободная переменная --- переменная, которая встречается в теле функции, но которая не является параметром этой функции или локальной переменной.
\begin{pylst}{}{}
def make_adder(y):
    def add(x):
        return x + y
    return add

>>> add5 = make_adder(5)
>>> add5(5)
10
>>> add5(7)
12
\end{pylst}

Замыкание \lstinline{add} создается при каждом вызове функции \lstinline{make_adder}. Замыкании \lstinline{add} переменная \lstinline{y} является свободной переменной.

Замыкания в Python также не доведены до логического конца, хоть в версиях $>=3.0$ уже такая претензия есть. В версии 3.0 введен оператор \lstinline{nonlocal}, суть которого видна из следующего примера:
\begin{pylst}{}{}
def make_counter():
    count = 0
    def get():
        return count
    def inc():
        count += 1

    return get, inc

>>> get, inc = make_counter()
>>> get()
>>> 0
>>> inc()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/tmp/py9637pml", line 11, in inc
UnboundLocalError: local variable 'count' referenced before assignment

def make_counter():
    count = 0
    def get():
        nonlocal count
        return count
    def inc():
        count += 1

    return get, inc

>>> get, inc = make_counter()
>>> get()
>>> 0
>>> inc()
>>> get()
1
\end{pylst}

\subsection{Частичное применение функции}
Частичное применение функции --- это преобразование функции от $n$ аргументов к функции от $n - m$ аргументов ($m < n$), в которой $m$ аргументов привязаны к определенным значениям. То есть некоторые аргументы изначальной функции фиксируются.

Эта возможность предоставляется стандартной библиотекой Python:
\begin{pylst}{}{}
from functools import partial
basetwo = partial(int, base=2)

>>> basetwo('10010')
18
\end{pylst}

\section{Декораторы}
\label{sec:py-decorators}
Декоратор --- объект, который можно вызвать с одним аргументом. Он волен делать с переданным аргументом всё, что угодно, лишь бы программа оставалась корректной.
\begin{pylst}{}{}
def debug(func):
    def wrapped(*args, **kwargs):
        print "%s called with: %s, %s" % (func.__name__, args, kwargs)
        ret = func(*args, **kwargs)
        print "%s returned: %s" % (func.__name__, ret)
        return ret
    return wrapped

@debug
def inc(i):
    return i + 1
\end{pylst}

@-синтаксис введен всего лишь для удобства. Вышеопределенное декорирование эквивалентно следующему:
\begin{pylst}{}{}
def inc(i):
    return i + 1

inc = debug(inc)
\end{pylst}

Пример вызова декорированной функции \lstinline{inc}:
\begin{pylst}{}{}
>>> inc(1)
inc called with: (1,), {}
inc returned: 2
\end{pylst}

\subsection{Примеры декораторов}
\subsubsection{Псевдокаррирование}
Каррирование или карринг (англ. currying) в информатике --- преобразование функции от пары аргументов в функцию, берущую свои аргументы по одному.
\begin{pylst}{}{}
class curried(object):
    def __init__(self, func, *a):
        self.func = func
        self.args = a

    def __call__(self, *a):
        args = self.args + a
        if len(args) < self.func.__code__.co_argcount:
            return curried(self.func, *args)
        else:
            return self.func(*args)

@curried
def add(a, b):
    return a + b

add1 = add(1)
print add1(2)
\end{pylst}

\subsubsection{Синхронизация}
Декорированная функция пытается захватить взаимное исключение перед тем, как исполняться.

\begin{pylst}{}{}
def synchronized(lock):
    def wrap(f):
        def sync(*args, **kwargs):
            lock.acquire()
            try:
                return f(*args, **kwargs)
            finally:
                lock.release()
        return sync
    return wrap

# Example usage:

from threading import Lock
lock = Lock()

@synchronized(lock)
def critical_one(*args):
    pass

@synchronized(lock)
def critical_two(*args):
    pass
\end{pylst}

\subsubsection{Декоратор, муштрующий декораторы}
Есть проблема с декорированной функции, например, ее свойство \lstinline{__name__} больше не равно ее действительному имени после декорирования. Следующий декоратор, призванный декорировать другие декораторы, этот досадный недостаток устраняет.
\begin{pylst}{}{}
def well_behaved(decorator):
    def new_decorator(f):
        g = decorator(f)
        g.__name__ = f.__name__
        g.__doc__ = f.__doc__
        g.__dict__.update(f.__dict__)
        return g
    new_decorator.__name__ = decorator.__name__
    new_decorator.__doc__ = decorator.__doc__
    new_decorator.__dict__.update(decorator.__dict__)
    return new_decorator

# Sample Use:

synchronized = well_behaved(synchronized)
\end{pylst}

\section{Метаклассы}
В Python классы --- такие же объекты, как и всё остальное. Их можно передавать в качестве аргументов функциям или рассматривать под микроскопом. Так же как класс определяет поведение объектов, так и метакласс определяет поведение своих классов. Самый распростаненный метакласс в Python --- \lstinline{type}.

\begin{pylst}{}{}
>>> object.__class__
<type 'type'>
>>> type(object)
<type 'type'>
\end{pylst}

Часто метаклассы используются как фабрики. Когда Python создает новый класс (при выполнении оператора \lstinline{class}), он вызывает метакласс. Метакласс в свою очередь может поместить класс в какой-нибудь регистр или же вернуть \emph{совсем} другой класс. Для подавляющего большинства --- если не всех --- встроенных типов метаклассом является метакласс \lstinline{type}.

\begin{pylst}{}{}
# prototype
type(name, bases, dict)
\end{pylst}
где \lstinline{name} --- имя нового класса, \lstinline{bases} --- последовательность базовый классов (может быть пустой), а \lstinline{dict} --- словарь, ключи которого являются именами аттрибутов создаваемого класса, а значения --- значениями этих аттрибутов.

Определение
\begin{pylst}{}{}
class MyClass(BaseClass):
    attribute = 42
\end{pylst}
эквивалентно
\begin{pylst}{}{}
MyClass = type("MyClass", (BaseClass,), { 'attribute' : 42 })
\end{pylst}

Метакласс для класса указывается с помощью поля \lstinline{__metaclass__}. В метаклассе можно (пере)определять любые методы, как и в любом классе, с тем отличием, что методам класса передается экземпляр первым аргументом (отсюда и общеупотребимое \lstinline{self}), а методам метакласса --- класс. Поэтому первый аргумент часто именуется \lstinline{cls}.

\begin{pylst}{}{}
class UselessType(type):
    def __new__(cls, name, bases, dct):
        print "Allocating memory for class", name
        return type.__new__(cls, name, bases, dct)

    def __init__(cls, name, bases, dct):
        print "Init'ing (configuring) class", name
        super(UselessType, cls).__init__(name, bases, dct)

    def __call__(cls, *args, **kwargs):
        print "Calling %s" % cls.__name__
        return super(UselessType, cls).__call__(*args, **kwargs)

    def whoami(cls):
        print cls.__name__

class UselessClass(object):
    __metaclass__ = UselessType

>>> UselessClass.whoami()
UselessClass
>>> UselessClass()
Calling <class '__main__.UselessClass'>
\end{pylst}

Когда выполняется оператор \lstinline{class}, Python вначале выполняет внутреннее содержимое как обычный блок кода. В результате получается пространство имен, представленное словарем. Затем Python ищет метакласс для создаваемого класса в следующей последовательности:
\begin{enumerate}
  \item Если \lstinline{dict['__metaclass__']} существуют, то используется он.
  \item В ином случае, если у класса есть базовые классы, их метакласс используется (сначала проверяется аттрибут \lstinline{__class__}, и если такого нет, то исползуется тип базового класса).
  \item В ином случае, если есть глобальная переменная \lstinline{__metaclass__}, то используется она.
\end{enumerate}

После чего метакласс вызывается с именем вновь создаваемого класса, его базовыми классами и словарем аттрибутов как аргументами.

Полю \lstinline{__metaclass__} можно присваивать не только метаклассы, но и любой вызываемый (callable) объект, который принимает три аргумента.
\begin{pylst}{}{}
def meta(name, bases, dct):
    # setting useless attr
    dct['foo'] = 'bar'
    return type(name, bases, dct)

class Bar(object):
    __metaclass__ = meta

>>> Bar().foo
'bar'
\end{pylst}

Следом идет реализация паттерна Singleton с помощью метакласса:
\begin{pylst}{}{}
class SingletonMetaclass(type):
    instance = None

    def __call__(cls, *args, **kwargs):
        if cls.instance is None:
            cls.instance = super(SingletonMetaclass, cls).__call__(
                *args, **kwargs)
        return cls.instance

class Foo(object):
     __metaclass__ = SingletonMetaclass

>>> Foo() is Foo()
True
\end{pylst}

Как говорится в руководстве по Python, области применения метаклассов безграничны, что, конечно же, является бесстыдным враньём. Вот несколько из общеизвестных применений: logging, проверка интерфейсов, автоматическое делегирование, автоматическое создание свойств класса, прокси, ORM и автоматическая синхронизация/захват ресурса.
