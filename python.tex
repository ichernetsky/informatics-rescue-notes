\chapter{Язык программирования Python}
\label{ch:python}

Чтобы попробовать \emph{Python}, достаточно запустить REPL (от \emph{Read, Eval, Print, Loop}), введя в командной оболочке \lstinline{python} (а ещё лучше \lstinline{ipython}). Запустится интерпретатор \emph{Python}, ожидающий ввода. Можно вводить конструкции языка — и немедленно получать результат исполнения.

\begin{plainlst}{Пример минимальной сессии}{}
% ipython
Python 2.7.2 (default, Jun 29 2011, 15:07:32)
Type "copyright", "credits" or "license" for more information.

IPython 0.10.2 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object'. ?object also works, ?? prints more.

In [1]: 2 ** 32
Out[1]: 4294967296

In [2]: dir(None)
Out[2]:
['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__',
 '__hash__', '__init__', '__new__', '__reduce__', '__reduce_ex__',
 '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']

In [3]: map?
Type:		builtin_function_or_method
Base Class:	<type 'builtin_function_or_method'>
String Form:	<built-in function map>
Namespace:	Python builtin
Docstring:
    map(function, sequence[, sequence, ...]) -> list

    Return a list of the results of applying the function to the items of
    the argument sequence(s).  If more than one sequence is given, the
    function is called with an argument list consisting of the corresponding
    item of each sequence, substituting None for missing values when not all
    sequences have the same length.  If the function is None, return a list
    of the items of the sequence (or a list of tuples if more than one
    sequence).
\end{plainlst}

\section{Типы и структуры данных и операции над ними}
\label{sec:py-types}

\emph{Python} — динамически типизированный язык. Типы принадлежат объектам, не переменным. Переменные лишь связываются с объектами, то есть они всего лишь имена. \emph{Python} — строго типизированный язык. Все типы проверяются во время исполнения. Если обнаруживается какое-либо несоответствие типов, то возникает исключение, как правило, \lstinline{TypeError} или \lstinline{AttributeError}.

Все объекты деляется на \emph{ссылочные} и \emph{атомарные}. При присваивании атомарных объектов они копируются, в то время как при присваивании ссылочных объектов копируются только ссылки на них. Ссылочные объекты могут быть \emph{изменяемыми} или \emph{неизменяемыми} (\emph{mutable} и \emph{immutable} соответственно).

\subsection{NoneType}
Единственным экземпляром этого типа является константа \lstinline{None}. Используется для обозначение того факта, что значения нет, например, «функция ничего не возвращает». С \lstinline{None} можно использовать операции сравнения\footnote{В \emph{Python} 2.x можно использовать и операторы отношения порядка, в 3.x — только операторы равенства.} и т.п.

\subsection{Булев тип}
\lstinline{False} — ложное значение булева типа, а \lstinline{True} — истинное значение.

Любой объект может быть проверен на истинность (как все просто!) для использования в операторах \lstinline{if} и \lstinline{while}. Следующие значения считаются ложными:
\begin{itemize}
  \item \lstinline{None};
  \item \lstinline{False};
  \item нуль любого числового типа;
  \item любая пустая последовательность;
  \item любое пустое отображение (словарь);
  \item экземпляр класса, определенного пользователем, если в классе определены \lstinline{__nonzero__()} или \lstinline{__len__()} методы, и они возвращают нуль или \lstinline{False} соответственно.
\end{itemize}

\begin{pylst}{}{}
class Zero(object):
    def __nonzero__(self):
        return False

class ZeroLen(object):
    def __len__(self):
        return 0

>>> bool(Zero())
False

>>> bool(ZeroLen())
False

>>> bool({})
False

>>> bool([])
False
\end{pylst}

Все остальные значения считаются истинными.

\subsubsection{Булевы операции}

\lstinline{x or y}. Если \lstinline{x} истинен, то результат выражения — \lstinline{x}, иначе — \lstinline{y}. Правый аргумент вычисляется, только если левый — ложен.

\begin{pylst}{}{}
>>> 0 or 2 or 1 or 0
2
\end{pylst}

\lstinline{x and y}. Если \lstinline{x} — ложен, то он вычисляется и является результатом, и в этом случае \lstinline{y} не вычисляется. Иначе вычисляется \lstinline{y}, и результат вычисления становится значением всего выражения.

\begin{pylst}{}{}
>>> 1 and 2 and 0 and 3
0
\end{pylst}

\lstinline{not x}. Отрицание \lstinline{x}. Если он истинен, то значение выражения — \lstinline{False}, и наоборот.

\subsection{Числовые типы}
Четыре числовых типа: \lstinline{int}, \lstinline{long}, \lstinline{float} и \lstinline{complex}. \lstinline{int} соответсвует \lstinline{long} языка C. Для типа \lstinline{long} языка Python нет ограничений на размер числа. \lstinline{float} языка Python реализован с помощью типа \lstinline{double} языка C. Комплексные числа имеют действительную и мнимую составляющие, каждая из которые представлена \lstinline{double} языка C.

\begin{pylst}{Работа с числовыми типами}{}
>>> x, y = 5, 7
>>> x + y, x / y, y % x
12, 0, 2
>>> x ** y ** 2
17763568394002504646778106689453125L
>>> abs(-x)
5
>>> x, y = 3.5, 23.3
>>> round(x), y / x
4.0, 6.6571428571428575
>>> z = 1.3 + 0.5j
>>> z.imag
0.5
\end{pylst}

Python предоставляет все стандартные побитовые операции над целыми числами: \lstinline{|} (побитовое ИЛИ), \lstinline{^} (побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ), \lstinline{&} (побитовое И), \lstinline{<<} (сдвиг влево), \lstinline{>>} (сдвиг вправо) и \lstinline{~} (побитовое НЕ).

\subsection{Последовательности}
Четыре типа последовательности: \lstinline{string} (строки), \lstinline{unicode} (юникодные строки), \lstinline{list} (списки), \lstinline{tuple} (кортежи).

Все последовательности поддерживают следующие операции:
\begin{center}
  \begin{tabular}{lp{7.5cm}}
    \toprule
    Операция & Результат \\
    \midrule
    \texttt{x in s} & Истина, если какой-либо элемент из \texttt{s} равен \texttt{x} \\
    \texttt{x not in s} & Истина, если ни один элемент из \texttt{s} не равен \texttt{s} \\
    \texttt{s + t} & Сцепка \texttt{s} и \texttt{t} \\
    \texttt{s * n} & Сцепка \texttt{s} с собой \texttt{n} раз \\
    \texttt{s[i]} & Доступ по индексу \texttt{i} \\
    \texttt{s[i:j]} & Срез от \texttt{i} до \texttt{j} \\
    \texttt{s[i:j:k]} & Срез от \texttt{i} до \texttt{j} с шагом \texttt{k} \\
    \texttt{len(s)} & Длина \texttt{s} \\
    \texttt{min(s)} & Минимальный элемент в \texttt{s} \\
    \texttt{max(s)} & Максимальный элемент в \texttt{s} \\
    \bottomrule
  \end{tabular}
\end{center}

\begin{pylst}{Работа с последовательностями}{}
>>> s = 'not so long string '
>>> 'l' in s, 'l' not in s
True, False
>>> s + '...'
'not so long string ...'
>>> s * 2
'not so long string not so long string '
>>> s[10], s[1:6], s[1:9:2]
'g', 'ot so', 'o ol'
>>> len(s)
19
\end{pylst}

\subsubsection{Строки}
Строка в Python --- неизменяемый тип данных. Все операции над последовательностями работают и со строками. Ниже проиллюстрированы часто употребляемые методы:
\begin{pylst}{}{}
>>> s = 'In the very beginning...'
>>> s.count('in')
2
>>> s.startswith('in')
False
>>> ', '.join(['a', 'b', 'c'])
'a, b, c'
>>> s.upper()
'IN THE VERY BEGINNING...'
>>> s.partition(' ')
('In', ' ', 'the very beginning...')
>>> s.split(' ')
['In', 'the', 'very', 'beginning...']
>>> '%s there was actually nothing' % s
'In the very beginning... there was actually nothing'
\end{pylst}

Строковые литералы могут быть трёх видов:
\begin{itemize}
  \item \lstinline{'string'} или \lstinline{"string"}.
  \item \lstinline{'''string'''} или \lstinline{"""string"""}. Может занимать несколько строк.
  \item \lstinline{r'string'} или \lstinline{r"string"}. Специальные символы не надо экранировать.
\end{itemize}

\subsubsection{Списки}
Список в Python --- изменяемая структура данных. Все операции над последовательностями применимы и к спискам. В таблице~\ref{tbl:py-listops} приведены некоторые операции, специфичные для списков.
\begin{table}[h!]
  \begin{center}
    \caption{Дополнительные операции над списками\label{tbl:py-listops}}
    \begin{tabular}{lp{9cm}}
      \toprule
      Операция & Результат \\
      \midrule
      \texttt{s[i] = x} & Замещает элемент на позиции \texttt{i} переменной \texttt{x} \\
      \texttt{s[i:j] = t} & Срез от \texttt{i} до \texttt{j} замещается содержимым итератора \texttt{t} \\
      \texttt{del s[i:j]} & То же, что и \texttt{s[i:j] = []} \\
      \texttt{s[i:j:k] = t} & Элементы \texttt{s[i:j:k]} замещаются содержимым \texttt{t} \\
      \texttt{del s[i:j:k]} & Удаляет элементы \texttt{s[i:j:k]} из списка \\
      \texttt{s.append(x)} & Добавляет элемент в конец списка \\
      \texttt{s.extend(x)} & То же самое, что и \texttt{s[len(s):len(s)] = x} \\
      \texttt{s.insert(i, x)} & То же самое, что и \texttt{s[i:i] = [x]} \\
      \texttt{s.pop([i])} & То же самое, что и \texttt{x = s[i]; del s[i]; return x} \\
      \texttt{s.remove(x)} & То же самое, что и \texttt{del s[s.index(x)]} \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

\subsubsection{Кортежи}
Кортеж --- это неизменяемая последовательность элементов. Нельзя ни удалять элементы из кортежа, ни добавлять, ни изменять. Примеры создания кортежей:
\begin{pylst}{}{}
>>> tuple([1, 2, 3])
(1, 2, 3)
>>> ('a', 'b', 'c')
\end{pylst}

\subsection{Словари}
Словарь --- изменяемая структура данных. Он отображает хешируемые значения на любые объекты.
\begin{pylst}{Примеры создания словаря}{}
dict(one=2, two=3)
dict({'one': 2, 'two': 3})
dict(zip(('one', 'two'), (2, 3)))
dict([['two', 3], ['one', 2]])
\end{pylst}

Некоторые операции над словарём \texttt{d}:
\begin{itemize}
  \item \lstinline{d[key]}. Возвращает объект, ассоциированный с ключом \lstinline{key}. Если такового нет --- \lstinline{KeyError}.
  \item \lstinline{d[key] = value}. Ассоциирует объект \lstinline{value} с ключом \lstinline{key}.
  \item \lstinline{del d[key]}. Удаляет объект, ассоциированный с ключом \lstinline{key}.
  \item \lstinline{key in d}. \lstinline{True}, если \lstinline{d} имеет ключ \lstinline{key}.
  \item \lstinline{key not in d}. Обратно.
  \item \lstinline{iter(d)}. Возвращает итератор по ключам словаря.
  \item \lstinline{clear()}. Удаляет все элементы из словаря.
  \item \lstinline{items()}. Возвращает список пар вида \lstinline{(key, value)}.
  \item \lstinline{iteritems()}. Возвращает итератор по \lstinline{items()}.
  \item \lstinline{iterkeys()}. Возвращает итератор по ключам.
  \item \lstinline{itervalues()}. Возвращает итератор по ассоциированным объектам.
  \item \lstinline{keys()}. Список всех ключей.
  \item \lstinline{values()}. Список ассоциированных объектов.
  \item \lstinline{update([other])}. Обновляет словарь элементами словаря \lstinline{other}.
\end{itemize}

\subsection{Множества}
Очень похожи на математические множества. Поддерживает операции объединения, пересечения, вычитания и различные проверки. Некоторые операции:
\begin{itemize}
  \item \lstinline{isdisjoint(other)}. Возвращает \lstinline{True}, если множества не имею одинаковых элементов.
  \item \lstinline{issubset(other)} или \lstinline{set <= other}. Проверяет, все ли элементы первого множества присутствуют во втором.
  \item \lstinline{issuperset(other)} или \lstinline{set >= other}. По аналогии.
\end{itemize}

\section{Операторы}
\label{sec:py-statements}

\subsubsection{Оператор if}
Общая форма оператора \lstinline{if} выглядит следующим образом:
\begin{pylst}{}{}
if $expression$: $suite$
( elif $expression$: $suite$)*
[ else: $suite$ ]
\end{pylst}

Этот оператор вычисляет последовательно выражения $expression$ до тех пор, пока не будет найдено равное \lstinline{true}. После чего выполняется соответсвующее $suite$. Если все выражения оказались равными \lstinline{false}, то выполняются операторы и выражения из \lstinline{else} ветки. Выполняется не больше одного набора операторов и выражений ($suite$).

\subsubsection{Оператор while}
Общая форма оператора \lstinline{while} выглядит следующим образом:
\begin{pylst}{}{}
while $expression$: $suite_1$
[ else: $suite_2$ ]
\end{pylst}

Выполняет $suite_1$ пока $expression$ истинно. Если в первый раз $expression$ оказалось ложно, выполняется ветка \lstinline{else}, после чего цикл завершается. Оператор \lstinline{break} завершает цикл без выполнения ветки \lstinline{else}. Оператор \lstinline{continue} передает управление на начало цикла.

\subsubsection{Оператор for}
Общая форма оператора \lstinline{for} выглядит следующим образом:
\begin{pylst}{}{}
for $variable$ in $expression$: $suite_1$
[ else: $suite_2$ ]
\end{pylst}

$expression$ вычисляется единожды. Оно должно вычислятся в итерируемый объект. Затем $suite_1$ вычисляется столько раз, сколько объектов в итерируемом объекте, при этом переменной $variable$ присваивается очередной объект. По завершении вычисляется ветка \lstinline{else}.

Оператор \lstinline{break} завершает цикл без выполнения ветки \lstinline{else}. Оператор \lstinline{continue} передает управление на начало цикла или, если больше нет очередного объекта, на ветку \lstinline{else}.

\subsubsection{Оператор try}
Общая форма оператора \lstinline{try} выглядит следующим образом:
\begin{pylst}{}{}
try: suite
( except [expression [ ( as | "," ) target ] ]: suite )+
[ else: suite ]
[ finally: suite ]
\end{pylst}
или
\begin{pylst}{}{}
try: suite
finally: suite
\end{pylst}

Блоки \lstinline{except} определяют обработчики исключительных ситуаций. Если в блоке \lstinline{try} не возникло исключительной ситуации, то ни один из обработчиков не выполняется. В ином случае происходит поиск подходящего обработчика последовательно по блокам \lstinline{except}. Блок \lstinline{except} без выражений $expression$, если таковой присутствует, должен быть последним. При поиске выражения $expression$ вычисляются, и блок выбирается для выполнения, если объект-результат подходит к возникшему исключению, т.е. если объект является классом, который присутствует в списке наследования объекта исключения, или же кортежем, в котором хотя бы один элемент является совместимым с исключением.

Если обработчик не найден, поиск происходит в обрамляющем коде и вверх дальше по стеку, если блок \lstinline{finally} не присутсвует.

Если при выполнении выражений $expression$ возникло исключение, то изначальное исключение отбрасывается, и начинается новый поиск для нового исключения в обрамляющем коде и вверх по стеку.

Если же подходящий блок \lstinline{except} найден, то $target$, если присутствует, присваивается результат вычисления $expression$, и блок исполняется. После чего управление передается, как правило, за пределы оператора \lstinline{try}.

В блоке обработчика можно вызвать \lstinline{sys.exc_info}, которая возвращает кортеж \lstinline{(exc_type, exc_value, exc_traceback)}, где \lstinline{exc_type} --- объект исключения, \lstinline{exc_value} --- параметры, переданные исключению, \lstinline{exc_traceback} --- traceback объект.

Блок \lstinline{else} выполняется в том случае, если управление достигло конца блока \lstinline{try}. Исключения, возникшие в блоке \lstinline{else} не обрабатываются предыдущими ему обработчиками.

Блок \lstinline{finally} выполняется всегда, где бы исключительная ситуация не возникла: внутри блок \lstinline{try}, \lstinline{except} или же \lstinline{else}.

\subsubsection{Оператор with}
Общая форма оператора \lstinline{with} выглядит следующим образом:
\begin{pylst}{}{}
with $expression$ [ as $target$ ]: $suite$
\end{pylst}

Схема работы следующая:
\begin{enumerate}
  \item $expression$ вычисляется.
  \item Вызывается метод \lstinline{__enter__()} у результата вычисления $expression$.
  \item Если использовалась форма \lstinline{as target}, то значение возвращенное из \lstinline{__enter__} присваивается $target$.
  \item Исполняется $suite$.
  \item Вызывается метод \lstinline{__exit__()}. Если возникло исключение при исполнении $suite$ и метод \lstinline{__exit__()} вернул \lstinline{False}, то исключение порождается вновь.
\end{enumerate}

\begin{pylst}{}{}
import threading

lock = threading.Lock()
with lock: ...
\end{pylst}

\section{Функции}
Ниже приведено тривиальное определение функции:
\begin{pylst}{}{}
def add(a, b):
    return a + b
\end{pylst}

Как видно из примера, определение функции начинается с оператора \lstinline{def}, за которым идет имя функции, а следом --- аргументы, заключенные в круглые скобки. Возврат значения происходит посредством оператора \lstinline{return}. Если возврат из функции происходит из-за того, что управление достигло конца функции, то возвращаемое значение равно \lstinline{None}. Определение функции связывает её имя с объектом функции (обёрткой над действительно исполняемым кодом) в текущем пространсве имён. Объект функции содержит ссылку на текущее глобальное пространство имён, которое будет использоваться при вызове функции.

Определение функции может быть обёрнуто декораторами. Декораторы вычисляются во время определения функции в том же самом контексте, где находится определение функции.

Функция может иметь именованные аргументы, которые имеют значение по умолчанию. При вызове функции не обязательно передавать именованные аргументы, если устраивает значение по умолчанию. В определении функции после именованного аргумента могут идти только именованные аргументы.

Значения по умолчанию для именованных аргументов вычисляются один раз при выполнении определения функции. После чего при любом вызове используется один и тот же объект. Если значение по умолчанию --- изменяемый (mutable) объект, то можно наткнуться на неприятности, что и проиллюстрировано ниже:
\begin{pylst}{}{}
def append(list=[]):
    list.append('a')
    return list

>>> append()
['a']
>>> append()
['a', 'a']
>>> append()
['a', 'a', 'a']
\end{pylst}

Ниже представлена версия, лишенная приведенного недостатка:
\begin{pylst}{}{}
def append(list=None):
    if list is None:
        list = []
    list.append('a')
    return list

>>> append()
['a']
>>> append()
['a']
\end{pylst}

Если в определении функции присутствует форма \lstinline{*identifier}, то \lstinline{identifier} будет равен кортежу, который содержит все аргументы, которые не были явно проименованы. Если же присутствует форма \lstinline{**identifier}, то \lstinline{identifier} будет словарём, который отображет имена аргументов на их значения.

При вызове если происходит ошибка разбора аргументов, их нехватка или избыток и так далее, то порождается исключение \lstinline{TypeError}. Если при вызове присутствует форма \lstinline{*identifier}, то \lstinline{identifier} должен вычисляться в последовательность, элементы которой будут считаться дополнительными позиционными аргументами. Если же при вызове присутсвует форма \lstinline{**identifier}, то \lstinline{identifier} должен вычисляться в словарь, ключи которого будут использоваться в качестве именованных аргументов, а значения --- в качестве значений этих аргументов.

Обе формы могут присутствовать одновременно как при определении функции, так и при вызове.

\subsubsection{Анонимные функции}
\emph{Анонимные (безымянные) функции} в Python --- объекты функций, которые не имеют имени ни в каком пространстве имён после \emph{непосредственного} определения. Они определяются с помощью лямбда-выражений:
\begin{pylst}{}{}
lambda [ $parameters$ ]: $expression$
\end{pylst}

В отличии от обычного определения функции лямбда-выражение не может содержать операторов (statements).
\begin{pylst}{}{}
>>> map(lambda i: i + 1, [1, 2, 3])
[2, 3, 4]
\end{pylst}

\section{Функциональное программирование}
В Python возможно использовать некоторые идеи и концепции функционального программирования.

\subsection{Функции высшего порядка}
Функция высшего порядка --- функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата.
\begin{pylst}{}{}
def f(x):
    return x + 3
 
def g(function, x):
    return function(x) * function(x)
 
>>> g(f, 7)
100
\end{pylst}

Ниже представлены наиболее общеупотребимые функции высшего порядка, определенные в Python.

\subsubsection{Функция map}
\lstinline{map} --- функция высшего порядка, которая применяет переданную функция к элементам одной или нескольких последовательностей. Количество аргументов переданной функции должно быть равно количеству переданных последовательностей. Если последовательности не одинаковой длины, то вместо недостающих элементов используется \lstinline{None}. Длина результирующего списка равна длине наибольшего списка. Если вместо функции передается \lstinline{None}, тогда элементы последовательностей никак не преобразуются, а используются как есть. Если последовательностей --- несколько, то результатом будет список кортежей.
\begin{pylst}{}{}
map(function, sequence[, sequence, ...]) -> list

>>> map(lambda x, y: x + y, [1, 2, 3], [2, 3, 4])
[3, 5, 7]
>>> map(None, [1, 2], [3])
[(1, 3), (2, None)]
\end{pylst}

\subsubsection{Функция filter}
\lstinline{filter} --- функция высшего порядка, которая конструирует итоговый список из элементов переданной последовательности, если конкретный элемент удовлетворяет функции-предикату. Если в качестве последовательности передается строка или кортеж, то и тип результата будет строка или кортеж, соответственно. Если функция равна \lstinline{None}, то возвращаются элементы, которые истинны.
\begin{pylst}{}{}
filter(function or None, sequence) -> list, tuple, or string

>>> filter(lambda x: x % 2, [1, 2, 3, 4, 5])
[1, 3, 5]
\end{pylst}

\subsubsection{Функция reduce}
\lstinline{reduce} --- функция высшего порядка, которая делает свёртку последовательности, в результате чего получается, как правило, значение типа элемента последовательности. Функция свёртки обычно принимает три аргумента: комбинирующую функцию \lstinline{function}, начальное значение \lstinline{initial} и последовательность \lstinline{sequence}.
\begin{pylst}{}{}
reduce(function, sequence[, initial]) -> value
\end{pylst}

$4!$ можно вычислить следующим образом, используя функцию \lstinline{reduce}:
\begin{pylst}{}{}
>>> reduce(lambda res, x: res * x, range(2, 4 + 1), 1)
24
\end{pylst}

Вычисление происходит следующим образом:
\begin{center}
  \begin{tikzpicture}[level/.style={sibling distance=50mm/#1}]
    \node [circle, draw] {$*$}
      child { node [circle, draw] {$*$}
        child { node [circle, draw] {$*$} 
          child { node [circle, draw] {$1$} }
          child { node [circle, draw] {$2$} } }
        child { node [circle, draw] {$3$} } }
      child { node [circle, draw] {$4$} };
  \end{tikzpicture}
\end{center}

Другая иллюстрация:
\begin{pylst}{}{}
(((1 * 2) * 3) * 4)
\end{pylst}

\subsection{Рекурсия}
Хоть в Python и существует рекурсия, но в наиболее популярной реализации этого языка --- CPython --- она не православна, так как там нет оптимизации хвостовых вызовов (tail call optimization, TCO).

Хвостовая рекурсия --- специальный случай рекурсии, при котором последней операцией, выполняемой рекурсивной функцией, является вызов самой себя. Подобный вид рекурсии примечателен тем, что может быть легко и автоматически заменён на итерацию, что и делают многие оптимизирующие компиляторы. Подобные рассуждения справедливы и для взаимно рекурсивных функций, хоть TCO для них в компиляторах встречается еще реже.

\begin{pylst}{}{}
def infinite():
    infinite()

# shortly somewhere in a far far away galaxy
>>> infinite()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
...
RuntimeError: maximum recursion depth exceeded
\end{pylst}

Получить и установить максимальное возможное количество рекурсивные вызовов можно с помощью функцией \lstinline{sys.getrecursionlimit} и \lstinline{sys.setrecursionlimit(limit)}.

\subsection{Замыкания}
Замыкание --- первоклассная функция со свободными переменными, которые связаны с определенными значениями в своем лексическом окружении. Свободная переменная --- переменная, которая встречается в теле функции, но которая не является параметром этой функции или локальной переменной.
\begin{pylst}{}{}
def make_adder(y):
    def add(x):
        return x + y
    return add

>>> add5 = make_adder(5)
>>> add5(5)
10
>>> add5(7)
12
\end{pylst}

Замыкание \lstinline{add} создается при каждом вызове функции \lstinline{make_adder}. Замыкании \lstinline{add} переменная \lstinline{y} является свободной переменной.

Замыкания в Python также не доведены до логического конца, хоть в версиях $>=3.0$ уже такая претензия есть. В версии 3.0 введен оператор \lstinline{nonlocal}, суть которого видна из следующего примера:
\begin{pylst}{}{}
def make_counter():
    count = 0
    def get():
        return count
    def inc():
        count += 1

    return get, inc

>>> get, inc = make_counter()
>>> get()
>>> 0
>>> inc()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/tmp/py9637pml", line 11, in inc
UnboundLocalError: local variable 'count' referenced before assignment

def make_counter():
    count = 0
    def get():
        nonlocal count
        return count
    def inc():
        count += 1

    return get, inc

>>> get, inc = make_counter()
>>> get()
>>> 0
>>> inc()
>>> get()
1
\end{pylst}

\subsection{Частичное применение функции}
Частичное применение функции --- это преобразование функции от $n$ аргументов к функции от $n - m$ аргументов ($m < n$), в которой $m$ аргументов привязаны к определенным значениям. То есть некоторые аргументы изначальной функции фиксируются.

Эта возможность предоставляется стандартной библиотекой Python:
\begin{pylst}{}{}
from functools import partial
basetwo = partial(int, base=2)

>>> basetwo('10010')
18
\end{pylst}

\subsection{Списковые включения}
Списковое включение (list comprehension) --- удобная конструкция для конструирования списков. Часто предпочтительней использовать именно списковые включения, а не набор функций \lstinline{map} и \lstinline{filter}. Суть видна из следующей демонстрации:
\begin{pylst}{}{}
>>> [i for i in range(10)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> [[i * j for j in range(5)] for i in range(5)]
[[0, 0, 0, 0, 0],
 [0, 1, 2, 3, 4],
 [0, 2, 4, 6, 8],
 [0, 3, 6, 9, 12],
 [0, 4, 8, 12, 16]]
>>> [i + j for i in range(3) for j in range(3)]
[0, 1, 2, 1, 2, 3, 2, 3, 4]
>>> [i + j for i in range(3) if i % 2 == 0 for j in range(3) if j % 2 == 1]
[1, 3]
\end{pylst}

\section{Модули}
\label{sec:py-modules}
Модуль представляет собой функционально законченный фрагмент программы, оформленный, как правило, в виде отдельного файла с исходным кодом, предназначенный для использования в других программах. Модули позволяют разбивать сложные задачи на более мелкие.

Модуль импортируются с помощью оператора \lstinline{import}. Модуль имеет пространство имён, представляющее собой словарь (это тот самый словарь, на который ссылает \lstinline{func_global} аттрибут любой определенной функции в этом модуле). Чтение аттрибута модуля \lstinline{m.x} эквивалентно поиску по ключу в словаре \lstinline{m.__dict__['x']}.

Каждый модуль имеет несколько специальных аттрибутов:
\begin{itemize}
  \item \lstinline{__name__} --- имя модуля;
  \item \lstinline{__doc__} --- строка документации модуля или \lstinline{None}, если её нет;
  \item \lstinline{__file__} --- путь к файлу, если таковой существует, из которого модуль был загружен.
\end{itemize}

Оператор \lstinline{import} имеет две формы:
\begin{pylst}{}{}
import $module$
from $module$ import ( $something$ [ as $someothername$ ] )+
\end{pylst}

Процесс импорта состоит из двух шагов:
\begin{enumerate}
  \item Поиск модуля и его инициализация, если необходима.
  \item Определение локальных имен в той области видимости, где находится сам оператор \lstinline{import}.
\end{enumerate}

Первая форма оператора делает как первый шаг, так и второй. Вторая же форма оператора выполняет первый шаг единожды, после чего повторяет второй шаг для всех импортируемых имён.

Модули и пакеты могут образовывать иерархию. Модули не могут содержать ни другие модули, ни другие пакеты. В то время как пакет может содержать как другие модули, так и другие пакеты. Если эту структуру отображать на файловую систему, то модулям сответствуют файлы, а пакетам --- директории.
\begin{plainlst}{}{}
edu
|
`__init__.py
 informatics
 |
 `__init__.py
  ai.py
\end{plainlst}

Пусть в \texttt{ai.py} определен класс \lstinline{NotSoIntelligent}. Тогда все следующие операции импорта корректны:
\begin{pylst}{}{}
import edu
from edu import informatics
from informatics import ai as infoai
from infoai import *

NotSoIntelligent()
\end{pylst}

Если при импортировании модуль не может быть найдет, то возникает исключение \lstinline{ImportError}. При использовании формы импорта модуля со звёздочкой в текущее пространство импортируются все публичные имена. Их список определяется в переменной \lstinline{__all__} модуля или же конструируется из всех глобальных имён импортируемого модуля.
\begin{pylst}{A.py}{}
__all__ = ['one']

one = 1
two = 2
\end{pylst}

\begin{pylst}{}{}
>>> from A import *
>>> one
1
>>> two
NameError: name 'two' is not defined
\end{pylst}

Импорт может быть относительным. Точка перед модулем значит, что путь до модуля нужно искать от того модуля, где происходит импорт. Если две точки, то начинать надо с уровня выше. И так далее. Например, если импорт \lstinline{from . import mod} происходит из модуля в пакете \lstinline{pkg}, то импортирован будет модуль \lstinline{pkg.mod}. Если же импорт \lstinline{from ..subpkg2 import mod} --- из пакета \lstinline{pkg.subpkg1}, импортирован модуль \lstinline{pkg.subpkg2.mod}.

При выполненении \lstinline{from mod import *} не импортируются имена, которые начинаются с \lstinline{_}. Модули можно подгружать динамически, используя встроенную функцию \lstinline{__import__}.


\section{Объектно-ориентированное программирование}
\label{sec:py-oop}
В Python всё --- объекты, и даже типы. Типы --- экземпляры \lstinline{type}. Python поддерживает множественное наследование и перегрузку операторов. Например, оператор \lstinline{+} можно перегрузить для объекта путём определения метода \lstinline{__add__}.

Простое определение класса:
\begin{pylst}{}{}
class MyClass(object):
    i = 12345
    def __init__(self):
        self.i = 54321
    def f(self):
        return self.i
\end{pylst}

Видно, что \lstinline{MyClass} отнаследован от класса \lstinline{object}. Если надо, чтобы объект наследовался от многих классов, то их надо записывать через запятую. В месте указания базовых классов может быть любое выражение, лишь бы результатом его вычисления был тип.
\begin{pylst}{}{}
def get_object():
    return object

class ExpChild(get_object()):
    pass
\end{pylst}

Если в классе определена переменная, а в методах выполняется \lstinline{self.var = value}, то тем самым определяется переменная экземпляра, которая затеняет переменную класса с тем же именем.
\begin{pylst}{}{}
>>> c = MyClass()
>>> c.i
54321
>>> MyClass.i
12345
\end{pylst}

Инициализация --- и только! --- происходит в методе \lstinline{__init__()}. Если надо контролировать процесс создания объекта, то следует переопределять \lstinline{__new__(cls[, ...])}, как один из вариантов.
\begin{pylst}{}{}
class Complex(object):
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

>>> c = Complex(5.1, 3.0)
>>> c.real, c.imag
(5.1, 3.0)
\end{pylst}

Также можно определять свойства:
\begin{pylst}{}{}
class C(object):
    x = 0
    def getx(self):
        return self._x
    def setx(self, value):
        self._x = value
    def delx(self):
        del self._x
    x = property(getx, setx, delx, "I'm the 'x' property.")

# another way

class C(object):
    x = 0
    @property
    def x(self):
        return self._x
    @x.setter
    def x(self, value):
        self._x = value
    @x.deleter
    def x(self):
        del self._x
\end{pylst}

\lstinline{getx()} будет вызываться при выражении \lstinline{x = instance.x}, \lstinline{setx(value)} будет вызываться при выражении \lstinline{instance.x = x}, а \lstinline{delx()} --- при \lstinline{del instance.x}.

Для вызовы методов базовых классов из какого-либо метода следует использовать встроенную функцию \lstinline{super(type[, object-or-type])}. Аттрибут \lstinline{__mro__} типа \lstinline{type} является списком типов, который определяет по каким типам и в каком порядке будет происходить поиск нужного метода при использовании функции \lstinline{super()}. \lstinline{__mro__} может изменяться, когда изменяется иерархия наследования.
\begin{pylst}{}{}
class A(object):
    def f(self):
        print 'A'

class B(A):
    def f(self):
        print 'B'
        super(B, self).f()

class C(A):
    def f(self):
        print 'C'
        super(C, self).f()

class D(B, C):
    def f(self):
        print 'D'
        super(D, self).f()

>>> D.__mro__
(<class '__main__.D'>,
 <class '__main__.B'>,
 <class '__main__.C'>,
 <class '__main__.A'>,
 <type 'object'>)

>>> D().f()
D
B
C
A
\end{pylst}

То есть \lstinline{__mro__} содержит линеаризованный граф с уникальными элементами, чтобы ни один метод какого-либо базового класса не вызывался несколько раз, если переопределенный метод достижим по нескольким путям.

Проверять отношения наследования функциями \lstinline{isinstance(object, class-or-type-or-tuple)} и \lstinline{issubclass(C, B)}.
\begin{pylst}{}{}
>>> issubclass(D, D), issubclass(D, A), isinstance(D(), A)
(True, True, True)
\end{pylst}

Статические методы и методы класса определяются следующим образом:
\begin{pylst}{}{}
class MyClass(object):
    @classmethod
    def clsmethod(cls):
        print cls, 'class'

    @staticmethod
    def statmethod()
        print 'static'
\end{pylst}

В Python возможно использовать не-очень-приватные поля:
\begin{pylst}{}{}
class C(object):
    def __init__(self):
        self.__private = 1

>>> c = C()
>>> dir(c)
['_C__private', '__class__', '__delattr__', '__dict__', '__doc__',
 '__format__', '__getattribute__', '__hash__', '__init__',
 '__module__', '__new__', '__reduce__', '__reduce_ex__',
 '__repr__', '__setattr__', '__sizeof__', '__str__',
 '__subclasshook__', '__weakref__']
\end{pylst}

То есть любое имя вида \lstinline{__*} внутри определения класса \lstinline{Class} преобразуется в \lstinline{_Class__*}.

\subsection{Специальные методы}

\subsubsection{Доступ к аттрибутам}
\begin{itemize}
  \item \lstinline{object.__getattr__(self, name)}. Вызывается, если аттрибут не найден обычном поиском. Должен вернуть имя аттрибута или же породить исключение \lstinline{AttributeError}.
  \item \lstinline{object.__setattr__(self, name, value)}. Вызывается всегда для установки значения \lstinline{value} аттрибуту с именем \lstinline{name}.
  \item \lstinline{object.__delattr__(self, name)}.
  \item \lstinline{object.__getattribute__(self, name)}. Вызывается всегда. Если порождает исключение \lstinline{AttributeError}, вызывается метод \lstinline{object.__getattr__(self, name)}.
\end{itemize}

\subsubsection{Реализация протокола дескриптора}
\begin{itemize}
  \item \lstinline{object.__get__(self, instance, owner)}
  \item \lstinline{object.__set__(self, instance, value)}
  \item \lstinline{object.__delete__(self, instance)}
\end{itemize}

Дескриптор --- это объект, который реализует хотя бы один из вышеперечисленных методов. Если у объекта \lstinline{obj} есть аттрибут \lstinline{d}, который в свою очередь есть дескриптор, то код \lstinline{obj.d} эквивалентен коду \lstinline{type(obj).__dict__['x'].__get__(obj, type(obj))}.

\begin{pylst}{Пример дескриптора}{}
import random

class Die(object):
    def __init__(self, sides=6):
        self.sides = sides

    def __get__(self, instance, owner):
        return int(random.random() * self.sides) + 1

class Game(object):
    d6 = Die()
    d10 = Die(sides=10)
    d20 = Die(sides=20)

>>> Game.d6
5
>>> Game.d10
8
>>> Game.d20
19
>>> Game.d20
3
\end{pylst}

\subsubsection{Настройка проверок экземпляров и подклассов}
\begin{itemize}
  \item \lstinline{class.__instancecheck__(self, instance)}. Возвращает \lstinline{True}, если \lstinline{instance} должен рассматриваться как экземпляр класса.
  \item \lstinline{class.__subclasscheck__(self, subclass)}. Возвращает \lstinline{True}, если \lstinline{subclass} должен рассматриваться как потомок класса.
\end{itemize}

\section{Итераторы и генераторы}
\label{sec:py-iterators}

\subsubsection{Итераторы}
Итератор --- объект, позволяющий перебирать все элементы коллекции. Для реализации итерирования коллекции необходимо переопределить метод \lstinline{__iter__()}, который возвращает объект с реализованными методами \lstinline{__iter__()} и \lstinline{next()}. Метод \lstinline{__iter__()} итератора должен возвращать сам же итератор, чтобы как объекты, так и итераторы можно было использовать, например, с оператором \lstinline{for}. Метод \lstinline{next()} должен возвращаеть следующий элемент, если же такового нет, то он должен порождать исключение \lstinline{StopIteration}.
\begin{pylst}{}{}
class counter(object):
    def __init__(self, limit):
        assert limit >= 0
        self._limit = limit
        self._value = 0

    def __iter__(self):
        return self

    def next(self):
        if self._value < self._limit:
            self._value += 1
            return self._value - 1
        else:
            raise StopIteration

>>> [i for i in counter(10)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{pylst}

Для удобного создания итераторов и работы с ними в Python есть библиотека \texttt{itertools}.

\subsubsection{Генераторы}
Генераторы позволяют удобно реализовывать протокол итератора. Генератор есть функция, в которой используется оператор \lstinline{yield}, то есть для определения генератора достаточно просто записать оператор \lstinline{yield} в теле функции, это не имеет никакого отношения к времени исполнения.

При вызове генератора возвращается итератор (технически, объект-генератор). Когда вызывается какой-либо метод итератора, начинается выполнение до первого встреченного оператора \lstinline{yield}, выполнение приостанавливается, запоминается точка возврата, и, наконец, возвращается значение при операторе \lstinline{yield}. При следующем вызове итератора выполнение начинается с точки останова. Так продолжается до тех пор, пока генератор не завершится любым отличным от оператора \lstinline{yield} способом (достигнет конца тела функции, при помощи оператора \lstinline{return}, исключительная ситуация).

В объекте-генераторе определены следующие методы:
\begin{itemize}
  \item \lstinline{next()}. Начинает выполнение функции-генераторы сначала или же вместе останова, если таковой присутствовал. Если выполнение начинается с точки останова, то текущий оператор \lstinline{yield} вычисляется в \lstinline{None}, и вычисление продолжается дальше. Если функция завершается не посредством \lstinline{yield}, то порождается исключение \lstinline{StopIteration}.

  \item \lstinline{send(value)}. Возобновляет выполнение и передает значение \lstinline{value} в точку останова. \lstinline{value} подставляется вместо текущего оператора \lstinline{yield}. Возвращает следующее значение, которое вернул оператор \lstinline{yield}, или порождает исключение \lstinline{StopIteration}, если функция-генератор завершилась другим способом. Если \lstinline{send(value)} вызывается для пуска генератора, то \lstinline{value} должно быть \lstinline{None}.
  \item \lstinline{throw(type[, value[, traceback]])}. Порождает исключение типа \lstinline{type} там, где функция-генератор была остановлена, и возвращает следующее значение, которая вернет функция-генератор. Если функция просто завершается, то порождается исключение \lstinline{StopIteration}.
  \item \lstinline{close()}. Порождает исключение \lstinline{GeneratorExit} в месте останова. Если функция-генератор затем порождает \lstinline{StopIteration} (или завершаясь нормально, или если уже была завершена) или \lstinline{GeneratorExit} (просто не обрабатывая его), происходит возврат из \lstinline{close}. Если функция возвращает значение оператором \lstinline{yield}, то возникает исключение \lstinline{RuntimeError}.
\end{itemize}

\begin{pylst}{}{}
def infinite(i):
    while True:
        yield i

>>> g = infinite(5)
>>> g.next()
5
>>> g.next()
5
\end{pylst}

С помощью генераторов можно реализовать, например, координатор сопрограмм (coroutines). Сопрограмма --- компонент программы, обобщающий понятие подпрограммы, который дополнительно поддерживает множество входных точек и остановку и продолжение выполнения.
\begin{pylst}{Из PEP 342}{}
import collections
import sys
import types

class Trampoline(object):
    def __init__(self):
        self.running = False
        self.queue = collections.deque()

    def add(self, coroutine):
        self.schedule(coroutine)

    def run(self):
        result = None
        self.running = True
        try:
            while self.running and self.queue:
                func = self.queue.popleft()
                return func()
            return result
        finally:
            self.running = False

    def stop(self):
        self.running = False

    def schedule(self, coroutine, stack=(), val=None, *exc):
        def resume():
            try:
                if exc:
                    value = coroutine.throw(val, *exc)
                else:
                    value = coroutine.send(val)
            except:
                if stack:
                    # send the error back to the co-caller
                    self.schedule(stack[0], stack[1], *sys.exc_info())
                else:
                    # propogate it to the real caller
                    raise

            if isinstance(value, types.GeneratorType):
                # push the new coroutine and call the new one
                self.schedule(value, (coroutine, stack))
            elif stack:
                # got a result, pop the stack and send the result
                # to the caller
                self.schedule(stack[0], stack[1], value)
            # else: this co-routine has ended

        self.queue.append(resume)

# simple echo server giving that we have non-blocking operations

# coroutine function that echos data back on a connected socket
def echo_handler(sock):
    while True:
        try:
            data = yield nonblocking_read(sock)
            yield nonblocking_write(sock, data)
        except ConnectionLost:
            pass  # exit normally if connection lost

# coroutine function that listens for connections on a
# socket, and then launches a service "handler" coroutine
# to service the connection
def listen_on(trampoline, sock, handler):
    while True:
        # get the next incoming connection
        connected_socket = yield nonblocking_accept(sock)

        # start another coroutine to handle the connection
        trampoline.add(handler(connected_socket))

# Create a scheduler to manage all our coroutines
trampoline = Trampoline()

# Create a coroutine instance to run the echo_handler on
# incoming connections

# Add the coroutine to the scheduler
trampoline.add(listen_on(trampoline,
                         listening_socket("localhost", "echo"),
                         echo_handler))

# loop forever, accepting connections and servicing them
trampoline.run()
\end{pylst}

\subsubsection{Генераторные выражения}
Генераторное выражение --- выражение, которое возвращает итератор. Выглядит, как списковое включение, лишь с тем отличием, что вместо квадратных скобок используются круглые.
\begin{pylst}{}{}
>>> sum(i*i for i in range(10))
285
\end{pylst}

\section{Декораторы}
\label{sec:py-decorators}
Декоратор --- объект, который можно вызвать с одним аргументом. Он волен делать с переданным аргументом всё, что угодно, лишь бы программа оставалась корректной.
\begin{pylst}{}{}
def debug(func):
    def wrapped(*args, **kwargs):
        print "%s called with: %s, %s" % (func.__name__, args, kwargs)
        ret = func(*args, **kwargs)
        print "%s returned: %s" % (func.__name__, ret)
        return ret
    return wrapped

@debug
def inc(i):
    return i + 1
\end{pylst}

@-синтаксис введен всего лишь для удобства. Вышеопределенное декорирование эквивалентно следующему:
\begin{pylst}{}{}
def inc(i):
    return i + 1

inc = debug(inc)
\end{pylst}

Пример вызова декорированной функции \lstinline{inc}:
\begin{pylst}{}{}
>>> inc(1)
inc called with: (1,), {}
inc returned: 2
\end{pylst}

\subsection{Примеры декораторов}
\subsubsection{Псевдокаррирование}
Каррирование или карринг (англ. currying) в информатике --- преобразование функции от пары аргументов в функцию, берущую свои аргументы по одному.
\begin{pylst}{}{}
class curried(object):
    def __init__(self, func, *a):
        self.func = func
        self.args = a

    def __call__(self, *a):
        args = self.args + a
        if len(args) < self.func.__code__.co_argcount:
            return curried(self.func, *args)
        else:
            return self.func(*args)

@curried
def add(a, b):
    return a + b

add1 = add(1)
print add1(2)
\end{pylst}

\subsubsection{Синхронизация}
Декорированная функция пытается захватить взаимное исключение перед тем, как исполняться.

\begin{pylst}{}{}
def synchronized(lock):
    def wrap(f):
        def sync(*args, **kwargs):
            lock.acquire()
            try:
                return f(*args, **kwargs)
            finally:
                lock.release()
        return sync
    return wrap

# Example usage:

from threading import Lock
lock = Lock()

@synchronized(lock)
def critical_one(*args):
    pass

@synchronized(lock)
def critical_two(*args):
    pass
\end{pylst}

\subsubsection{Декоратор, муштрующий декораторы}
Есть проблема с декорированной функции, например, ее свойство \lstinline{__name__} больше не равно ее действительному имени после декорирования. Следующий декоратор, призванный декорировать другие декораторы, этот досадный недостаток устраняет.
\begin{pylst}{}{}
def well_behaved(decorator):
    def new_decorator(f):
        g = decorator(f)
        g.__name__ = f.__name__
        g.__doc__ = f.__doc__
        g.__dict__.update(f.__dict__)
        return g
    new_decorator.__name__ = decorator.__name__
    new_decorator.__doc__ = decorator.__doc__
    new_decorator.__dict__.update(decorator.__dict__)
    return new_decorator

# Sample Use:

synchronized = well_behaved(synchronized)
\end{pylst}

\section{Метаклассы}
В Python классы --- такие же объекты, как и всё остальное. Их можно передавать в качестве аргументов функциям или рассматривать под микроскопом. Так же как класс определяет поведение объектов, так и метакласс определяет поведение своих классов. Самый распростаненный метакласс в Python --- \lstinline{type}.

\begin{pylst}{}{}
>>> object.__class__
<type 'type'>
>>> type(object)
<type 'type'>
\end{pylst}

Часто метаклассы используются как фабрики. Когда Python создает новый класс (при выполнении оператора \lstinline{class}), он вызывает метакласс. Метакласс в свою очередь может поместить класс в какой-нибудь регистр или же вернуть \emph{совсем} другой класс. Для подавляющего большинства --- если не всех --- встроенных типов метаклассом является метакласс \lstinline{type}.

\begin{pylst}{}{}
# prototype
type(name, bases, dict)
\end{pylst}
где \lstinline{name} --- имя нового класса, \lstinline{bases} --- последовательность базовый классов (может быть пустой), а \lstinline{dict} --- словарь, ключи которого являются именами аттрибутов создаваемого класса, а значения --- значениями этих аттрибутов.

Определение
\begin{pylst}{}{}
class MyClass(BaseClass):
    attribute = 42
\end{pylst}
эквивалентно
\begin{pylst}{}{}
MyClass = type("MyClass", (BaseClass,), { 'attribute' : 42 })
\end{pylst}

Метакласс для класса указывается с помощью поля \lstinline{__metaclass__}. В метаклассе можно (пере)определять любые методы, как и в любом классе, с тем отличием, что методам класса передается экземпляр первым аргументом (отсюда и общеупотребимое \lstinline{self}), а методам метакласса --- класс. Поэтому первый аргумент часто именуется \lstinline{cls}.

\begin{pylst}{}{}
class UselessType(type):
    def __new__(cls, name, bases, dct):
        print "Allocating memory for class", name
        return type.__new__(cls, name, bases, dct)

    def __init__(cls, name, bases, dct):
        print "Init'ing (configuring) class", name
        super(UselessType, cls).__init__(name, bases, dct)

    def __call__(cls, *args, **kwargs):
        print "Calling %s" % cls.__name__
        return super(UselessType, cls).__call__(*args, **kwargs)

    def whoami(cls):
        print cls.__name__

class UselessClass(object):
    __metaclass__ = UselessType

>>> UselessClass.whoami()
UselessClass
>>> UselessClass()
Calling <class '__main__.UselessClass'>
\end{pylst}

Когда выполняется оператор \lstinline{class}, Python вначале выполняет внутреннее содержимое как обычный блок кода. В результате получается пространство имен, представленное словарем. Затем Python ищет метакласс для создаваемого класса в следующей последовательности:
\begin{enumerate}
  \item Если \lstinline{dict['__metaclass__']} существуют, то используется он.
  \item В ином случае, если у класса есть базовые классы, их метакласс используется (сначала проверяется аттрибут \lstinline{__class__}, и если такого нет, то исползуется тип базового класса).
  \item В ином случае, если есть глобальная переменная \lstinline{__metaclass__}, то используется она.
\end{enumerate}

После чего метакласс вызывается с именем вновь создаваемого класса, его базовыми классами и словарем аттрибутов как аргументами.

Полю \lstinline{__metaclass__} можно присваивать не только метаклассы, но и любой вызываемый (callable) объект, который принимает три аргумента.
\begin{pylst}{}{}
def meta(name, bases, dct):
    # setting useless attr
    dct['foo'] = 'bar'
    return type(name, bases, dct)

class Bar(object):
    __metaclass__ = meta

>>> Bar().foo
'bar'
\end{pylst}

Следом идет реализация паттерна Singleton с помощью метакласса:
\begin{pylst}{}{}
class SingletonMetaclass(type):
    instance = None

    def __call__(cls, *args, **kwargs):
        if cls.instance is None:
            cls.instance = super(SingletonMetaclass, cls).__call__(
                *args, **kwargs)
        return cls.instance

class Foo(object):
     __metaclass__ = SingletonMetaclass

>>> Foo() is Foo()
True
\end{pylst}

Как говорится в руководстве по Python, области применения метаклассов безграничны, что, конечно же, является бесстыдным враньём. Вот несколько из общеизвестных применений: logging, проверка интерфейсов, автоматическое делегирование, автоматическое создание свойств класса, прокси, ORM и автоматическая синхронизация/захват ресурса.

\section{Интроспекция}
\label{sec:py-introspection}
В Python можно получить подробную информацию о внутренней структуре любого объекта и среды исполнения. Необходимые для интроспекции данные хранятся в специальных атрибутах. Так, например, получить все пользовательские атрибуты большинства объектов можно из специального атрибута --- словаря (или объекта, предоставляющего dict интерфейс) \lstinline{__dict__}.
\begin{pylst}{}{}
class Class(object): pass

>>> c = Class()
>>> c.attr = 'some'
>>> print c.__dict__
{'attr': 'some'}
>>> print Class.__dict__
{'__dict__': <attribute '__dict__' of 'Class' objects>,
 '__module__': '__main__',
 '__weakref__': <attribute '__weakref__' of 'Class' objects>,
 '__doc__': None}

class BaseA(object): pass
class BaseB(object): pass
class Child(BaseA, BaseB): pass

# let's get some information about object's hierachy
# and method resolution order

>>> c = Child()
>>> c.__class__
<class '__main__.Child'>
>>> c.__class__.__base__
<class '__main__.BaseA'>
>>> c.__class__.__bases__
(<class '__main__.BaseA'>, <class '__main__.BaseB'>)
>>> c.__class__.__mro__
(<class '__main__.Child'>,
 <class '__main__.BaseA'>,
 <class '__main__.BaseB'>,
 <type 'object'>)
\end{pylst}

Для более удобного получения информации о внутреннем устройстве различных объектов был введён модель \lstinline{inspect}.
\begin{pylst}{}{}
import inspect

def f(a, b, c=3):
    pass

>>> inspect.getargspec(f)
ArgSpec(args=['a', 'b', 'c'], varargs=None, keywords=None, defaults=(3,))
\end{pylst}

\begin{thebibliography}{9}

\bibitem{python:pilgrim09}
  M. Pilgrim,
  \emph{Dive into Python 3}.
  Apress,
  2nd ed.,
  2009.

\end{thebibliography}
