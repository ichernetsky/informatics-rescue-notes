\chapter{Язык программирования Python}
\label{ch:python}

Чтобы попробовать \emph{Python}, достаточно запустить REPL (от \emph{Read, Eval, Print, Loop}), введя в командной оболочке \lstinline{python} (а ещё лучше \lstinline{ipython}). Запустится интерпретатор \emph{Python}, ожидающий ввода. Можно вводить конструкции языка — и немедленно получать результат исполнения.

\begin{plainlst}{Пример минимальной сессии}{}
% ipython
Python 2.7.2 (default, Jun 29 2011, 15:07:32)
Type "copyright", "credits" or "license" for more information.

IPython 0.10.2 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object'. ?object also works, ?? prints more.

In [1]: 2 ** 32
Out[1]: 4294967296

In [2]: dir(None)
Out[2]:
['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__',
 '__hash__', '__init__', '__new__', '__reduce__', '__reduce_ex__',
 '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']

In [3]: map?
Type:		builtin_function_or_method
Base Class:	<type 'builtin_function_or_method'>
String Form:	<built-in function map>
Namespace:	Python builtin
Docstring:
    map(function, sequence[, sequence, ...]) -> list

    Return a list of the results of applying the function to the items of
    the argument sequence(s).  If more than one sequence is given, the
    function is called with an argument list consisting of the corresponding
    item of each sequence, substituting None for missing values when not all
    sequences have the same length.  If the function is None, return a list
    of the items of the sequence (or a list of tuples if more than one
    sequence).
\end{plainlst}

\section{Типы и структуры данных и операции над ними}
\label{sec:py-types}

\emph{Python} — динамически типизированный язык. Типы принадлежат объектам, не переменным. Переменные лишь связываются с объектами, то есть они всего лишь имена. \emph{Python} — строго типизированный язык. Все типы проверяются во время исполнения. Если обнаруживается какое-либо несоответствие типов, то возникает исключение, как правило, \lstinline{TypeError} или \lstinline{AttributeError}.

Все объекты деляется на \emph{ссылочные} и \emph{атомарные}. При присваивании атомарных объектов они копируются, в то время как при присваивании ссылочных объектов копируются только ссылки на них. Ссылочные объекты могут быть \emph{изменяемыми} или \emph{неизменяемыми} (\emph{mutable} и \emph{immutable} соответственно).

\subsection{NoneType}
Единственным экземпляром этого типа является константа \lstinline{None}. Используется для обозначение того факта, что значения нет, например, «функция ничего не возвращает». С \lstinline{None} можно использовать операции сравнения\footnote{В \emph{Python} 2.x можно использовать и операторы отношения порядка, в 3.x — только операторы равенства.} и т.п.

\subsection{Булев тип}
\lstinline{False} — ложное значение булева типа, а \lstinline{True} — истинное значение.

Любой объект может быть проверен на истинность (как все просто!) для использования в операторах \lstinline{if} и \lstinline{while}. Следующие значения считаются ложными:
\begin{itemize}
  \item \lstinline{None};
  \item \lstinline{False};
  \item нуль любого числового типа;
  \item любая пустая последовательность;
  \item любое пустое отображение (словарь);
  \item экземпляр класса, определенного пользователем, если в классе определены \lstinline{__nonzero__()} или \lstinline{__len__()} методы, и они возвращают нуль или \lstinline{False} соответственно.
\end{itemize}

\begin{pylst}{}{}
class Zero(object):
    def __nonzero__(self):
        return False

class ZeroLen(object):
    def __len__(self):
        return 0

>>> bool(Zero())
False

>>> bool(ZeroLen())
False

>>> bool({})
False

>>> bool([])
False
\end{pylst}

Все остальные значения считаются истинными.

\subsubsection{Булевы операции}

\lstinline{x or y}. Если \lstinline{x} истинен, то результат выражения — \lstinline{x}, иначе — \lstinline{y}. Правый аргумент вычисляется, только если левый — ложен.

\begin{pylst}{}{}
>>> 0 or 2 or 1 or 0
2
\end{pylst}

\lstinline{x and y}. Если \lstinline{x} — ложен, то он вычисляется и является результатом, и в этом случае \lstinline{y} не вычисляется. Иначе вычисляется \lstinline{y}, и результат вычисления становится значением всего выражения.

\begin{pylst}{}{}
>>> 1 and 2 and 0 and 3
0
\end{pylst}

\lstinline{not x}. Отрицание \lstinline{x}. Если он истинен, то значение выражения — \lstinline{False}, и наоборот.

\subsection{Числовые типы}
В \emph{Python} есть четыре числовых типа: \lstinline{int}, \lstinline{long}\footnote{В \emph{Python} 3.x этот тип убран вообще, но зато числа типа \lstinline{int} теперь не имеют ограничений на размер.}, \lstinline{float} и \lstinline{complex}. \lstinline{int} соответсвует \lstinline{long} языка \emph{C}. Для типа \lstinline{long} языка \emph{Python} нет ограничений на размер числа. \lstinline{float} языка \emph{Python} реализован с помощью типа \lstinline{double} языка \emph{C}. Комплексные числа имеют действительную и мнимую составляющие, каждая из которых представлена \lstinline{double} языка \emph{C}.

Комплексные числа записываются как \lstinline{x + yj}, где \lstinline{x} и \lstinline{y} — целый числа или числа с плавающей точкой.

\begin{pylst}{}{}
>>> z = 1.3 + 0.5j
>>> z
(1.3+0.5j)
>>> z.real
1.3
>>> z.imag
0.5
>>> z.conjugate()
(1.3-0.5j)
\end{pylst}

\subsubsection{Преобразование числовых типов}

Создавать числа и преобразовывать друг в друга можно, используя типы \lstinline{int}, \lstinline{long}, \lstinline{float} и \lstinline{complex}.

\begin{pylst}{}{}
>>> int(2)
2
>>> int(2.3)
2
>>> float(2)
2.0
>>> complex(2, 4)
(2+4j)
\end{pylst}

\subsubsection{Числовые операторы и не только}

Унарные операторы: \lstinline{+x, -x, ~x}. Унарный оператор \lstinline{+} не изменяет своего аргумента. Оператор \lstinline{-} возвращает противоположное значение относительно операции сложения. Оператор \lstinline{~} побитово инвертирует свой аргумент, эквивалентен выражению \lstinline{-(x + 1)}.

\begin{pylst}{}{}
>>> x = 111
>>> +x
111
>>> -x
-111
>>> bin(x)
'0b1101111'
>>> bin(~x)
'-0b1110000'
\end{pylst}

Бинарные арифметические операторы: \lstinline{x + y, x - y, x * y, x // y, x / y, x % y, x ** y}. Перед выполнением всех операций аргументы приводятся к общему типу. Операторы \lstinline{/} и \lstinline{//} возвращают частное деления. Если оба аргумента целочисленны, то результатом оператора \lstinline{/} будет целое число\footnote{В \emph{Python} 3.x это не так. Там оператор \lstinline{/} возвращает значение типа \lstinline{float}. Для того, чтобы включить такое поведение и в \emph{Python} 2.x, следует в начало файла вставить \lstinline{from __future__ import division}. См. \emph{PEP 238}: \url{http://www.python.org/dev/peps/pep-0238/}}. Оператор \lstinline{//} определён как $\lfloor \frac{x}{y} \rfloor$. Оператор \lstinline{%} возвращает остаток от деления; он также определён и для чисел с плавающей точкой. Оператор \lstinline{**} возводит \lstinline{x} в степень \lstinline{y}.

Для всех операторов с целочисленным аргументами определено следующее поведение: если результату вычисления недостаточно типа \lstinline{int}, то возвращается число типа \lstinline{long}.

\begin{pylst}{}{}
>>> 7 + 5
12
>>> 7 - 5
2
>>> 7 * 5
35
>>> 7 / 5
1
>>> 7.0 / 5
1.4
>>> 7.0 // 5
1.0
>>> 7 % 5
2
>>> 3.14 % 0.7
0.3400000000000003
>>> 2**100
1267650600228229401496703205376L
\end{pylst}

Бинарные побитовые операторы: \lstinline{x & y, x ^ y, x | y}. Перед вычислением аргументы преобразуются к общему типу. Типом аргумента может быть \lstinline{int} или \lstinline{long}. Оператор \lstinline{&} — побитовое И (AND); оператор \lstinline{^} — побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR); оператор \lstinline{|} — побитовое ИЛИ (OR).

\begin{pylst}{}{}
>>> hex(0xc4 & 0x72)
'0x40'
>>> hex(0xc4 ^ 0x72)
'0xb6'
>>> hex(0xc4 | 0x72)
'0xf6'
\end{pylst}

Операторы сдвига: \lstinline{x << y} и \lstinline{x >> y}. Перед вычислением аргументы преобразуются к общему типу. Типом аргумента может быть \lstinline{int} или \lstinline{long}. Операторы делают сдвиг \lstinline{x} на \lstinline{y} бит влево и вправо соответственно. Оператор \lstinline{<<} определён как \lstinline{x * pow(2, y)}, а \lstinline{>>} — как \lstinline{x / pow(2, y)}.

\begin{pylst}{}{}
>>> 1 << 5 == 1 * pow(2, 5)
True
>>> 256 >> 5 == 256 / pow(2, 5)
True
\end{pylst}

\subsubsection{Перегрузка операторов}

В \emph{Python} все операторы можно перегружать\footnote{По ссылке \url{http://docs.python.org/reference/datamodel.html\#special-method-names} перечислены все \emph{специальные методы}, часть которых используется для перегрузки операторов.}. Для небольшой иллюстрации напишем класс, который представляет нейтральный элемент относительно операций сложения и умножения.

\begin{pylst}{}{}
class IdentityElement(object):
    def __repr__(self):
        return "IdentityElement"
    def __str__(self):
        return self.__repr__()
    def __add__(self, other):
        return other
    def __radd__(self, other):
        return other
    def __mul__(self, other):
        return other
    def __rmul__(self, other):
        return other

>>> identity = IdentityElement()
>>> identity
IdentityElement
>>> 5 + identity
5
>>> identity * 5
5
\end{pylst}

\subsubsection{Числовые функции и модули}

В стандартной библиотеке \emph{Python} есть как модули, предоставляющие математические функции и константы, так и модули, предоставляющие реализации новых числовых типов.

Так модуль \lstinline{math} предоставляет различные функции округлений чисел с плавающей точкой, степенные, логарифмические, тригонометрические, гиперболические функции и т.д. Аналогичную функциональность, но уже для комплексных чисел, предоставляет модуль \lstinline{cmath}.

Модуль \lstinline{random} содержит функции для генерации случайных чисел различных распределений и функции, которые выбирают один или несколько случайных элементов из последовательности, перемешивают последовательность и т. д.

\begin{pylst}{}{}
>>> random.random()
0.37444887175646646
>>> random.uniform(1, 10)
1.1800146073117523
>>> random.randint(1, 10)
7
>>> random.choice('abcdefghij')
'c'

>>> items = [1, 2, 3, 4, 5, 6, 7]
>>> random.shuffle(items)
>>> items
[7, 3, 2, 5, 6, 4, 1]

>>> random.sample([1, 2, 3, 4, 5],  3)
[4, 1, 5]
\end{pylst}

Модуль \lstinline{fraction} предоставляет тип рациональных чисел с поддержкой всех арифметических операцией.

\begin{pylst}{}{}
>>> from fractions import Fraction
>>> x = Fraction(16, -10)
>>> x
Fraction(-8, 5)
>>> y = Fraction('3/7')
>>> y
Fraction(3, 7)
>>> z = Fraction(2.25)
>>> z
Fraction(9, 4)
>>> x + y + z
Fraction(151, 140)
>>> from decimal import Decimal
>>> Fraction(Decimal('1.1'))
Fraction(11, 10)
\end{pylst}

Модуль \lstinline{decimal} реализует поддержку \emph{чисел с десятичной плавающей точкой (decimal floating point numbers)}. Вот некоторые преимущества в сравнении с числами с двоичной плавающей точкой:
\begin{itemize}
  \item Более удобна для восприятия людьми.
  \item Десятичные числа могут быть представлены точно, в то время как $1.2$ не может быть представлена точно, используя числа с двоичной плавающей точкой.
\begin{pylst}{}{}
>>> 1.1 + 2.2
3.3000000000000003
\end{pylst}
  \item Эта точность сохраняется и при использовании арифтемических операций. Так $0.1 + 0.1 + 0.1 - 0.3$ будет равно $0$, в то время как:
\begin{pylst}{}{}
>>> 0.1 + 0.1 + 0.1 - 0.3
5.551115123125783e-17
\end{pylst}
  \item Можно изменять \emph{точность (precision)}.
\end{itemize}

Небольшая иллюстрация использования модуля \lstinline{decimal}:

\begin{pylst}{}{}
>>> from decimal import *
>>> D = Decimal
>>> D('1.1') + D('2.2')
Decimal('3.3')
>>> D('0.1') + D('0.1') + D('0.1') - D('0.3')
Decimal('0.0')

>>> D(2) ** D('0.5')
Decimal('1.414213562373095048801688724')
>>> D(1).exp()
Decimal('2.718281828459045235360287471')

>>> getcontext().prec = 6
>>> D('3.1415926535') + D('2.7182818285')
Decimal('5.85987')
>>> getcontext().rounding = ROUND_UP
>>> D('3.1415926535') + D('2.7182818285')
Decimal('5.85988')
\end{pylst}

\subsection{Последовательности}
В \emph{Python} семь типов последовательностей: \lstinline{str} (\emph{строки}), \lstinline{unicode} (\emph{юникодные строки}), \lstinline{list} (\emph{списки}), \lstinline{tuple} (\emph{кортежи}), \lstinline{bytearray}, \lstinline{buffer} и \lstinline{xrange}.\footnote{Последние три типа особо не будут рассматриваться, так как они не находят столь широкого применения, как первые четыре типа.}

Строковые литералы записываются в одинарных либо двойных кавычках: \lstinline{'foo'}, \lstinline{"foo"}. Списки записываются в квадратных скобках, посреди которых элементы разделяются запятыми: \lstinline{[1, 2, 3]}. Форма записи кортежей — элементы, разделённые запятыми; также могут присутствовать необязательные круглые скобки: \lstinline{(1, 2, 3)} и \lstinline{1, 2, 3} — эквивалентные записи. Для создания кортежа из одного элемента необходимо наличие запятой после этого элемента: \lstinline{(1,)}.

В \emph{Python} нет специального синтаксиса для создания последовательностей \lstinline{bytearray}, \lstinline{buffer} и \lstinline{xrange}. Они создаются встроенными функциями \lstinline{bytearray()}, \lstinline{buffer()} и \lstinline{xrange()} соответственно.

Отличительная черта \lstinline{xrange} — использование константного объёма памяти, какой бы длинной представляемая последовательноть не была. Объекты \lstinline{xrange} поддерживают итерирование, доступ по индексу и получение длины последовательности (\lstinline{len()}); но не поддерживают операции среза (\emph{slicing}), сцепки (\emph{concatenation}) и повтора (\emph{repetition}); также операторы \lstinline{in} и \lstinline{not in} и функции \lstinline{min()} и \lstinline{max()} очень неэффективны с данными объектами. Основное применение \emph{xrange} — итерирование по последовательности целых чисел:

\begin{pylst}{}{}
>>> for i in xrange(1, 10, 2):
...     print i,
...
1 3 5 7 9
\end{pylst}

Последовательности делятся на \emph{изменяемые} (\emph{mutable}) и \emph{неизменяемые} (\emph{immutable}). Последовательности поддерживают следующие операции:

\lstinline{x in s}. Результат — истинный, если какой либо элемент последовательности \lstinline{s} равен \lstinline{x}; иначе — ложный. В случае строк эта операция — проверка, является ли \lstinline{x} подстрокой \lstinline{s}.
\begin{pylst}{}{}
>>> 2 in [1, 2, 3]
True
>>> 'boo' in 'boozers'
True
\end{pylst}

\lstinline{x not in s}. Операция, обратная предыдущей. Возвращает истину, если \lstinline{x} не присутствует в \lstinline{s}.
\begin{pylst}{}{}
>>> 4 not in [1, 2, 3]
True
\end{pylst}

\lstinline{s + t}. Сцепка последовательностей одного типа \lstinline{s} и \lstinline{t}.
\begin{pylst}{}{}
>>> (1, 2, 3) + (4, 5)
(1, 2, 3, 4, 5)
>>> 'foo' + 'bar'
'foobar'
\end{pylst}

\lstinline{s * n} и \lstinline{n * s}. Повтор последовательности \lstinline{n} раз. Если \lstinline{n <= 0}, то возвращается пустая последовательность. Нужно помнить, что при выполнении этой операции делается \emph{shallow}\footnote{Копирование бывает \emph{shallow} и \emph{deep}. В первом случае копируется только сама последовательность, во втором же случае — и все элементы, причём рекурсивно.} копирование.
\begin{pylst}{}{}
>>> [1, 2, 3] * -1
[]
>>> [1, 2, 3] * 0
[]
>>> [1, 2, 3] * 2
[1, 2, 3, 1, 2, 3]

>>> lists = [[]] * 3
>>> lists
[[], [], []]
>>> lists[0].append(3)
>>> lists
[[3], [3], [3]]
\end{pylst}

\lstinline{s[i]}. Доступ к $i$-тому элементу последовательности \lstinline{s}. Первый элемент имеет индекс \lstinline{0}. Индекс также может быть отрицательным, в таком случае отсчёт идёт с конца последовательности. Последний элемент имеет индекс \lstinline{-1}.
\begin{pylst}{}{}
>>> s = list(xrange(1, 10, 3))
>>> s
1, 4, 7
>>> s[2]
7
>>> s[-2]
4
\end{pylst}

\lstinline{s[i:j]}. Срез последовательности, который состоит из элементов, индекс которых больше либо равен \lstinline{i} и меньше \lstinline{j}. Оба индекса могут отсутствовать. Если отсутствует \lstinline{i}, то элементы берутся начиная с первого; если же — \lstinline{j}, то элементы обрабатываются до конца последовательности.

\lstinline{s[i:j:k]}. Также срез, но уже с шагом \lstinline{k}.
\begin{pylst}{}{}
>>> s = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> s[3:-1]
[3, 4, 5, 6, 7, 8]
>>> s[3:]
[3, 4, 5, 6, 7, 8, 9]
>>> s[3:-1:2]
[3, 5, 7]
>>> s[:]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{pylst}

\lstinline{len(s)}. Возвращает количество элементов в последовательности \lstinline{s}.
\begin{pylst}{}{}
>>> len(xrange(10))
10
\end{pylst}

\lstinline{min(s)} и \lstinline{max(s)}. Соответственно минимальный и максимальный элементы последовательности \lstinline{s}.
\begin{pylst}{}{}
>>> s = [4, 1, 9, 5, 6]
>>> min(s)
1
>>> max(s)
9
\end{pylst}

\lstinline{s.index(x[, start[, end]])}. Возвращает индекс первого элемента слева, который равен \lstinline{x}, в последовательности \lstinline{s}. Необязательные аргументы \lstinline{start} и \lstinline{end} указывают интервал поиска.
\begin{pylst}{}{}
>>> s = [9, 4, 1, 8]
>>> s.index(1)
2
\end{pylst}

\lstinline{s.count(x)}. Возвращает количество элементов последовательности \lstinline{s}, которые равны \lstinline{x}. Необязательные аргументы \lstinline{start} и \lstinline{end} указывают интервал поиска.
\begin{pylst}{}{}
>>> s = [1, 2, 1, 2, 3]
>>> s.count(1)
2
\end{pylst}

\subsubsection{Операции над изменяемыми последовательностями}
Нижеперечисленные операции относятся к изменяемым последовательностям, в текущих реализациях \emph{Python} это списки и \lstinline{bytearray}.

\lstinline{s[i] = x}. Заменяет \lstinline{i}-тый элемент последовательности на \lstinline{x}.
\begin{pylst}{}{}
>>> s = [1, 2, 3]
>>> s[1] = 4
>>> s
[1, 4, 3]
\end{pylst}

\lstinline{s[i:j] = t}. Заменяет срез элементами последовательности \lstinline{t}.
\begin{pylst}{}{}
>>> s = [1, 2, 7, 8]
>>> s[:2] = [2, 3]
>>> s
[2, 3, 7, 8]

>>> s[2:2] = [4, 5, 6]
[2, 3, 4, 5, 6, 7, 8]

>>> s[1:6] = []
[2, 8]
\end{pylst}{}

\lstinline{s[i:j:k] = t}. То же самое поведение, что и у предыдущей операции, но на этот раз длина \lstinline{t} должна быть равна длине среза.
\begin{pylst}{}{}
>>> s = [1, 1, 3, 3]
>>> s[1::2] = [2, 4]
>>> s
[1, 2, 3, 4]
\end{pylst}

\lstinline{del s[i:j]} и \lstinline{del s[i:j:k]}. Удаляет элементы среза из последовательности \lstinline{s}.
\begin{pylst}{}{}
>>> s = [1, 2, 3, 4, 5]
>>> del s[-1]
>>> s
[1, 2, 3, 4]

>>> del[::2]
>>> s
[2, 4]
\end{pylst}

\lstinline{s.append(x)}. Добавляет \lstinline{x} в конец последовательности \lstinline{s}.
\begin{pylst}{}{}
>>> s = [1, 2]
>>> s.append(3)
>>> s
[1, 2, 3]
\end{pylst}

\lstinline{s.extend(t)}. Добавляет все элементы последовательности \lstinline{t} в конец последовательности \lstinline{s}.
\begin{pylst}{}{}
>>> s = [1, 2]
>>> s.extend([3, 4])
>>> s
[1, 2, 3, 4]
\end{pylst}

\lstinline{s.insert(i, x)}. Вставляет \lstinline{x} до элемента в последовательности с индексом \lstinline{i}.
\begin{pylst}{}{}
>>> s = [1, 2]
>>> s.insert(0, 0)
>>> s
[0, 1, 2]
\end{pylst}

\lstinline{s.pop([i])}. Удаляет элемент с индексом \lstinline{i} из последовательности. Если индекс не перадан при вызове, то берётся последний элемент.
\begin{pylst}{}{}
>>> s = [1, 2, 3, 4]
>>> s.pop()
4
>>> s
[1, 2, 3]
>>> s.pop(1)
2
>>> s
[1, 3]
\end{pylst}

\lstinline{s.remove(x)}. Удаляет из последовательности первый встреченный элемент, который равен \lstinline{x}.
\begin{pylst}{}{}
>>> s = [1, 3, 2, 3, 4]
>>> s.remove(3)
>>> s
[1, 2, 3, 4]
\end{pylst}

\lstinline{s.reverse()}. Переворачивает последовательность \emph{in-place}.
\begin{pylst}{}{}
>>> s = [1, 2, 3]
>>> s.reverse()
>>> s
[3, 2, 1]
\end{pylst}

\lstinline{s.sort([cmp[, key[, reverse]]])}. Сортирует последовательность \emph{in-place}. Стабильно. Необязательный параметр \lstinline{cmp} должен быть функцией двух аргументов, которая будет использоваться для сравнения элементов последовательности при сортировке. Функция должна возвращать отрицательное целое, нуль или положительное целое число, если первый элемент меньше, равен или больше второго соответственно. Параметр \lstinline{key} определяет функцию одного аргумента, которая будет использоваться для получения ключа для сравнения на основе каждого элемента последовательности. Параметр \lstinline{reverse} — булева типа. Если он равен \lstinline{True}, то результат сравнения будет заменяться на обратный.
\begin{pylst}{}{}
>>> s = ['C', 'd', 'E', 'A', 'b', 'f']
>>> s.sort()
>>> s
['A', 'C', 'E', 'b', 'd', 'f']

>>> s = ['C', 'd', 'E', 'A', 'b', 'f']
>>> s.sort(key=lambda x: x.lower())
>>> s
['A', 'b', 'C', 'd', 'E', 'f']

>>> s = ['C', 'd', 'E', 'A', 'b', 'f']
>>> s.sort(key=lambda x: x.lower(), reverse=True)
>>> s
['f', 'E', 'd', 'C', 'b', 'A']
\end{pylst}

\subsubsection{Строки}
Строка — неизменяемый тип данных. Все операции над последовательностями работают и со строками. Строковые литералы могут быть записаны двумя способами:
\begin{itemize}
  \item \lstinline{'string'} или \lstinline{"string"}. При использовании одинарных кавычек отпадает необходимость экранировать двойные, и наоборот.
  \item \lstinline{'''string'''} или \lstinline{"""string"""}. Строка при этом может занимать несколько строк. Также не нужно экранировать кавычки.
\begin{pylst}{}{}
>>> '''This
... makes
... sense.'''
'This\nmakes\nsense.'
\end{pylst}
\end{itemize}

Также строковые литералы могут иметь следующие префиксы:
\begin{itemize}
  \item \lstinline{r} или \lstinline{R}. С таким префиксом обратная наклонная черта не имеет никакого специального значения\footnote{Все управляющие последовательности перечислены на \url{http://docs.python.org/reference/lexical_analysis.html\#string-literals}}. Очень удобно при записи, например, регулярных выражений.
\begin{pylst}{}{}
>>> print 'one\ntwo'
one two
>>> print r'one\ntwo'
one\ntwo
\end{pylst}
  \item \lstinline{u} или \lstinline{U}. Этот префикс делает литерал юникодовым\footnote{В \emph{Python} 3.x все строки являются юникодовыми; начиная с этой версии типа \lstinline{unicode} нет вообще, а тип \lstinline{str} является тем, что есть \lstinline{unicode} в версии 2.x.}.
\end{itemize}

Для форматирования строк в \emph{Python} есть оператор \lstinline{%} и метод \lstinline{format(*args, **kwargs)}\footnote{В версии 3.x комильфо способом форматирования является метод \lstinline{format}, поэтому следует использовать его.}. Синтаксис и все спецификаторы форматирования, определение собственных спецификаторов и т. д. описаны в \emph{PEP 3101}\footnote{\url{http://www.python.org/dev/peps/pep-3101/}}. Здесь же ограничимся некоторыми примерами, из которых основная суть наглядно ясна:

\begin{pylst}{}{}
>>> 'My name is {0[name]}'.format(dict(name='Fred'))
'My name is Fred'

>>> '%(language)s has %(number)03d quote types.' % \
...     { "language" : "Python", "number" : 2 }
'Python has 002 quote types.'

>>> from datetime import datetime
>>> 'Today is: {0:%a %b %d %H:%M:%S %Y}'.format(datetime.now())
'Today is: Fri Nov 25 18:11:23 2011'
\end{pylst}

В \emph{Python} используется \emph{UTF-8} для представления юникодовых строк. У строк есть методы \lstinline{encode} и \lstinline{decode} для преобразования строк из и в различные кодировки.

\lstinline{s.encode([encoding[, errors]])}. Кодирует строку \lstinline{s}, используя кодировку \lstinline{encoding}. Параметр \lstinline{errros} может быть равен \lstinline{'strict'} (в таком случае будет создаваться исключение \lstinline{UnicodeEncodeError} при ошибках кодирования), \lstinline{'ignore'}, \lstinline{'replace'}, как и другие значения, специфичные для конкретных кодировок.

\lstinline{s.decode([encoding[, errors]])}. Декодирует строку \lstinline{s}, используя кодировку \lstinline{encoding}. Параметры могут принимать те же значения, что и для метода \lstinline{encode}, с тем лишь отличием, что исключение — \lstinline{UnicodeDecodeError}.

Ниже представлены часто употребляемые методы строк:

\lstinline{s.startswith(prefix[, start[, end]])}. Проверяет, начинается ли строка \lstinline{s} с префикса \lstinline{prefix}. Параметрами \lstinline{start} и \lstinline{end} можно задать интервал проверки. Параметр \lstinline{prefix} может быть кортежом префиксов.
\begin{pylst}{}{}
>>> 'substring'.startswith('sub')
True
\end{pylst}

\lstinline{s.endswith(suffix[, start[, end]])}. Проверяет, заканчивается ли строка \lstinline{s} строкой \lstinline{suffix}. В остальном значения параметров такие же, как и для метода \lstinline{startswith}.

\lstinline{s.strip([chars])}. Удаляет с обоих концов строки \lstinline{s} либо пробельные символы, либо символы из строки \lstinline{chars}.
\begin{pylst}{}{}
>>> '      centered      '.strip()
'centered'
\end{pylst}

\lstinline{s.lower()} и \lstinline{s.upper()}. Преобразуют строку к нижнему и верхнему регистру соответственно.
\begin{pylst}{}{}
>>> 'FOObar'.lower()
'foobar'
\end{pylst}

\lstinline{s.split([sep[, maxsplit]])}. Разбивает строку по разделителю \lstinline{sep} и возвращает список полученных элементов. Если же параметр \lstinline{sep} не задан, то разбивается по пробельным символам, причём подряд идущие пробельные символы считаются за один, а пробельные символы на концах строк просто удаляются. Количество разбиений можно ограничить параметром \lstinline{maxsplit}.
\begin{pylst}{}{}
>>> '1,2,3'.split(',')
['1', '2', '3']
>>> '1,,3'.split(',')
['1', '', '3']
>>> ' 1    2  3 '.split()
['1', '2', '3']
>>> ' 1    2  3 '.split(None, 1)
['1', '2  3 ']
\end{pylst}

\lstinline{s.join(iterable)}. Сцепляет строки, которые возвращает итерируемый объект \lstinline{iterable}, с разделителем \lstinline{s}.
\begin{pylst}{}{}
>>> ', '.join(str(i) for i in xrange(10))
'0, 1, 2, 3, 4, 5, 6, 7, 8, 9'
\end{pylst}

\subsubsection{Списки}
Список в \emph{Python} — изменяемая структура данных. Все операции над последовательностями применимы к спискам. Списки реализованы с помощью расширяемых массивов; этот факт нужно не упускать из виду при работе со списками. Так, вставка в начало списка не выполняется за $\Theta(1)$, как ожидается исходя из названия, но за $\Theta(n)$.

\subsubsection{Кортежи}
Кортеж — это неизменяемая последовательность элементов. Нельзя ни удалять элементы из кортежа, ни добавлять, ни изменять. Примеры создания кортежей:
\begin{pylst}{}{}
>>> tuple([1, 2, 3])
(1, 2, 3)
>>> ('a', 'b', 'c')
('a', 'b', 'c')
\end{pylst}

Объекты можно упаковывать (\emph{packing}) в кортеж, но можно и проделать обратную операцию (\emph{unpacking}):
\begin{pylst}{}{}
>>> t = 1, 2, 3
>>> a, b, c = t
>>> b
2
\end{pylst}

\subsection{Словари}
Словарь — изменяемая структура данных. Он отображает хешируемые значения на любые объекты. Словарь можно создавать несколькими способами:
\begin{itemize}
  \item С помощью встроенного синтаксиса:
\begin{pylst}{}{}
>>> d = { 'one' : 1, 'two' : 2 }
>>> d
{'one': 1, 'two': 2}
\end{pylst}

  \item С помощью конструктора и именованных аргументов:
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)
>>> d
{'one': 1, 'two': 2}
\end{pylst}

  \item С помощью конструктора и любой последовательности, содержащей последовательности длины $2$, первый элемент которых становится ключом, а второй — значением.
\begin{pylst}{}{}
>>> d = dict([('one', 1), ('two', 1)])
>>> d
{'one': 1, 'two': 2}
\end{pylst}

  \item Словарным влючением (\emph{dict comprehension})\footnote{Появились в \emph{Python} 2.7. Аналогичны списковым включениям, которые будут рассмотрены позднее.}.
\begin{pylst}{}{}
>>> d = { k : v for k, v in enumerate('ABCD') if v not in 'CB' }
>>> d
{0: 'A', 3: 'D'}
\end{pylst}
\end{itemize}

Ключами не могут быть изменяемые объекты, как списки и другие словари, так как они сравниваются структурно, а структура их может меняться (например, мы можем добавить новый элемент). В то же время ключом может быть произвольный объект, так как сравнение происходит по адресу в памяти, а не структурно. Проиллюстрируем:
\begin{pylst}{}{}
>>> d = dict()
>>> d[list()] = 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'

>>> class dummy(object):
...     def __init__(self):
...         self._list = list()
...
>>> d[dummy()] = 1
>>> d
{<__main__.dummy object at 0x7f922fb3a410>: 1}
\end{pylst}

Ниже рассмотрены некоторые операции над словарями:

\lstinline{d[key]}. Возвращает объект, ассоциированный с ключом \lstinline{key}. Если такового нет — исключение \lstinline{KeyError}.
\begin{pylst}{}{}
>>> d = dict(one=1)
>>> d['one']
1
\end{pylst}

\lstinline{d[key] = value}. Ассоциирует объект \lstinline{value} с ключом \lstinline{key}.
\begin{pylst}{}{}
>>> d = dict()
>>> d['fruits'] = ('banana', 'apple', 'pear')
>>> d
{'fruits': ('banana', 'apple', 'pear')}
\end{pylst}

\lstinline{del d[key]}. Удаляет объект, ассоциированный с ключом \lstinline{key}.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)
>>> del d['two']
>>> d
{'one': 1}
\end{pylst}

\lstinline{key in d} и \lstinline{key not in d}. Проверяют наличие или отсутствие соответственно ключа \lstinline{key} в словаре \lstinline{d}.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)
>>> 'one' in d
True
>>> 'three' in d
False
\end{pylst}

\lstinline{d.clear()}. Удаляет все элементы из словаря.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)
>>> d.clear()
>>> d
{}
\end{pylst}

\lstinline{d.items()} и \lstinline{d.iteritems()}. Метод \lstinline{items()} возвращает список пар вида \lstinline{(key, value)}. Метод же \lstinline{iteritems()} возвращает итератор по тем же парам.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)

>>> d.items()
[('two', 2), ('one', 1)]
>>> d.iteritems()
<dictionary-itemiterator object at 0x7f922fb88f18>

>>> for k, v in d.iteritems():
...     print k, ':', v
...
two : 2
one : 1
\end{pylst}

\lstinline{d.keys()} и \lstinline{d.iterkeys()}. Метод \lstinline{keys()} возвращает список всех ключей. Метод \lstinline{iterkeys()} возвращает итератор по ключам.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)

>>> d.keys()
['two', 'one']
>>> d.iterkeys()
<dictionary-keyiterator object at 0x7f922fb88f18>

>>> for k in d.iterkeys():
...     print k,
...
two one
\end{pylst}

\lstinline{d.values()} и \lstinline{d.itervalues()}. Метод \lstinline{values()} возвращает список всех значений. Метод \lstinline{itervalues()} возвращает итератор по значениям.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)

>>> d.values()
[2, 1]
>>> d.itervalues()
<dictionary-valueiterator object at 0x7f922fb88f18>

>>> for v in d.itervalues():
...     print v,
...
2 1
\end{pylst}

\lstinline{d.update(other)}. Обновляет словарь элементами словаря \lstinline{other}.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)
>>> d.update({ 'three' : 3 })
{'one': 1, 'three': 3, 'two': 2}
\end{pylst}

\lstinline{d.get(key[, default])}. Если в словаре есть значение для ключа \lstinline{key}, то возвращает его, иначе — \lstinline{default}, если он передан, и исключение \lstinline{KeyError}, если нет.
\begin{pylst}{}{}
>>> d = dict(one=1)
>>> d.get('one', None)
1
>>> d.get('two', None)
None
\end{pylst}

\lstinline{d.setdefault(key[, default])}. Если в словаре нет значения для ключа \lstinline{key}, то ассоциирует с ним значение \lstinline{default}. Если \lstinline{default} не передан при вызове, то он равняется \lstinline{None}.
\begin{pylst}{}{}
>>> d = dict(furniture=['chair'])
>>> d
{'furniture': ['chair']}

>>> d.setdefault('furniture', list()).append('table')
>>> d
{'furniture': ['chair', 'table']}
\end{pylst}

\subsection{Множества}
Множество (\emph{set}) в \emph{Python} — неупорядоченная коллекция данных, в которой элементы не повторяются. Элементами множеств могут быть лишь хешируемые объекты. Есть два типа множеств: \lstinline{set} и \lstinline{frozenset}. \lstinline{set} — изменяемая структура данных, а \lstinline{frozenset} — нет. Создать их можно несколькими способами:
\begin{itemize}
  \item С помощью встроенных функций \lstinline{set()} и \lstinline{frozenset()}.
\begin{pylst}{}{}
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> fruits = set(basket)
>>> fruits
set(['apple', 'banana', 'orange', 'pear'])
\end{pylst}

  \item Непустое изменяемое множество может быть создано специальным синтаксисом:
\begin{pylst}{}{}
>>> { 'apple', 'orange', 'apple', 'pear', 'orange', 'banana' }
set(['apple', 'banana', 'orange', 'pear'])
\end{pylst}

  \item Изменяемое множество может быть создано множественным включением (\emph{set comprehension})\footnote{Появились \emph{Python} 2.7. Аналогичны списковым включениям, которые будут рассмотрены позднее.}.
\begin{pylst}{}{}
>>> s = { v for v in 'ABCDABCD' if v not in 'CB' }
>>> s
set(['A', 'D'])
\end{pylst}
\end{itemize}

Множества поддерживают ожидаемый набор операций: проверка на присутствие, объединение, пересечение и т. д. Вот некоторые из них, применимые как к изменяемым, так и к неизменяемым множествам:

\lstinline{len(s)}. Возвращает размер множества \lstinline{s}.
\begin{pylst}{}{}
>>> s = set([1, 2, 3])
>>> len(s)
3
\end{pylst}

\lstinline{x in s} и \lstinline{x not in s}. Проверяют, присутствует ли или не присутствует элемент \lstinline{x} в множестве \lstinline{s}.
\begin{pylst}{}{}
>>> s = set([1, 2, 3])
>>> 2 in s
True
>>> 0 in s
False
\end{pylst}

\lstinline{s.isdisjoint(other)}. Возвращает истину, если множество \lstinline{s} не имеет одинаковых элементов с \lstinline{other}, то есть пересечение \lstinline{s} и \lstinline{other} — пустое множество.
\begin{pylst}{}{}
>>> s1, s2, s3 = set([1, 2, 3]), set([4, 5, 6]), set([3, 4])
>>> s1.isdisjoint(s2)
True
>>> s1.isdisjoint(s3)
False
\end{pylst}

\lstinline{s.issubset(other)} или \lstinline{s <= other}. Проверяют, является ли \lstinline{s} подмножеством \lstinline{other}.
\begin{pylst}{}{}
>>> s = set([1, 2, 3])
>>> s.issubset(s)
True
\end{pylst}

\lstinline{s < other}. Проверяет, является ли \lstinline{s} подмножеством \lstinline{other}, причём \lstinline{s != other}.
\begin{pylst}{}{}
>>> s = set([1, 2, 3])
>>> s < s
False
\end{pylst}

\lstinline{s.issuperset(other)} или \lstinline{s >= other}. Проверяют, является ли \lstinline{other} подмножеством \lstinline{s}.
\begin{pylst}{}{}
>>> s = set([1, 2, 3])
>>> s.issuperset(s)
True
\end{pylst}

\lstinline{s > other}. Проверяет, является ли \lstinline{other} подмножеством \lstinline{s}, причём \lstinline{other != s}.
\begin{pylst}{}{}
>>> s = set([1, 2, 3])
>>> s > s
False
\end{pylst}

\lstinline{s.union(other)} или \lstinline{s | other}. Возвращают новое множество, которое является объединением обоих.
\begin{pylst}{}{}
>>> s1, s2 = set([1, 2]), set([2, 3])
>>> s1.union(s2)
set([1, 2, 3])
\end{pylst}

\lstinline{s.intersection(other)} или \lstinline{s & other}. Возвращают пересечение множеств.
\begin{pylst}{}{}
>>> s1, s2 = set([1, 2]), set([2, 3])
>>> s1.intersection(s2)
set([2])
\end{pylst}

\lstinline{s.difference(other)} или \lstinline{s - other}. Возвращают разность множеств.
\begin{pylst}{}{}
>>> s1, s2 = set([1, 2]), set([2, 3])
>>> s1.difference(s2)
set([1])
\end{pylst}

\lstinline{s.symmetric_difference(other)} или \lstinline{s ^ other}. Возвращают симметрическую разность.
\begin{pylst}{}{}
>>> s1, s2 = set([1, 2]), set([2, 3])
>>> s1.symmetric_difference(s2)
set([1, 3])
\end{pylst}

У изменяемых множеств есть следующие методы вдобавок:

\lstinline{s.add(x)}. Добавляет объект \lstinline{x} в множество \lstinline{s}.
\begin{pylst}{}{}
>>> s = set([1, 2])
>>> s.add(3)
>>> s
set([1, 2, 3])
\end{pylst}

\lstinline{s.remove(x)}. Удаляет объект \lstinline{x} из множества. Если же его в нём нет, то — исключение \lstinline{KeyError}.
\begin{pylst}{}{}
>>> s = set([1, 2])
>>> s.remove(1)
>>> s
set([2])
\end{pylst}

\lstinline{s.discard(x)}. Удаляет объект \lstinline{x} из множества, если он там присутствует.
\begin{pylst}{}{}
>>> s = set([1, 2])
>>> s.discard(1)
>>> s.discard(1)
>>> s
set([2])
\end{pylst}

\lstinline{s.clear()}. Удаляет все элементы из множества.
\begin{pylst}{}{}
>>> s = set([1, 2])
>>> s.clear()
>>> s
set([])
\end{pylst}

\section{Операторы}
\label{sec:py-statements}

\subsubsection{Оператор if}
Общая форма оператора \lstinline{if} выглядит следующим образом:
\begin{pylst}{}{}
if $expression$: $suite$
( elif $expression$: $suite$)*
[ else: $suite$ ]
\end{pylst}

Этот оператор вычисляет последовательно выражения $expression$ до тех пор, пока не будет найдено равное \lstinline{true}. После чего выполняется соответсвующее $suite$. Если все выражения оказались равными \lstinline{false}, то выполняются операторы и выражения из \lstinline{else} ветки. Выполняется не больше одного набора операторов и выражений ($suite$).

\subsubsection{Оператор while}
Общая форма оператора \lstinline{while} выглядит следующим образом:
\begin{pylst}{}{}
while $expression$: $suite_1$
[ else: $suite_2$ ]
\end{pylst}

Выполняет $suite_1$ пока $expression$ истинно. Если в первый раз $expression$ оказалось ложно, выполняется ветка \lstinline{else}, после чего цикл завершается. Оператор \lstinline{break} завершает цикл без выполнения ветки \lstinline{else}. Оператор \lstinline{continue} передает управление на начало цикла.

\subsubsection{Оператор for}
Общая форма оператора \lstinline{for} выглядит следующим образом:
\begin{pylst}{}{}
for $variable$ in $expression$: $suite_1$
[ else: $suite_2$ ]
\end{pylst}

$expression$ вычисляется единожды. Оно должно вычислятся в итерируемый объект. Затем $suite_1$ вычисляется столько раз, сколько объектов в итерируемом объекте, при этом переменной $variable$ присваивается очередной объект. По завершении вычисляется ветка \lstinline{else}.

Оператор \lstinline{break} завершает цикл без выполнения ветки \lstinline{else}. Оператор \lstinline{continue} передает управление на начало цикла или, если больше нет очередного объекта, на ветку \lstinline{else}.

\subsubsection{Оператор try}
Общая форма оператора \lstinline{try} выглядит следующим образом:
\begin{pylst}{}{}
try: suite
( except [expression [ ( as | "," ) target ] ]: suite )+
[ else: suite ]
[ finally: suite ]
\end{pylst}
или
\begin{pylst}{}{}
try: suite
finally: suite
\end{pylst}

Блоки \lstinline{except} определяют обработчики исключительных ситуаций. Если в блоке \lstinline{try} не возникло исключительной ситуации, то ни один из обработчиков не выполняется. В ином случае происходит поиск подходящего обработчика последовательно по блокам \lstinline{except}. Блок \lstinline{except} без выражений $expression$, если таковой присутствует, должен быть последним. При поиске выражения $expression$ вычисляются, и блок выбирается для выполнения, если объект-результат подходит к возникшему исключению, т.е. если объект является классом, который присутствует в списке наследования объекта исключения, или же кортежем, в котором хотя бы один элемент является совместимым с исключением.

Если обработчик не найден, поиск происходит в обрамляющем коде и вверх дальше по стеку, если блок \lstinline{finally} не присутсвует.

Если при выполнении выражений $expression$ возникло исключение, то изначальное исключение отбрасывается, и начинается новый поиск для нового исключения в обрамляющем коде и вверх по стеку.

Если же подходящий блок \lstinline{except} найден, то $target$, если присутствует, присваивается результат вычисления $expression$, и блок исполняется. После чего управление передается, как правило, за пределы оператора \lstinline{try}.

В блоке обработчика можно вызвать \lstinline{sys.exc_info}, которая возвращает кортеж \lstinline{(exc_type, exc_value, exc_traceback)}, где \lstinline{exc_type} --- объект исключения, \lstinline{exc_value} --- параметры, переданные исключению, \lstinline{exc_traceback} --- traceback объект.

Блок \lstinline{else} выполняется в том случае, если управление достигло конца блока \lstinline{try}. Исключения, возникшие в блоке \lstinline{else} не обрабатываются предыдущими ему обработчиками.

Блок \lstinline{finally} выполняется всегда, где бы исключительная ситуация не возникла: внутри блок \lstinline{try}, \lstinline{except} или же \lstinline{else}.

\subsubsection{Оператор with}
Общая форма оператора \lstinline{with} выглядит следующим образом:
\begin{pylst}{}{}
with $expression$ [ as $target$ ]: $suite$
\end{pylst}

Схема работы следующая:
\begin{enumerate}
  \item $expression$ вычисляется.
  \item Вызывается метод \lstinline{__enter__()} у результата вычисления $expression$.
  \item Если использовалась форма \lstinline{as target}, то значение возвращенное из \lstinline{__enter__} присваивается $target$.
  \item Исполняется $suite$.
  \item Вызывается метод \lstinline{__exit__()}. Если возникло исключение при исполнении $suite$ и метод \lstinline{__exit__()} вернул \lstinline{False}, то исключение порождается вновь.
\end{enumerate}

\begin{pylst}{}{}
import threading

lock = threading.Lock()
with lock: ...
\end{pylst}

\section{Функции}
Ниже приведено тривиальное определение функции:
\begin{pylst}{}{}
def add(a, b):
    return a + b
\end{pylst}

Как видно из примера, определение функции начинается с оператора \lstinline{def}, за которым идет имя функции, а следом — аргументы, заключенные в круглые скобки. Возврат значения происходит посредством оператора \lstinline{return}. Если возврат из функции происходит из-за того, что управление достигло конца функции, то возвращаемое значение равно \lstinline{None}. Определение функции связывает её имя с объектом функции (обёрткой над действительно исполняемым кодом) в текущем пространсве имён. Объект функции содержит ссылку на текущее глобальное пространство имён, которое будет использоваться при вызове функции.
\begin{pylst}{}{}
>>> type(add)
<type 'function'>
>>> add.__globals__
{'__builtins__': <module '__builtin__' (built-in)>,
 '__name__': '__main__', 'add': <function add at 0x7f4f81af8578>,
 '__doc__': None, '__package__': None}
\end{pylst}

Определение функции может быть обёрнуто декораторами\footnote{Декораторы рассматриваются в секции~«\nameref{sec:py-decorators}» на стр.~\pageref{sec:py-decorators}.}. Декораторы вычисляются во время определения функции в том же самом контексте, где находится определение функции.

Функция может иметь именованные аргументы, которые имеют значение по умолчанию. При вызове функции не обязательно передавать именованные аргументы, если устраивает значение по умолчанию. В определении функции после именованного аргумента могут идти только именованные аргументы.
\begin{pylst}{}{}
def yes_or_no(prompt, retries=4, complaint='Please enter Yes or No.'):
    while True:
        answer = raw_input(prompt)
        answer = answer.lower()
        if answer in ('y', 'ye', 'yes'):
            return True
        if answer in ('n', 'no', 'nop', 'nope'):
            return False

        retries -= 1
        if retries < 0:
            raise IOError('User has not approved or declined an action.')

        print complaint
\end{pylst}

Примеры вызовов вышеприведённой функции:
\begin{pylst}{}{}
>>> yes_or_no('Delete the file:', retries=3)
...
>>> yes_or_no('Will you marry me?',
              complaint="That's fine, but one more time...")
...
\end{pylst}

Значения по умолчанию для именованных аргументов вычисляются один раз при выполнении определения функции. После чего при любом вызове используется один и тот же объект. Если значение по умолчанию --- изменяемый (mutable) объект, то можно наткнуться на неприятности, что и проиллюстрировано ниже:
\begin{pylst}{}{}
def append(list=[]):
    list.append('a')
    return list

>>> append()
['a']
>>> append()
['a', 'a']
>>> append()
['a', 'a', 'a']
\end{pylst}

Ниже представлена версия, лишенная приведенного недостатка:
\begin{pylst}{}{}
def append(list=None):
    if list is None:
        list = []
    list.append('a')
    return list

>>> append()
['a']
>>> append()
['a']
\end{pylst}

Если в определении функции присутствует форма \lstinline{*identifier}, то \lstinline{identifier} будет равен кортежу, который содержит все аргументы, которые не были явно проименованы. Если же присутствует форма \lstinline{**identifier}, то \lstinline{identifier} будет словарём, который отображет имена аргументов на их значения.
\begin{pylst}{}{}
def fargs(*args):
    print args

def fkwargs(**kwargs):
    print kwargs

>>> fargs(1, 2, 3)
(1, 2, 3)
>>> fkwargs(one=1, two=2, three=3)
{'three': 3, 'two': 2, 'one': 1}
\end{pylst}

При вызове если происходит ошибка разбора аргументов, их нехватка или избыток и так далее, то порождается исключение \lstinline{TypeError}. Если при вызове присутствует форма \lstinline{*identifier}, то \lstinline{identifier} должен вычисляться в последовательность, элементы которой будут считаться дополнительными позиционными аргументами. Если же при вызове присутсвует форма \lstinline{**identifier}, то \lstinline{identifier} должен вычисляться в словарь, ключи которого будут использоваться в качестве именованных аргументов, а значения — в качестве значений этих аргументов.
\begin{pylst}{}{}
def fargs(a, b, c):
    print a, b, c

def fkwargs(a, b=2, c=3):
    print a, b, c

>>> args = [1, 2, 3]
>>> fargs(*args)
1 2 3

>>> kwargs = { 'a' : 2, 'b' : 3, 'c' : 4 }
>>> fkwargs(**kwargs)
2 3 4
\end{pylst}

Обе формы могут присутствовать одновременно как при определении функции, так и при вызове.

Функция может иметь \emph{строку документации} (\emph{docstring}), которая записывается на следующей строке после сигнатуры функции. Строка документации позже может быть получена из аттрибута функции \lstinline{__doc__}.
\begin{pylst}{}{}
def func():
   """Here goes docstring."""
   pass

>>> func.__doc__
'Here goes docstring.'
\end{pylst}

\subsubsection{Анонимные функции}
\emph{Анонимные (безымянные) функции} в \emph{Python} — объекты функций, которые не имеют имени ни в каком пространстве имён после \emph{непосредственного} определения. Они определяются с помощью \emph{лямбда-выражений}:
\begin{pylst}{}{}
lambda [ $parameters$ ]: $expression$
\end{pylst}

В отличии от обычного определения функции лямбда-выражение не может содержать операторов (\emph{statements}).
\begin{pylst}{}{}
>>> map(lambda i: i + 1, [1, 2, 3])
[2, 3, 4]
\end{pylst}

\section{Функциональное программирование}
В \emph{Python} возможно использовать некоторые идеи функционального программирования.

\subsection{Функции высшего порядка}
\emph{Функция высшего порядка} — функция, принимающая в качестве аргументов другие функции или возвращающая функцию в качестве результата. Как пример, реализуем композицию двух функций одного аргумента.
\begin{pylst}{}{}
def compose(g, f):
    return lambda x: g(f(x))

def f(x):
    return x + 3

def g(x):
    return 2 * x
 
>>> z = compose(g, f)
>>> z(2)
10
\end{pylst}

Ниже представлены наиболее общеупотребимые функции высшего порядка, определенные в \emph{Python}.

\subsubsection{Функция map}
\lstinline{map} — функция высшего порядка, которая применяет переданную функция к элементам одной или нескольких последовательностей. Количество аргументов переданной функции должно быть равно количеству переданных последовательностей. Если последовательности не одинаковой длины, то вместо недостающих элементов используется \lstinline{None}. Длина результирующего списка равна длине наибольшего списка. Если вместо функции передается \lstinline{None}, тогда элементы последовательностей никак не преобразуются, а используются как есть; при этом если последовательностей — несколько, то результатом будет список кортежей.
\begin{pylst}{}{}
map(function, sequence[, sequence, ...]) -> list

>>> map(lambda x, y: x + y, [1, 2, 3], [2, 3, 4])
[3, 5, 7]
>>> map(None, [1, 2], [3])
[(1, 3), (2, None)]
\end{pylst}

\subsubsection{Функция filter}
\lstinline{filter} — функция высшего порядка, которая конструирует итоговый список из элементов переданной последовательности, если конкретный элемент удовлетворяет функции-предикату. Если в качестве последовательности передается строка или кортеж, то и тип результата будет строка или кортеж, соответственно. Если функция равна \lstinline{None}, то возвращаемая последовательность будет состоять из элементов, которые истинны.
\begin{pylst}{}{}
filter(function or None, sequence) -> list, tuple, or string

>>> filter(lambda x: x % 2, [1, 2, 3, 4, 5])
[1, 3, 5]
\end{pylst}

\subsubsection{Функция reduce}
\lstinline{reduce} — функция высшего порядка, которая делает свёртку последовательности, в результате чего получается, как правило, значение типа элемента последовательности. Функция свёртки обычно принимает три аргумента: комбинирующую функцию \lstinline{function}, начальное значение \lstinline{initial} и последовательность \lstinline{sequence}.
\begin{pylst}{}{}
reduce(function, sequence[, initial]) -> value
\end{pylst}

$4!$ можно вычислить следующим образом, используя функцию \lstinline{reduce}:
\begin{pylst}{}{}
>>> reduce(lambda res, x: res * x, [2, 3, 4], 1)
24
\end{pylst}

Вычисление происходит следующим образом:
\begin{center}
  \begin{tikzpicture}[level/.style={sibling distance=50mm/#1}]
    \node [circle, draw] {$*$}
      child { node [circle, draw] {$*$}
        child { node [circle, draw] {$*$} 
          child { node [circle, draw] {$1$} }
          child { node [circle, draw] {$2$} } }
        child { node [circle, draw] {$3$} } }
      child { node [circle, draw] {$4$} };
  \end{tikzpicture}
\end{center}

Другая иллюстрация:
\begin{pylst}{}{}
(((1 * 2) * 3) * 4)
\end{pylst}

\subsection{Рекурсия}
Хоть в \emph{Python} и существует рекурсия, но в наиболее популярной реализации этого языка — \emph{CPython} — она не православна, так как там нет \emph{оптимизации хвостовых вызовов} (\emph{tail call optimization}, \emph{TCO}).

\emph{Хвостовая рекурсия} — специальный случай рекурсии, при котором последней операцией, выполняемой рекурсивной функцией, является вызов самой себя. Подобный вид рекурсии примечателен тем, что может быть легко и автоматически заменён на итерацию, что и делают многие оптимизирующие компиляторы. Подобные рассуждения справедливы и для взаимно рекурсивных функций, хоть \emph{TCO} для них в компиляторах встречается еще реже.

\begin{pylst}{}{}
def infinite():
    infinite()

>>> infinite()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
...
RuntimeError: maximum recursion depth exceeded
\end{pylst}

Получить и установить максимальное возможное количество рекурсивные вызовов можно с помощью функцией \lstinline{sys.getrecursionlimit()} и \lstinline{sys.setrecursionlimit(limit)}.

\subsection{Замыкания}
\emph{Замыкание} — первоклассная функция со свободными переменными, которые связаны с определенными значениями в своем лексическом окружении. \emph{Свободная переменная} — переменная, которая встречается в теле функции, но которая не является параметром этой функции или локальной переменной.
\begin{pylst}{}{}
def make_adder(y):
    def add(x):
        return x + y
    return add

>>> add5 = make_adder(5)
>>> add5(5)
10
>>> add5(7)
12
\end{pylst}

Замыкание \lstinline{add} создается при каждом вызове функции \lstinline{make_adder}. В замыкании \lstinline{add} переменная \lstinline{y} является свободной переменной.

Замыкания в \emph{Python} также не доведены до логического конца, хоть в версиях 3.x уже такая претензия есть. В версии 3.0 введен оператор \lstinline{nonlocal}, суть которого видна из следующего примера:
\begin{pylst}{}{}
def make_counter():
    count = 0
    def get():
        return count
    def inc():
        count += 1

    return get, inc

>>> get, inc = make_counter()
>>> get()
>>> 0
>>> inc()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/tmp/py9637pml", line 11, in inc
UnboundLocalError: local variable 'count' referenced before assignment

def make_counter():
    count = 0
    def get():
        nonlocal count
        return count
    def inc():
        count += 1

    return get, inc

>>> get, inc = make_counter()
>>> get()
>>> 0
>>> inc()
>>> get()
1
\end{pylst}

\subsection{Частичное применение функции}
\emph{Частичное применение} функции — это преобразование функции от $n$ аргументов к функции от $n - m$ аргументов ($m < n$), в которой $m$ аргументов привязаны к определенным значениям. То есть некоторые аргументы изначальной функции фиксируются.

Эта возможность предоставляется стандартной библиотекой \emph{Python}:
\begin{pylst}{}{}
from functools import partial
basetwo = partial(int, base=2)

>>> basetwo('10010')
18
\end{pylst}

\subsection{Списковые включения}
\emph{Списковое включение} (\emph{list comprehension}) — удобная конструкция для порождения списков. Часто предпочтительней использовать именно списковые включения, а не набор функций \lstinline{map} и \lstinline{filter}. Суть видна из следующих демонстраций:

\begin{pylst}{}{}
>>> [i for i in range(10)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

>>> [[i * j for j in range(5)] for i in range(5)]
[[0, 0, 0, 0, 0],
 [0, 1, 2, 3, 4],
 [0, 2, 4, 6, 8],
 [0, 3, 6, 9, 12],
 [0, 4, 8, 12, 16]]

>>> [i + j for i in range(3) for j in range(3)]
[0, 1, 2, 1, 2, 3, 2, 3, 4]

>>> [i + j for i in range(3) if i % 2 == 0 for j in range(3) if j % 2 == 1]
[1, 3]
\end{pylst}

\section{Модули}
\label{sec:py-modules}
Модуль представляет собой функционально законченный фрагмент программы, оформленный, как правило, в виде отдельного файла с исходным кодом, предназначенный для использования в других программах. Модули позволяют разбивать сложные задачи на более мелкие.

Модуль импортируются с помощью оператора \lstinline{import}. Модуль имеет пространство имён, представляющее собой словарь (это тот самый словарь, на который ссылает \lstinline{func_global} аттрибут любой определенной функции в этом модуле). Чтение аттрибута модуля \lstinline{m.x} эквивалентно поиску по ключу в словаре \lstinline{m.__dict__['x']}.

Каждый модуль имеет несколько специальных аттрибутов:
\begin{itemize}
  \item \lstinline{__name__} --- имя модуля;
  \item \lstinline{__doc__} --- строка документации модуля или \lstinline{None}, если её нет;
  \item \lstinline{__file__} --- путь к файлу, если таковой существует, из которого модуль был загружен.
\end{itemize}

Оператор \lstinline{import} имеет две формы:
\begin{pylst}{}{}
import $module$
from $module$ import ( $something$ [ as $someothername$ ] )+
\end{pylst}

Процесс импорта состоит из двух шагов:
\begin{enumerate}
  \item Поиск модуля и его инициализация, если необходима.
  \item Определение локальных имен в той области видимости, где находится сам оператор \lstinline{import}.
\end{enumerate}

Первая форма оператора делает как первый шаг, так и второй. Вторая же форма оператора выполняет первый шаг единожды, после чего повторяет второй шаг для всех импортируемых имён.

Модули и пакеты могут образовывать иерархию. Модули не могут содержать ни другие модули, ни другие пакеты. В то время как пакет может содержать как другие модули, так и другие пакеты. Если эту структуру отображать на файловую систему, то модулям сответствуют файлы, а пакетам --- директории.
\begin{plainlst}{}{}
edu
|
`__init__.py
 informatics
 |
 `__init__.py
  ai.py
\end{plainlst}

Пусть в \texttt{ai.py} определен класс \lstinline{NotSoIntelligent}. Тогда все следующие операции импорта корректны:
\begin{pylst}{}{}
import edu
from edu import informatics
from informatics import ai as infoai
from infoai import *

NotSoIntelligent()
\end{pylst}

Если при импортировании модуль не может быть найдет, то возникает исключение \lstinline{ImportError}. При использовании формы импорта модуля со звёздочкой в текущее пространство импортируются все публичные имена. Их список определяется в переменной \lstinline{__all__} модуля или же конструируется из всех глобальных имён импортируемого модуля.
\begin{pylst}{A.py}{}
__all__ = ['one']

one = 1
two = 2
\end{pylst}

\begin{pylst}{}{}
>>> from A import *
>>> one
1
>>> two
NameError: name 'two' is not defined
\end{pylst}

Импорт может быть относительным. Точка перед модулем значит, что путь до модуля нужно искать от того модуля, где происходит импорт. Если две точки, то начинать надо с уровня выше. И так далее. Например, если импорт \lstinline{from . import mod} происходит из модуля в пакете \lstinline{pkg}, то импортирован будет модуль \lstinline{pkg.mod}. Если же импорт \lstinline{from ..subpkg2 import mod} --- из пакета \lstinline{pkg.subpkg1}, импортирован модуль \lstinline{pkg.subpkg2.mod}.

При выполненении \lstinline{from mod import *} не импортируются имена, которые начинаются с \lstinline{_}. Модули можно подгружать динамически, используя встроенную функцию \lstinline{__import__}.


\section{Объектно-ориентированное программирование}
\label{sec:py-oop}
В Python всё --- объекты, и даже типы. Типы --- экземпляры \lstinline{type}. Python поддерживает множественное наследование и перегрузку операторов. Например, оператор \lstinline{+} можно перегрузить для объекта путём определения метода \lstinline{__add__}.

Простое определение класса:
\begin{pylst}{}{}
class MyClass(object):
    i = 12345
    def __init__(self):
        self.i = 54321
    def f(self):
        return self.i
\end{pylst}

Видно, что \lstinline{MyClass} отнаследован от класса \lstinline{object}. Если надо, чтобы объект наследовался от многих классов, то их надо записывать через запятую. В месте указания базовых классов может быть любое выражение, лишь бы результатом его вычисления был тип.
\begin{pylst}{}{}
def get_object():
    return object

class ExpChild(get_object()):
    pass
\end{pylst}

Если в классе определена переменная, а в методах выполняется \lstinline{self.var = value}, то тем самым определяется переменная экземпляра, которая затеняет переменную класса с тем же именем.
\begin{pylst}{}{}
>>> c = MyClass()
>>> c.i
54321
>>> MyClass.i
12345
\end{pylst}

Инициализация --- и только! --- происходит в методе \lstinline{__init__()}. Если надо контролировать процесс создания объекта, то следует переопределять \lstinline{__new__(cls[, ...])}, как один из вариантов.
\begin{pylst}{}{}
class Complex(object):
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

>>> c = Complex(5.1, 3.0)
>>> c.real, c.imag
(5.1, 3.0)
\end{pylst}

Также можно определять свойства:
\begin{pylst}{}{}
class C(object):
    x = 0
    def getx(self):
        return self._x
    def setx(self, value):
        self._x = value
    def delx(self):
        del self._x
    x = property(getx, setx, delx, "I'm the 'x' property.")

# another way

class C(object):
    x = 0
    @property
    def x(self):
        return self._x
    @x.setter
    def x(self, value):
        self._x = value
    @x.deleter
    def x(self):
        del self._x
\end{pylst}

\lstinline{getx()} будет вызываться при выражении \lstinline{x = instance.x}, \lstinline{setx(value)} будет вызываться при выражении \lstinline{instance.x = x}, а \lstinline{delx()} --- при \lstinline{del instance.x}.

Для вызовы методов базовых классов из какого-либо метода следует использовать встроенную функцию \lstinline{super(type[, object-or-type])}. Аттрибут \lstinline{__mro__} типа \lstinline{type} является списком типов, который определяет по каким типам и в каком порядке будет происходить поиск нужного метода при использовании функции \lstinline{super()}. \lstinline{__mro__} может изменяться, когда изменяется иерархия наследования.
\begin{pylst}{}{}
class A(object):
    def f(self):
        print 'A'

class B(A):
    def f(self):
        print 'B'
        super(B, self).f()

class C(A):
    def f(self):
        print 'C'
        super(C, self).f()

class D(B, C):
    def f(self):
        print 'D'
        super(D, self).f()

>>> D.__mro__
(<class '__main__.D'>,
 <class '__main__.B'>,
 <class '__main__.C'>,
 <class '__main__.A'>,
 <type 'object'>)

>>> D().f()
D
B
C
A
\end{pylst}

То есть \lstinline{__mro__} содержит линеаризованный граф с уникальными элементами, чтобы ни один метод какого-либо базового класса не вызывался несколько раз, если переопределенный метод достижим по нескольким путям.

Проверять отношения наследования функциями \lstinline{isinstance(object, class-or-type-or-tuple)} и \lstinline{issubclass(C, B)}.
\begin{pylst}{}{}
>>> issubclass(D, D), issubclass(D, A), isinstance(D(), A)
(True, True, True)
\end{pylst}

Статические методы и методы класса определяются следующим образом:
\begin{pylst}{}{}
class MyClass(object):
    @classmethod
    def clsmethod(cls):
        print cls, 'class'

    @staticmethod
    def statmethod()
        print 'static'
\end{pylst}

В Python возможно использовать не-очень-приватные поля:
\begin{pylst}{}{}
class C(object):
    def __init__(self):
        self.__private = 1

>>> c = C()
>>> dir(c)
['_C__private', '__class__', '__delattr__', '__dict__', '__doc__',
 '__format__', '__getattribute__', '__hash__', '__init__',
 '__module__', '__new__', '__reduce__', '__reduce_ex__',
 '__repr__', '__setattr__', '__sizeof__', '__str__',
 '__subclasshook__', '__weakref__']
\end{pylst}

То есть любое имя вида \lstinline{__*} внутри определения класса \lstinline{Class} преобразуется в \lstinline{_Class__*}.

\subsection{Специальные методы}

\subsubsection{Доступ к аттрибутам}
\begin{itemize}
  \item \lstinline{object.__getattr__(self, name)}. Вызывается, если аттрибут не найден обычном поиском. Должен вернуть имя аттрибута или же породить исключение \lstinline{AttributeError}.
  \item \lstinline{object.__setattr__(self, name, value)}. Вызывается всегда для установки значения \lstinline{value} аттрибуту с именем \lstinline{name}.
  \item \lstinline{object.__delattr__(self, name)}.
  \item \lstinline{object.__getattribute__(self, name)}. Вызывается всегда. Если порождает исключение \lstinline{AttributeError}, вызывается метод \lstinline{object.__getattr__(self, name)}.
\end{itemize}

\subsubsection{Реализация протокола дескриптора}
\begin{itemize}
  \item \lstinline{object.__get__(self, instance, owner)}
  \item \lstinline{object.__set__(self, instance, value)}
  \item \lstinline{object.__delete__(self, instance)}
\end{itemize}

Дескриптор --- это объект, который реализует хотя бы один из вышеперечисленных методов. Если у объекта \lstinline{obj} есть аттрибут \lstinline{d}, который в свою очередь есть дескриптор, то код \lstinline{obj.d} эквивалентен коду \lstinline{type(obj).__dict__['x'].__get__(obj, type(obj))}.

\begin{pylst}{Пример дескриптора}{}
import random

class Die(object):
    def __init__(self, sides=6):
        self.sides = sides

    def __get__(self, instance, owner):
        return int(random.random() * self.sides) + 1

class Game(object):
    d6 = Die()
    d10 = Die(sides=10)
    d20 = Die(sides=20)

>>> Game.d6
5
>>> Game.d10
8
>>> Game.d20
19
>>> Game.d20
3
\end{pylst}

\subsubsection{Настройка проверок экземпляров и подклассов}
\begin{itemize}
  \item \lstinline{class.__instancecheck__(self, instance)}. Возвращает \lstinline{True}, если \lstinline{instance} должен рассматриваться как экземпляр класса.
  \item \lstinline{class.__subclasscheck__(self, subclass)}. Возвращает \lstinline{True}, если \lstinline{subclass} должен рассматриваться как потомок класса.
\end{itemize}

\section{Итераторы и генераторы}
\label{sec:py-iterators}

\subsubsection{Итераторы}
Итератор --- объект, позволяющий перебирать все элементы коллекции. Для реализации итерирования коллекции необходимо переопределить метод \lstinline{__iter__()}, который возвращает объект с реализованными методами \lstinline{__iter__()} и \lstinline{next()}. Метод \lstinline{__iter__()} итератора должен возвращать сам же итератор, чтобы как объекты, так и итераторы можно было использовать, например, с оператором \lstinline{for}. Метод \lstinline{next()} должен возвращаеть следующий элемент, если же такового нет, то он должен порождать исключение \lstinline{StopIteration}.
\begin{pylst}{}{}
class counter(object):
    def __init__(self, limit):
        assert limit >= 0
        self._limit = limit
        self._value = 0

    def __iter__(self):
        return self

    def next(self):
        if self._value < self._limit:
            self._value += 1
            return self._value - 1
        else:
            raise StopIteration

>>> [i for i in counter(10)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{pylst}

Для удобного создания итераторов и работы с ними в Python есть библиотека \texttt{itertools}.

\subsubsection{Генераторы}
Генераторы позволяют удобно реализовывать протокол итератора. Генератор есть функция, в которой используется оператор \lstinline{yield}, то есть для определения генератора достаточно просто записать оператор \lstinline{yield} в теле функции, это не имеет никакого отношения к времени исполнения.

При вызове генератора возвращается итератор (технически, объект-генератор). Когда вызывается какой-либо метод итератора, начинается выполнение до первого встреченного оператора \lstinline{yield}, выполнение приостанавливается, запоминается точка возврата, и, наконец, возвращается значение при операторе \lstinline{yield}. При следующем вызове итератора выполнение начинается с точки останова. Так продолжается до тех пор, пока генератор не завершится любым отличным от оператора \lstinline{yield} способом (достигнет конца тела функции, при помощи оператора \lstinline{return}, исключительная ситуация).

В объекте-генераторе определены следующие методы:
\begin{itemize}
  \item \lstinline{next()}. Начинает выполнение функции-генераторы сначала или же вместе останова, если таковой присутствовал. Если выполнение начинается с точки останова, то текущий оператор \lstinline{yield} вычисляется в \lstinline{None}, и вычисление продолжается дальше. Если функция завершается не посредством \lstinline{yield}, то порождается исключение \lstinline{StopIteration}.

  \item \lstinline{send(value)}. Возобновляет выполнение и передает значение \lstinline{value} в точку останова. \lstinline{value} подставляется вместо текущего оператора \lstinline{yield}. Возвращает следующее значение, которое вернул оператор \lstinline{yield}, или порождает исключение \lstinline{StopIteration}, если функция-генератор завершилась другим способом. Если \lstinline{send(value)} вызывается для пуска генератора, то \lstinline{value} должно быть \lstinline{None}.
  \item \lstinline{throw(type[, value[, traceback]])}. Порождает исключение типа \lstinline{type} там, где функция-генератор была остановлена, и возвращает следующее значение, которая вернет функция-генератор. Если функция просто завершается, то порождается исключение \lstinline{StopIteration}.
  \item \lstinline{close()}. Порождает исключение \lstinline{GeneratorExit} в месте останова. Если функция-генератор затем порождает \lstinline{StopIteration} (или завершаясь нормально, или если уже была завершена) или \lstinline{GeneratorExit} (просто не обрабатывая его), происходит возврат из \lstinline{close}. Если функция возвращает значение оператором \lstinline{yield}, то возникает исключение \lstinline{RuntimeError}.
\end{itemize}

\begin{pylst}{}{}
def infinite(i):
    while True:
        yield i

>>> g = infinite(5)
>>> g.next()
5
>>> g.next()
5
\end{pylst}

С помощью генераторов можно реализовать, например, координатор сопрограмм (coroutines). Сопрограмма --- компонент программы, обобщающий понятие подпрограммы, который дополнительно поддерживает множество входных точек и остановку и продолжение выполнения.
\begin{pylst}{Из PEP 342}{}
import collections
import sys
import types

class Trampoline(object):
    def __init__(self):
        self.running = False
        self.queue = collections.deque()

    def add(self, coroutine):
        self.schedule(coroutine)

    def run(self):
        result = None
        self.running = True
        try:
            while self.running and self.queue:
                func = self.queue.popleft()
                return func()
            return result
        finally:
            self.running = False

    def stop(self):
        self.running = False

    def schedule(self, coroutine, stack=(), val=None, *exc):
        def resume():
            try:
                if exc:
                    value = coroutine.throw(val, *exc)
                else:
                    value = coroutine.send(val)
            except:
                if stack:
                    # send the error back to the co-caller
                    self.schedule(stack[0], stack[1], *sys.exc_info())
                else:
                    # propogate it to the real caller
                    raise

            if isinstance(value, types.GeneratorType):
                # push the new coroutine and call the new one
                self.schedule(value, (coroutine, stack))
            elif stack:
                # got a result, pop the stack and send the result
                # to the caller
                self.schedule(stack[0], stack[1], value)
            # else: this co-routine has ended

        self.queue.append(resume)

# simple echo server giving that we have non-blocking operations

# coroutine function that echos data back on a connected socket
def echo_handler(sock):
    while True:
        try:
            data = yield nonblocking_read(sock)
            yield nonblocking_write(sock, data)
        except ConnectionLost:
            pass  # exit normally if connection lost

# coroutine function that listens for connections on a
# socket, and then launches a service "handler" coroutine
# to service the connection
def listen_on(trampoline, sock, handler):
    while True:
        # get the next incoming connection
        connected_socket = yield nonblocking_accept(sock)

        # start another coroutine to handle the connection
        trampoline.add(handler(connected_socket))

# Create a scheduler to manage all our coroutines
trampoline = Trampoline()

# Create a coroutine instance to run the echo_handler on
# incoming connections

# Add the coroutine to the scheduler
trampoline.add(listen_on(trampoline,
                         listening_socket("localhost", "echo"),
                         echo_handler))

# loop forever, accepting connections and servicing them
trampoline.run()
\end{pylst}

\subsubsection{Генераторные выражения}
Генераторное выражение --- выражение, которое возвращает итератор. Выглядит, как списковое включение, лишь с тем отличием, что вместо квадратных скобок используются круглые.
\begin{pylst}{}{}
>>> sum(i*i for i in range(10))
285
\end{pylst}

\section{Декораторы}
\label{sec:py-decorators}
Декоратор --- объект, который можно вызвать с одним аргументом. Он волен делать с переданным аргументом всё, что угодно, лишь бы программа оставалась корректной.
\begin{pylst}{}{}
def debug(func):
    def wrapped(*args, **kwargs):
        print "%s called with: %s, %s" % (func.__name__, args, kwargs)
        ret = func(*args, **kwargs)
        print "%s returned: %s" % (func.__name__, ret)
        return ret
    return wrapped

@debug
def inc(i):
    return i + 1
\end{pylst}

@-синтаксис введен всего лишь для удобства. Вышеопределенное декорирование эквивалентно следующему:
\begin{pylst}{}{}
def inc(i):
    return i + 1

inc = debug(inc)
\end{pylst}

Пример вызова декорированной функции \lstinline{inc}:
\begin{pylst}{}{}
>>> inc(1)
inc called with: (1,), {}
inc returned: 2
\end{pylst}

\subsection{Примеры декораторов}
\subsubsection{Псевдокаррирование}
Каррирование или карринг (англ. currying) в информатике --- преобразование функции от пары аргументов в функцию, берущую свои аргументы по одному.
\begin{pylst}{}{}
class curried(object):
    def __init__(self, func, *a):
        self.func = func
        self.args = a

    def __call__(self, *a):
        args = self.args + a
        if len(args) < self.func.__code__.co_argcount:
            return curried(self.func, *args)
        else:
            return self.func(*args)

@curried
def add(a, b):
    return a + b

add1 = add(1)
print add1(2)
\end{pylst}

\subsubsection{Синхронизация}
Декорированная функция пытается захватить взаимное исключение перед тем, как исполняться.

\begin{pylst}{}{}
def synchronized(lock):
    def wrap(f):
        def sync(*args, **kwargs):
            lock.acquire()
            try:
                return f(*args, **kwargs)
            finally:
                lock.release()
        return sync
    return wrap

# Example usage:

from threading import Lock
lock = Lock()

@synchronized(lock)
def critical_one(*args):
    pass

@synchronized(lock)
def critical_two(*args):
    pass
\end{pylst}

\subsubsection{Декоратор, муштрующий декораторы}
Есть проблема с декорированной функции, например, ее свойство \lstinline{__name__} больше не равно ее действительному имени после декорирования. Следующий декоратор, призванный декорировать другие декораторы, этот досадный недостаток устраняет.
\begin{pylst}{}{}
def well_behaved(decorator):
    def new_decorator(f):
        g = decorator(f)
        g.__name__ = f.__name__
        g.__doc__ = f.__doc__
        g.__dict__.update(f.__dict__)
        return g
    new_decorator.__name__ = decorator.__name__
    new_decorator.__doc__ = decorator.__doc__
    new_decorator.__dict__.update(decorator.__dict__)
    return new_decorator

# Sample Use:

synchronized = well_behaved(synchronized)
\end{pylst}

\section{Метаклассы}
В Python классы --- такие же объекты, как и всё остальное. Их можно передавать в качестве аргументов функциям или рассматривать под микроскопом. Так же как класс определяет поведение объектов, так и метакласс определяет поведение своих классов. Самый распростаненный метакласс в Python --- \lstinline{type}.

\begin{pylst}{}{}
>>> object.__class__
<type 'type'>
>>> type(object)
<type 'type'>
\end{pylst}

Часто метаклассы используются как фабрики. Когда Python создает новый класс (при выполнении оператора \lstinline{class}), он вызывает метакласс. Метакласс в свою очередь может поместить класс в какой-нибудь регистр или же вернуть \emph{совсем} другой класс. Для подавляющего большинства --- если не всех --- встроенных типов метаклассом является метакласс \lstinline{type}.

\begin{pylst}{}{}
# prototype
type(name, bases, dict)
\end{pylst}
где \lstinline{name} --- имя нового класса, \lstinline{bases} --- последовательность базовый классов (может быть пустой), а \lstinline{dict} --- словарь, ключи которого являются именами аттрибутов создаваемого класса, а значения --- значениями этих аттрибутов.

Определение
\begin{pylst}{}{}
class MyClass(BaseClass):
    attribute = 42
\end{pylst}
эквивалентно
\begin{pylst}{}{}
MyClass = type("MyClass", (BaseClass,), { 'attribute' : 42 })
\end{pylst}

Метакласс для класса указывается с помощью поля \lstinline{__metaclass__}. В метаклассе можно (пере)определять любые методы, как и в любом классе, с тем отличием, что методам класса передается экземпляр первым аргументом (отсюда и общеупотребимое \lstinline{self}), а методам метакласса --- класс. Поэтому первый аргумент часто именуется \lstinline{cls}.

\begin{pylst}{}{}
class UselessType(type):
    def __new__(cls, name, bases, dct):
        print "Allocating memory for class", name
        return type.__new__(cls, name, bases, dct)

    def __init__(cls, name, bases, dct):
        print "Init'ing (configuring) class", name
        super(UselessType, cls).__init__(name, bases, dct)

    def __call__(cls, *args, **kwargs):
        print "Calling %s" % cls.__name__
        return super(UselessType, cls).__call__(*args, **kwargs)

    def whoami(cls):
        print cls.__name__

class UselessClass(object):
    __metaclass__ = UselessType

>>> UselessClass.whoami()
UselessClass
>>> UselessClass()
Calling <class '__main__.UselessClass'>
\end{pylst}

Когда выполняется оператор \lstinline{class}, Python вначале выполняет внутреннее содержимое как обычный блок кода. В результате получается пространство имен, представленное словарем. Затем Python ищет метакласс для создаваемого класса в следующей последовательности:
\begin{enumerate}
  \item Если \lstinline{dict['__metaclass__']} существуют, то используется он.
  \item В ином случае, если у класса есть базовые классы, их метакласс используется (сначала проверяется аттрибут \lstinline{__class__}, и если такого нет, то исползуется тип базового класса).
  \item В ином случае, если есть глобальная переменная \lstinline{__metaclass__}, то используется она.
\end{enumerate}

После чего метакласс вызывается с именем вновь создаваемого класса, его базовыми классами и словарем аттрибутов как аргументами.

Полю \lstinline{__metaclass__} можно присваивать не только метаклассы, но и любой вызываемый (callable) объект, который принимает три аргумента.
\begin{pylst}{}{}
def meta(name, bases, dct):
    # setting useless attr
    dct['foo'] = 'bar'
    return type(name, bases, dct)

class Bar(object):
    __metaclass__ = meta

>>> Bar().foo
'bar'
\end{pylst}

Следом идет реализация паттерна Singleton с помощью метакласса:
\begin{pylst}{}{}
class SingletonMetaclass(type):
    instance = None

    def __call__(cls, *args, **kwargs):
        if cls.instance is None:
            cls.instance = super(SingletonMetaclass, cls).__call__(
                *args, **kwargs)
        return cls.instance

class Foo(object):
     __metaclass__ = SingletonMetaclass

>>> Foo() is Foo()
True
\end{pylst}

Как говорится в руководстве по Python, области применения метаклассов безграничны, что, конечно же, является бесстыдным враньём. Вот несколько из общеизвестных применений: logging, проверка интерфейсов, автоматическое делегирование, автоматическое создание свойств класса, прокси, ORM и автоматическая синхронизация/захват ресурса.

\section{Интроспекция}
\label{sec:py-introspection}
В Python можно получить подробную информацию о внутренней структуре любого объекта и среды исполнения. Необходимые для интроспекции данные хранятся в специальных атрибутах. Так, например, получить все пользовательские атрибуты большинства объектов можно из специального атрибута --- словаря (или объекта, предоставляющего dict интерфейс) \lstinline{__dict__}.
\begin{pylst}{}{}
class Class(object): pass

>>> c = Class()
>>> c.attr = 'some'
>>> print c.__dict__
{'attr': 'some'}
>>> print Class.__dict__
{'__dict__': <attribute '__dict__' of 'Class' objects>,
 '__module__': '__main__',
 '__weakref__': <attribute '__weakref__' of 'Class' objects>,
 '__doc__': None}

class BaseA(object): pass
class BaseB(object): pass
class Child(BaseA, BaseB): pass

# let's get some information about object's hierachy
# and method resolution order

>>> c = Child()
>>> c.__class__
<class '__main__.Child'>
>>> c.__class__.__base__
<class '__main__.BaseA'>
>>> c.__class__.__bases__
(<class '__main__.BaseA'>, <class '__main__.BaseB'>)
>>> c.__class__.__mro__
(<class '__main__.Child'>,
 <class '__main__.BaseA'>,
 <class '__main__.BaseB'>,
 <type 'object'>)
\end{pylst}

Для более удобного получения информации о внутреннем устройстве различных объектов был введён модель \lstinline{inspect}.
\begin{pylst}{}{}
import inspect

def f(a, b, c=3):
    pass

>>> inspect.getargspec(f)
ArgSpec(args=['a', 'b', 'c'], varargs=None, keywords=None, defaults=(3,))
\end{pylst}

\begin{thebibliography}{9}

\bibitem{python:pilgrim09}
  M. Pilgrim,
  \emph{Dive into Python 3}.
  Apress,
  2nd ed.,
  2009.

\bibitem{python:officialtutorial}
  \emph{Official Python Tutorial}.
  \url{http://docs.python.org/tutorial/index.html}.

\bibitem{python:officialtutorial}
  \emph{Python Library Reference}.
  \url{http://docs.python.org/library/index.html}.

\bibitem{python:officialtutorial}
  \emph{Python Language Reference}.
  \url{http://docs.python.org/reference/index.html}.

\end{thebibliography}
