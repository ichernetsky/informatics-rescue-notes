\chapter{Язык программирования Python}
\label{ch:python}

\section{Типы и структуры данных и операции над ними}
\label{sec:py-types}
Python --- динамически типизированный язык. Типы принадлежат объектам, не переменным. Переменные лишь связываются с объектами. Python --- строго типизированный язык. Все типы проверяются во время исполнения. Если обнаруживается какое-либо несоответствие типов, то возникает исключение \lstinline{TypeError}.

Все объекты деляется на ссылочные и атомарные. При присваивании атомарных объектов они копируются, в то время как при присваивании ссылочных объекто копируюся только ссылки на них. Ссылочные объекты могут быть изменяемыми или неизменяемыми (mutable и immutable, соответственно).

\subsection{NoneType}
Единственным экземпляром этого типа является \lstinline{None}. Используется для обозначение того факта, что значения нет, например, ``функция ничего не возвращает''. С \lstinline{None} можно использовать операции сравнения и т.п.

\subsection{Булев тип}
\lstinline{False} -- ложное значение булева типа, а \lstinline{True} --- истинное значение.

Любой объект может быть проверен на истинность (как все просто!) для использования в операторах \lstinline{if} и \lstinline{while}. Следующие значения считаются ложными:
\begin{itemize}
  \item \lstinline{None};
  \item \lstinline{False};
  \item нуль любого числового типа;
  \item любая пустая последовательность;
  \item любое пустое отображение (словарь);
  \item экземпляр класса, определенного пользователем, если в классе определены \lstinline{__nonzero__()} или \lstinline{__len()} методы, и они возвращают нуль или \lstinline{False}.
\end{itemize}

Все остальные значения считаются истинными.

\subsubsection{Булевы операции}
\begin{center}
  \begin{tabular}{lp{6cm}}
    \toprule
    Операция & Результат \\
    \midrule
    x or y & Если x истинен, то x, иначе y. \\
    x and y & Если x истинен, то y, иначе x. \\
    not x & Если x истинен, то False, иначе True. \\
    \bottomrule
  \end{tabular}
\end{center}

\subsection{Числовые типы}
Четыре числовых типа: \lstinline{int}, \lstinline{long}, \lstinline{float} и \lstinline{complex}. \lstinline{int} соответсвует \lstinline{long} языка C. Для типа \lstinline{long} языка Python нет ограничений на размер числа. \lstinline{float} языка Python реализован с помощью типа \lstinline{double} языка C. Комплексные числа имеют действительную и мнимую составляющие, каждая из которые представлена \lstinline{double} языка C.

\begin{pylst}{Работа с числовыми типами}{}
>>> x, y = 5, 7
>>> x + y, x / y, y % x
12, 0, 2
>>> x ** y ** 2
17763568394002504646778106689453125L
>>> abs(-x)
5
>>> x, y = 3.5, 23.3
>>> round(x), y / x
4.0, 6.6571428571428575
>>> z = 1.3 + 0.5j
>>> z.imag
0.5
\end{pylst}

Python предоставляет все стандартные побитовые операции над целыми числами: \lstinline{|} (побитовое ИЛИ), \lstinline{^} (побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ), \lstinline{&} (побитовое И), \lstinline{<<} (сдвиг влево), \lstinline{>>} (сдвиг вправо) и \lstinline{~} (побитовое НЕ).

\subsection{Последовательности}
Четыре типа последовательности: \lstinline{string} (строки), \lstinline{unicode} (юникодные строки), \lstinline{list} (списки), \lstinline{tuple} (кортежи).

Все последовательности поддерживают следующие операции:
\begin{center}
  \begin{tabular}{lp{7.5cm}}
    \toprule
    Операция & Результат \\
    \midrule
    \texttt{x in s} & Истина, если какой-либо элемент из \texttt{s} равен \texttt{x} \\
    \texttt{x not in s} & Истина, если ни один элемент из \texttt{s} не равен \texttt{s} \\
    \texttt{s + t} & Сцепка \texttt{s} и \texttt{t} \\
    \texttt{s * n} & Сцепка \texttt{s} с собой \texttt{n} раз \\
    \texttt{s[i]} & Доступ по индексу \texttt{i} \\
    \texttt{s[i:j]} & Срез от \texttt{i} до \texttt{j} \\
    \texttt{s[i:j:k]} & Срез от \texttt{i} до \texttt{j} с шагом \texttt{k} \\
    \texttt{len(s)} & Длина \texttt{s} \\
    \texttt{min(s)} & Минимальный элемент в \texttt{s} \\
    \texttt{max(s)} & Максимальный элемент в \texttt{s} \\
    \bottomrule
  \end{tabular}
\end{center}

\begin{pylst}{Работа с последовательностями}{}
>>> s = 'not so long string '
>>> 'l' in s, 'l' not in s
True, False
>>> s + '...'
'not so long string ...'
>>> s * 2
'not so long string not so long string '
>>> s[10], s[1:6], s[1:9:2]
'g', 'ot so', 'o ol'
>>> len(s)
19
\end{pylst}

\subsubsection{Строки}
Строка в Python --- неизменяемый тип данных. Все операции над последовательностями работают и со строками. Ниже проиллюстрированы часто употребляемые методы:
\begin{pylst}{}{}
>>> s = 'In the very beginning...'
>>> s.count('in')
2
>>> s.startswith('in')
False
>>> ', '.join(['a', 'b', 'c'])
'a, b, c'
>>> s.upper()
'IN THE VERY BEGINNING...'
>>> s.partition(' ')
('In', ' ', 'the very beginning...')
>>> s.split(' ')
['In', 'the', 'very', 'beginning...']
>>> '%s there was actually nothing' % s
'In the very beginning... there was actually nothing'
\end{pylst}

Строковые литералы могут быть трёх видов:
\begin{itemize}
  \item \lstinline{'string'} или \lstinline{"string"}.
  \item \lstinline{'''string'''} или \lstinline{"""string"""}. Может занимать несколько строк.
  \item \lstinline{r'string'} или \lstinline{r"string"}. Специальные символы не надо экранировать.
\end{itemize}

\subsubsection{Списки}
Список в Python --- изменяемая структура данных. Все операции над последовательностями применимы и к спискам. В таблице~\ref{tbl:py-listops} приведены некоторые операции, специфичные для списков.
\begin{table}[h!]
  \begin{center}
    \caption{Дополнительные операции над списками\label{tbl:py-listops}}
    \begin{tabular}{lp{9cm}}
      \toprule
      Операция & Результат \\
      \midrule
      \texttt{s[i] = x} & Замещает элемент на позиции \texttt{i} переменной \texttt{x} \\
      \texttt{s[i:j] = t} & Срез от \texttt{i} до \texttt{j} замещается содержимым итератора \texttt{t} \\
      \texttt{del s[i:j]} & То же, что и \texttt{s[i:j] = []} \\
      \texttt{s[i:j:k] = t} & Элементы \texttt{s[i:j:k]} замещаются содержимым \texttt{t} \\
      \texttt{del s[i:j:k]} & Удаляет элементы \texttt{s[i:j:k]} из списка \\
      \texttt{s.append(x)} & Добавляет элемент в конец списка \\
      \texttt{s.extend(x)} & То же самое, что и \texttt{s[len(s):len(s)] = x} \\
      \texttt{s.insert(i, x)} & То же самое, что и \texttt{s[i:i] = [x]} \\
      \texttt{s.pop([i])} & То же самое, что и \texttt{x = s[i]; del s[i]; return x} \\
      \texttt{s.remove(x)} & То же самое, что и \texttt{del s[s.index(x)]} \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

\subsubsection{Кортежи}
Кортеж --- это неизменяемая последовательность элементов. Нельзя ни удалять элементы из кортежа, ни добавлять, ни изменять. Примеры создания кортежей:
\begin{pylst}{}{}
>>> tuple([1, 2, 3])
(1, 2, 3)
>>> ('a', 'b', 'c')
\end{pylst}

\subsection{Словари}
Словарь --- изменяемая структура данных. Он отображает хешируемые значения на любые объекты.
\begin{pylst}{Примеры создания словаря}{}
dict(one=2, two=3)
dict({'one': 2, 'two': 3})
dict(zip(('one', 'two'), (2, 3)))
dict([['two', 3], ['one', 2]])
\end{pylst}

Некоторые операции над словарём \texttt{d}:
\begin{itemize}
  \item \lstinline{d[key]}. Возвращает объект, ассоциированный с ключом \lstinline{key}. Если такового нет --- \lstinline{KeyError}.
  \item \lstinline{d[key] = value}. Ассоциирует объект \lstinline{value} с ключом \lstinline{key}.
  \item \lstinline{del d[key]}. Удаляет объект, ассоциированный с ключом \lstinline{key}.
  \item \lstinline{key in d}. \lstinline{True}, если \lstinline{d} имеет ключ \lstinline{key}.
  \item \lstinline{key not in d}. Обратно.
  \item \lstinline{iter(d)}. Возвращает итератор по ключам словаря.
  \item \lstinline{clear()}. Удаляет все элементы из словаря.
  \item \lstinline{items()}. Возвращает список пар вида \lstinline{(key, value)}.
  \item \lstinline{iteritems()}. Возвращает итератор по \lstinline{items()}.
  \item \lstinline{iterkeys()}. Возвращает итератор по ключам.
  \item \lstinline{itervalues()}. Возвращает итератор по ассоциированным объектам.
  \item \lstinline{keys()}. Список всех ключей.
  \item \lstinline{values()}. Список ассоциированных объектов.
  \item \lstinline{update([other])}. Обновляет словарь элементами словаря \lstinline{other}.
\end{itemize}

\subsection{Множества}
Очень похожи на математические множества. Поддерживает операции объединения, пересечения, вычитания и различные проверки. Некоторые операции:
\begin{itemize}
  \item \lstinline{isdisjoint(other)}. Возвращает \lstinline{True}, если множества не имею одинаковых элементов.
  \item \lstinline{issubset(other)} или \lstinline{set <= other}. Проверяет, все ли элементы первого множества присутствуют во втором.
  \item \lstinline{issuperset(other)} или \lstinline{set >= other}. По аналогии.
\end{itemize}

\section{Операторы}
\label{sec:py-statements}

\subsubsection{Оператор if}
Общая форма оператора \lstinline{if} выглядит следующим образом:
\begin{pylst}{}{}
if $expression$: $suite$
( elif $expression$: $suite$)*
[ else: $suite$ ]
\end{pylst}

Этот оператор вычисляет последовательно выражения $expression$ до тех пор, пока не будет найдено равное \lstinline{true}. После чего выполняется соответсвующее $suite$. Если все выражения оказались равными \lstinline{false}, то выполняются операторы и выражения из \lstinline{else} ветки. Выполняется не больше одного набора операторов и выражений ($suite$).

\subsubsection{Оператор while}
Общая форма оператора \lstinline{while} выглядит следующим образом:
\begin{pylst}{}{}
while $expression$: $suite_1$
[ else: $suite_2$ ]
\end{pylst}

Выполняет $suite_1$ пока $expression$ истинно. Если в первый раз $expression$ оказалось ложно, выполняется ветка \lstinline{else}, после чего цикл завершается. Оператор \lstinline{break} завершает цикл без выполнения ветки \lstinline{else}. Оператор \lstinline{continue} передает управление на начало цикла.

\subsubsection{Оператор for}
Общая форма оператора \lstinline{for} выглядит следующим образом:
\begin{pylst}{}{}
for $variable$ in $expression$: $suite_1$
[ else: $suite_2$ ]
\end{pylst}

$expression$ вычисляется единожды. Оно должно вычислятся в итерируемый объект. Затем $suite_1$ вычисляется столько раз, сколько объектов в итерируемом объекте, при этом переменной $variable$ присваивается очередной объект. По завершении вычисляется ветка \lstinline{else}.

Оператор \lstinline{break} завершает цикл без выполнения ветки \lstinline{else}. Оператор \lstinline{continue} передает управление на начало цикла или, если больше нет очередного объекта, на ветку \lstinline{else}.

\subsubsection{Оператор try}
Общая форма оператора \lstinline{try} выглядит следующим образом:
\begin{pylst}{}{}
try: suite
( except [expression [ ( as | "," ) target ] ]: suite )+
[ else: suite ]
[ finally: suite ]
\end{pylst}
или
\begin{pylst}{}{}
try: suite
finally: suite
\end{pylst}

Блоки \lstinline{except} определяют обработчики исключительных ситуаций. Если в блоке \lstinline{try} не возникло исключительной ситуации, то ни один из обработчиков не выполняется. В ином случае происходит поиск подходящего обработчика последовательно по блокам \lstinline{except}. Блок \lstinline{except} без выражений $expression$, если таковой присутствует, должен быть последним. При поиске выражения $expression$ вычисляются, и блок выбирается для выполнения, если объект-результат подходит к возникшему исключению, т.е. если объект является классом, который присутствует в списке наследования объекта исключения, или же кортежем, в котором хотя бы один элемент является совместимым с исключением.

Если обработчик не найден, поиск происходит в обрамляющем коде и вверх дальше по стеку, если блок \lstinline{finally} не присутсвует.

Если при выполнении выражений $expression$ возникло исключение, то изначальное исключение отбрасывается, и начинается новый поиск для нового исключения в обрамляющем коде и вверх по стеку.

Если же подходящий блок \lstinline{except} найден, то $target$, если присутствует, присваивается результат вычисления $expression$, и блок исполняется. После чего управление передается, как правило, за пределы оператора \lstinline{try}.

В блоке обработчика можно вызвать \lstinline{sys.exc_info}, которая возвращает кортеж \lstinline{(exc_type, exc_value, exc_traceback)}, где \lstinline{exc_type} --- объект исключения, \lstinline{exc_value} --- параметры, переданные исключению, \lstinline{exc_traceback} --- traceback объект.

Блок \lstinline{else} выполняется в том случае, если управление достигло конца блока \lstinline{try}. Исключения, возникшие в блоке \lstinline{else} не обрабатываются предыдущими ему обработчиками.

Блок \lstinline{finally} выполняется всегда, где бы исключительная ситуация не возникла: внутри блок \lstinline{try}, \lstinline{except} или же \lstinline{else}.

\section{Функции}
Ниже приведено тривиальное определение функции:
\begin{pylst}{}{}
def add(a, b):
    return a + b
\end{pylst}

Как видно из примера, определение функции начинается с оператора \lstinline{def}, за которым идет имя функции, а следом --- аргументы, заключенные в круглые скобки. Возврат значения происходит посредством оператора \lstinline{return}. Если возврат из функции происходит из-за того, что управление достигло конца функции, то возвращаемое значение равно \lstinline{None}. Определение функции связывает её имя с объектом функции (обёрткой над действительно исполняемым кодом) в текущем пространсве имён. Объект функции содержит ссылку на текущее глобальное пространство имён, которое будет использоваться при вызове функции.

Определение функции может быть обёрнуто декораторами. Декораторы вычисляются во время определения функции в том же самом контексте, где находится определение функции.

Функция может иметь именованные аргументы, которые имеют значение по умолчанию. При вызове функции не обязательно передавать именованные аргументы, если устраивает значение по умолчанию. В определении функции после именованного аргумента могут идти только именованные аргументы.

Значения по умолчанию для именованных аргументов вычисляются один раз при выполнении определения функции. После чего при любом вызове используется один и тот же объект. Если значение по умолчанию --- изменяемый (mutable) объект, то можно наткнуться на неприятности, что и проиллюстрировано ниже:
\begin{pylst}{}{}
def append(list=[]):
    list.append('a')
    return list

>>> append()
['a']
>>> append()
['a', 'a']
>>> append()
['a', 'a', 'a']
\end{pylst}

Ниже представлена версия, лишенная приведенного недостатка:
\begin{pylst}{}{}
def append(list=None):
    if list is None:
        list = []
    list.append('a')
    return list

>>> append()
['a']
>>> append()
['a']
\end{pylst}

Если в определении функции присутствует форма \lstinline{*identifier}, то \lstinline{identifier} будет равен кортежу, который содержит все аргументы, которые не были явно проименованы. Если же присутствует форма \lstinline{**identifier}, то \lstinline{identifier} будет словарём, который отображет имена аргументов на их значения.

При вызове если происходит ошибка разбора аргументов, их нехватка или избыток и так далее, то порождается исключение \lstinline{TypeError}. Если при вызове присутствует форма \lstinline{*identifier}, то \lstinline{identifier} должен вычисляться в последовательность, элементы которой будут считаться дополнительными позиционными аргументами. Если же при вызове присутсвует форма \lstinline{**identifier}, то \lstinline{identifier} должен вычисляться в словарь, ключи которого будут использоваться в качестве именованных аргументов, а значения --- в качестве значений этих аргументов.

Обе формы могут присутствовать одновременно как при определении функции, так и при вызове.

\subsubsection{Анонимные функции}
\emph{Анонимные (безымянные) функции} в Python --- объекты функций, которые не имеют имени ни в каком пространстве имён после \emph{непосредственного} определения. Они определяются с помощью лямбда-выражений:
\begin{pylst}{}{}
lambda [ $parameters$ ]: $expression$
\end{pylst}

В отличии от обычного определения функции лямбда-выражение не может содержать операторов (statements).
\begin{pylst}{}{}
>>> map(lambda i: i + 1, [1, 2, 3])
[2, 3, 4]
\end{pylst}

\section{Функциональное программирование}
В Python возможно использовать некоторые идеи и концепции функционального программирования.

\subsection{Функции высшего порядка}
Функция высшего порядка --- функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата.
\begin{pylst}{}{}
def f(x):
    return x + 3
 
def g(function, x):
    return function(x) * function(x)
 
>>> g(f, 7)
100
\end{pylst}

Ниже представлены наиболее общеупотребимые функции высшего порядка, определенные в Python.

\subsubsection{Функция map}
\lstinline{map} --- функция высшего порядка, которая применяет переданную функция к элементам одной или нескольких последовательностей. Количество аргументов переданной функции должно быть равно количеству переданных последовательностей. Если последовательности не одинаковой длины, то вместо недостающих элементов используется \lstinline{None}. Длина результирующего списка равна длине наибольшего списка. Если вместо функции передается \lstinline{None}, тогда элементы последовательностей никак не преобразуются, а используются как есть. Если последовательностей --- несколько, то результатом будет список кортежей.
\begin{pylst}{}{}
map(function, sequence[, sequence, ...]) -> list

>>> map(lambda x, y: x + y, [1, 2, 3], [2, 3, 4])
[3, 5, 7]
>>> map(None, [1, 2], [3])
[(1, 3), (2, None)]
\end{pylst}

\subsubsection{Функция filter}
\lstinline{filter} --- функция высшего порядка, которая конструирует итоговый список из элементов переданной последовательности, если конкретный элемент удовлетворяет функции-предикату. Если в качестве последовательности передается строка или кортеж, то и тип результата будет строка или кортеж, соответственно. Если функция равна \lstinline{None}, то возвращаются элементы, которые истинны.
\begin{pylst}{}{}
filter(function or None, sequence) -> list, tuple, or string

>>> filter(lambda x: x % 2, [1, 2, 3, 4, 5])
[1, 3, 5]
\end{pylst}

\subsubsection{Функция reduce}
\lstinline{reduce} --- функция высшего порядка, которая делает свёртку последовательности, в результате чего получается, как правило, значение типа элемента последовательности. Функция свёртки обычно принимает три аргумента: комбинирующую функцию \lstinline{function}, начальное значение \lstinline{initial} и последовательность \lstinline{sequence}.
\begin{pylst}{}{}
reduce(function, sequence[, initial]) -> value
\end{pylst}

$4!$ можно вычислить следующим образом, используя функцию \lstinline{reduce}:
\begin{pylst}{}{}
>>> reduce(lambda res, x: res * x, range(2, 4 + 1), 1)
24
\end{pylst}

Вычисление происходит следующим образом:
\begin{center}
  \begin{tikzpicture}[level/.style={sibling distance=50mm/#1}]
    \node [circle, draw] {$*$}
      child { node [circle, draw] {$*$}
        child { node [circle, draw] {$*$} 
          child { node [circle, draw] {$1$} }
          child { node [circle, draw] {$2$} } }
        child { node [circle, draw] {$3$} } }
      child { node [circle, draw] {$4$} };
  \end{tikzpicture}
\end{center}

Другая иллюстрация:
\begin{pylst}{}{}
(((1 * 2) * 3) * 4)
\end{pylst}

\subsection{Рекурсия}
Хоть в Python и существует рекурсия, но в наиболее популярной реализации этого языка --- CPython --- она не православна, так как там нет оптимизации хвостовых вызовов (tail call optimization, TCO).

Хвостовая рекурсия --- специальный случай рекурсии, при котором последней операцией, выполняемой рекурсивной функцией, является вызов самой себя. Подобный вид рекурсии примечателен тем, что может быть легко и автоматически заменён на итерацию, что и делают многие оптимизирующие компиляторы. Подобные рассуждения справедливы и для взаимно рекурсивных функций, хоть TCO для них в компиляторах встречается еще реже.

\begin{pylst}{}{}
def infinite():
    infinite()

# shortly somewhere in a far far away galaxy
>>> infinite()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
...
RuntimeError: maximum recursion depth exceeded
\end{pylst}

Получить и установить максимальное возможное количество рекурсивные вызовов можно с помощью функцией \lstinline{sys.getrecursionlimit} и \lstinline{sys.setrecursionlimit(limit)}.

\subsection{Замыкания}
Замыкание --- первоклассная функция со свободными переменными, которые связаны с определенными значениями в своем лексическом окружении. Свободная переменная --- переменная, которая встречается в теле функции, но которая не является параметром этой функции или локальной переменной.
\begin{pylst}{}{}
def make_adder(y):
    def add(x):
        return x + y
    return add

>>> add5 = make_adder(5)
>>> add5(5)
10
>>> add5(7)
12
\end{pylst}

Замыкание \lstinline{add} создается при каждом вызове функции \lstinline{make_adder}. Замыкании \lstinline{add} переменная \lstinline{y} является свободной переменной.

Замыкания в Python также не доведены до логического конца, хоть в версиях $>=3.0$ уже такая претензия есть. В версии 3.0 введен оператор \lstinline{nonlocal}, суть которого видна из следующего примера:
\begin{pylst}{}{}
def make_counter():
    count = 0
    def get():
        return count
    def inc():
        count += 1

    return get, inc

>>> get, inc = make_counter()
>>> get()
>>> 0
>>> inc()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/tmp/py9637pml", line 11, in inc
UnboundLocalError: local variable 'count' referenced before assignment

def make_counter():
    count = 0
    def get():
        nonlocal count
        return count
    def inc():
        count += 1

    return get, inc

>>> get, inc = make_counter()
>>> get()
>>> 0
>>> inc()
>>> get()
1
\end{pylst}

\subsection{Частичное применение функции}
Частичное применение функции --- это преобразование функции от $n$ аргументов к функции от $n - m$ аргументов ($m < n$), в которой $m$ аргументов привязаны к определенным значениям. То есть некоторые аргументы изначальной функции фиксируются.

Эта возможность предоставляется стандартной библиотекой Python:
\begin{pylst}{}{}
from functools import partial
basetwo = partial(int, base=2)

>>> basetwo('10010')
18
\end{pylst}

\section{Модули}
\label{sec:py-modules}
Модуль представляет собой функционально законченный фрагмент программы, оформленный, как правило, в виде отдельного файла с исходным кодом, предназначенный для использования в других программах. Модули позволяют разбивать сложные задачи на более мелкие.

Модуль импортируются с помощью оператора \lstinline{import}. Модуль имеет пространство имён, представляющее собой словарь (это тот самый словарь, на который ссылает \lstinline{func_global} аттрибут любой определенной функции в этом модуле). Чтение аттрибута модуля \lstinline{m.x} эквивалентно поиску по ключу в словаре \lstinline{m.__dict__['x']}.

Каждый модуль имеет несколько специальных аттрибутов:
\begin{itemize}
  \item \lstinline{__name__} --- имя модуля;
  \item \lstinline{__doc__} --- строка документации модуля или \lstinline{None}, если её нет;
  \item \lstinline{__file__} --- путь к файлу, если таковой существует, из которого модуль был загружен.
\end{itemize}

Оператор \lstinline{import} имеет две формы:
\begin{pylst}{}{}
import $module$
from $module$ import ( $something$ [ as $someothername$ ] )+
\end{pylst}

Процесс импорта состоит из двух шагов:
\begin{enumerate}
  \item Поиск модуля и его инициализация, если необходима.
  \item Определение локальных имен в той области видимости, где находится сам оператор \lstinline{import}.
\end{enumerate}

Первая форма оператора делает как первый шаг, так и второй. Вторая же форма оператора выполняет первый шаг единожды, после чего повторяет второй шаг для всех импортируемых имён.

Модули и пакеты могут образовывать иерархию. Модули не могут содержать ни другие модули, ни другие пакеты. В то время как пакет может содержать как другие модули, так и другие пакеты. Если эту структуру отображать на файловую систему, то модулям сответствуют файлы, а пакетам --- директории.
\begin{plainlst}{}{}
edu
|
`__init__.py
 informatics
 |
 `__init__.py
  ai.py
\end{plainlst}

Пусть в \texttt{ai.py} определен класс \lstinline{NotSoIntelligent}. Тогда все следующие операции импорта корректны:
\begin{pylst}{}{}
import edu
from edu import informatics
from informatics import ai as infoai
from infoai import *

NotSoIntelligent()
\end{pylst}

Если при импортировании модуль не может быть найдет, то возникает исключение \lstinline{ImportError}. При использовании формы импорта модуля со звёздочкой в текущее пространство импортируются все публичные имена. Их список определяется в переменной \lstinline{__all__} модуля или же конструируется из всех глобальных имён импортируемого модуля.
\begin{pylst}{A.py}{}
__all__ = ['one']

one = 1
two = 2
\end{pylst}

\begin{pylst}{}{}
>>> from A import *
>>> one
1
>>> two
NameError: name 'two' is not defined
\end{pylst}

Импорт может быть относительным. Точка перед модулем значит, что путь до модуля нужно искать от того модуля, где происходит импорт. Если две точки, то начинать надо с уровня выше. И так далее. Например, если импорт \lstinline{from . import mod} происходит из модуля в пакете \lstinline{pkg}, то импортирован будет модуль \lstinline{pkg.mod}. Если же импорт \lstinline{from ..subpkg2 import mod} --- из пакета \lstinline{pkg.subpkg1}, импортирован модуль \lstinline{pkg.subpkg2.mod}.

Модули можно подгружать динамически, используя встроенную функцию \lstinline{__import__}.

\section{Декораторы}
\label{sec:py-decorators}
Декоратор --- объект, который можно вызвать с одним аргументом. Он волен делать с переданным аргументом всё, что угодно, лишь бы программа оставалась корректной.
\begin{pylst}{}{}
def debug(func):
    def wrapped(*args, **kwargs):
        print "%s called with: %s, %s" % (func.__name__, args, kwargs)
        ret = func(*args, **kwargs)
        print "%s returned: %s" % (func.__name__, ret)
        return ret
    return wrapped

@debug
def inc(i):
    return i + 1
\end{pylst}

@-синтаксис введен всего лишь для удобства. Вышеопределенное декорирование эквивалентно следующему:
\begin{pylst}{}{}
def inc(i):
    return i + 1

inc = debug(inc)
\end{pylst}

Пример вызова декорированной функции \lstinline{inc}:
\begin{pylst}{}{}
>>> inc(1)
inc called with: (1,), {}
inc returned: 2
\end{pylst}

\subsection{Примеры декораторов}
\subsubsection{Псевдокаррирование}
Каррирование или карринг (англ. currying) в информатике --- преобразование функции от пары аргументов в функцию, берущую свои аргументы по одному.
\begin{pylst}{}{}
class curried(object):
    def __init__(self, func, *a):
        self.func = func
        self.args = a

    def __call__(self, *a):
        args = self.args + a
        if len(args) < self.func.__code__.co_argcount:
            return curried(self.func, *args)
        else:
            return self.func(*args)

@curried
def add(a, b):
    return a + b

add1 = add(1)
print add1(2)
\end{pylst}

\subsubsection{Синхронизация}
Декорированная функция пытается захватить взаимное исключение перед тем, как исполняться.

\begin{pylst}{}{}
def synchronized(lock):
    def wrap(f):
        def sync(*args, **kwargs):
            lock.acquire()
            try:
                return f(*args, **kwargs)
            finally:
                lock.release()
        return sync
    return wrap

# Example usage:

from threading import Lock
lock = Lock()

@synchronized(lock)
def critical_one(*args):
    pass

@synchronized(lock)
def critical_two(*args):
    pass
\end{pylst}

\subsubsection{Декоратор, муштрующий декораторы}
Есть проблема с декорированной функции, например, ее свойство \lstinline{__name__} больше не равно ее действительному имени после декорирования. Следующий декоратор, призванный декорировать другие декораторы, этот досадный недостаток устраняет.
\begin{pylst}{}{}
def well_behaved(decorator):
    def new_decorator(f):
        g = decorator(f)
        g.__name__ = f.__name__
        g.__doc__ = f.__doc__
        g.__dict__.update(f.__dict__)
        return g
    new_decorator.__name__ = decorator.__name__
    new_decorator.__doc__ = decorator.__doc__
    new_decorator.__dict__.update(decorator.__dict__)
    return new_decorator

# Sample Use:

synchronized = well_behaved(synchronized)
\end{pylst}

\section{Метаклассы}
В Python классы --- такие же объекты, как и всё остальное. Их можно передавать в качестве аргументов функциям или рассматривать под микроскопом. Так же как класс определяет поведение объектов, так и метакласс определяет поведение своих классов. Самый распростаненный метакласс в Python --- \lstinline{type}.

\begin{pylst}{}{}
>>> object.__class__
<type 'type'>
>>> type(object)
<type 'type'>
\end{pylst}

Часто метаклассы используются как фабрики. Когда Python создает новый класс (при выполнении оператора \lstinline{class}), он вызывает метакласс. Метакласс в свою очередь может поместить класс в какой-нибудь регистр или же вернуть \emph{совсем} другой класс. Для подавляющего большинства --- если не всех --- встроенных типов метаклассом является метакласс \lstinline{type}.

\begin{pylst}{}{}
# prototype
type(name, bases, dict)
\end{pylst}
где \lstinline{name} --- имя нового класса, \lstinline{bases} --- последовательность базовый классов (может быть пустой), а \lstinline{dict} --- словарь, ключи которого являются именами аттрибутов создаваемого класса, а значения --- значениями этих аттрибутов.

Определение
\begin{pylst}{}{}
class MyClass(BaseClass):
    attribute = 42
\end{pylst}
эквивалентно
\begin{pylst}{}{}
MyClass = type("MyClass", (BaseClass,), { 'attribute' : 42 })
\end{pylst}

Метакласс для класса указывается с помощью поля \lstinline{__metaclass__}. В метаклассе можно (пере)определять любые методы, как и в любом классе, с тем отличием, что методам класса передается экземпляр первым аргументом (отсюда и общеупотребимое \lstinline{self}), а методам метакласса --- класс. Поэтому первый аргумент часто именуется \lstinline{cls}.

\begin{pylst}{}{}
class UselessType(type):
    def __new__(cls, name, bases, dct):
        print "Allocating memory for class", name
        return type.__new__(cls, name, bases, dct)

    def __init__(cls, name, bases, dct):
        print "Init'ing (configuring) class", name
        super(UselessType, cls).__init__(name, bases, dct)

    def __call__(cls, *args, **kwargs):
        print "Calling %s" % cls.__name__
        return super(UselessType, cls).__call__(*args, **kwargs)

    def whoami(cls):
        print cls.__name__

class UselessClass(object):
    __metaclass__ = UselessType

>>> UselessClass.whoami()
UselessClass
>>> UselessClass()
Calling <class '__main__.UselessClass'>
\end{pylst}

Когда выполняется оператор \lstinline{class}, Python вначале выполняет внутреннее содержимое как обычный блок кода. В результате получается пространство имен, представленное словарем. Затем Python ищет метакласс для создаваемого класса в следующей последовательности:
\begin{enumerate}
  \item Если \lstinline{dict['__metaclass__']} существуют, то используется он.
  \item В ином случае, если у класса есть базовые классы, их метакласс используется (сначала проверяется аттрибут \lstinline{__class__}, и если такого нет, то исползуется тип базового класса).
  \item В ином случае, если есть глобальная переменная \lstinline{__metaclass__}, то используется она.
\end{enumerate}

После чего метакласс вызывается с именем вновь создаваемого класса, его базовыми классами и словарем аттрибутов как аргументами.

Полю \lstinline{__metaclass__} можно присваивать не только метаклассы, но и любой вызываемый (callable) объект, который принимает три аргумента.
\begin{pylst}{}{}
def meta(name, bases, dct):
    # setting useless attr
    dct['foo'] = 'bar'
    return type(name, bases, dct)

class Bar(object):
    __metaclass__ = meta

>>> Bar().foo
'bar'
\end{pylst}

Следом идет реализация паттерна Singleton с помощью метакласса:
\begin{pylst}{}{}
class SingletonMetaclass(type):
    instance = None

    def __call__(cls, *args, **kwargs):
        if cls.instance is None:
            cls.instance = super(SingletonMetaclass, cls).__call__(
                *args, **kwargs)
        return cls.instance

class Foo(object):
     __metaclass__ = SingletonMetaclass

>>> Foo() is Foo()
True
\end{pylst}

Как говорится в руководстве по Python, области применения метаклассов безграничны, что, конечно же, является бесстыдным враньём. Вот несколько из общеизвестных применений: logging, проверка интерфейсов, автоматическое делегирование, автоматическое создание свойств класса, прокси, ORM и автоматическая синхронизация/захват ресурса.

\section{Интроспекция}
\label{sec:py-introspection}
В Python можно получить подробную информацию о внутренней структуре любого объекта и среды исполнения. Необходимые для интроспекции данные хранятся в специальных атрибутах. Так, например, получить все пользовательские атрибуты большинства объектов можно из специального атрибута --- словаря (или объекта, предоставляющего dict интерфейс) \lstinline{__dict__}.
\begin{pylst}{}{}
class Class(object): pass

>>> c = Class()
>>> c.attr = 'some'
>>> print c.__dict__
{'attr': 'some'}
>>> print Class.__dict__
{'__dict__': <attribute '__dict__' of 'Class' objects>,
 '__module__': '__main__',
 '__weakref__': <attribute '__weakref__' of 'Class' objects>,
 '__doc__': None}

class BaseA(object): pass
class BaseB(object): pass
class Child(BaseA, BaseB): pass

# let's get some information about object's hierachy
# and method resolution order

>>> c = Child()
>>> c.__class__
<class '__main__.Child'>
>>> c.__class__.__base__
<class '__main__.BaseA'>
>>> c.__class__.__bases__
(<class '__main__.BaseA'>, <class '__main__.BaseB'>)
>>> c.__class__.__mro__
(<class '__main__.Child'>,
 <class '__main__.BaseA'>,
 <class '__main__.BaseB'>,
 <type 'object'>)
\end{pylst}

Для более удобного получения информации о внутреннем устройстве различных объектов был введён модель \lstinline{inspect}.
\begin{pylst}{}{}
import inspect

def f(a, b, c=3):
    pass

>>> inspect.getargspec(f)
ArgSpec(args=['a', 'b', 'c'], varargs=None, keywords=None, defaults=(3,))
\end{pylst}
