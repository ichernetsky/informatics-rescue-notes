\chapter{Язык программирования Python}
\label{ch:python}

Чтобы попробовать \emph{Python}, достаточно запустить REPL (от \emph{Read, Eval, Print, Loop}), введя в командной оболочке \lstinline{python} (а ещё лучше \lstinline{ipython}). Запустится интерпретатор \emph{Python}, ожидающий ввода. Можно вводить конструкции языка — и немедленно получать результат исполнения.

\begin{plainlst}{Пример минимальной сессии}{}
% ipython
Python 2.7.2 (default, Jun 29 2011, 15:07:32)
Type "copyright", "credits" or "license" for more information.

IPython 0.10.2 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object'. ?object also works, ?? prints more.

In [1]: 2 ** 32
Out[1]: 4294967296

In [2]: dir(None)
Out[2]:
['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__',
 '__hash__', '__init__', '__new__', '__reduce__', '__reduce_ex__',
 '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']

In [3]: map?
Type:		builtin_function_or_method
Base Class:	<type 'builtin_function_or_method'>
String Form:	<built-in function map>
Namespace:	Python builtin
Docstring:
    map(function, sequence[, sequence, ...]) -> list

    Return a list of the results of applying the function to the items of
    the argument sequence(s).  If more than one sequence is given, the
    function is called with an argument list consisting of the corresponding
    item of each sequence, substituting None for missing values when not all
    sequences have the same length.  If the function is None, return a list
    of the items of the sequence (or a list of tuples if more than one
    sequence).
\end{plainlst}

\section{Типы и структуры данных и операции над ними}
\label{sec:py-types}

\emph{Python} — динамически типизированный язык. Типы принадлежат объектам, не переменным. Переменные лишь связываются с объектами, то есть они всего лишь имена. \emph{Python} — строго типизированный язык. Все типы проверяются во время исполнения. Если обнаруживается какое-либо несоответствие типов, то возникает исключение, как правило, \lstinline{TypeError} или \lstinline{AttributeError}.

Все объекты деляется на \emph{ссылочные} и \emph{атомарные}. При присваивании атомарных объектов они копируются, в то время как при присваивании ссылочных объектов копируются только ссылки на них. Ссылочные объекты могут быть \emph{изменяемыми} или \emph{неизменяемыми} (\emph{mutable} и \emph{immutable} соответственно).

\subsection{NoneType}
Единственным экземпляром этого типа является константа \lstinline{None}. Используется для обозначение того факта, что значения нет, например, «функция ничего не возвращает». С \lstinline{None} можно использовать операции сравнения\footnote{В \emph{Python} 2.x можно использовать и операторы отношения порядка, в 3.x — только операторы равенства.} и т.п.

\subsection{Булев тип}
\lstinline{False} — ложное значение булева типа, а \lstinline{True} — истинное значение.

Любой объект может быть проверен на истинность (как все просто!) для использования в операторах \lstinline{if} и \lstinline{while}. Следующие значения считаются ложными:
\begin{itemize}
  \item \lstinline{None};
  \item \lstinline{False};
  \item нуль любого числового типа;
  \item любая пустая последовательность;
  \item любое пустое отображение (словарь);
  \item экземпляр класса, определенного пользователем, если в классе определены \lstinline{__nonzero__()} или \lstinline{__len__()} методы, и они возвращают нуль или \lstinline{False} соответственно.
\end{itemize}

\begin{pylst}{}{}
class Zero(object):
    def __nonzero__(self):
        return False

class ZeroLen(object):
    def __len__(self):
        return 0

>>> bool(Zero())
False

>>> bool(ZeroLen())
False

>>> bool({})
False

>>> bool([])
False
\end{pylst}

Все остальные значения считаются истинными.

\subsubsection{Булевы операции}

\lstinline{x or y}. Если \lstinline{x} истинен, то результат выражения — \lstinline{x}, иначе — \lstinline{y}. Правый аргумент вычисляется, только если левый — ложен.

\begin{pylst}{}{}
>>> 0 or 2 or 1 or 0
2
\end{pylst}

\lstinline{x and y}. Если \lstinline{x} — ложен, то он вычисляется и является результатом, и в этом случае \lstinline{y} не вычисляется. Иначе вычисляется \lstinline{y}, и результат вычисления становится значением всего выражения.

\begin{pylst}{}{}
>>> 1 and 2 and 0 and 3
0
\end{pylst}

\lstinline{not x}. Отрицание \lstinline{x}. Если он истинен, то значение выражения — \lstinline{False}, и наоборот.

\subsection{Числовые типы}
В \emph{Python} есть четыре числовых типа: \lstinline{int}, \lstinline{long}\footnote{В \emph{Python} 3.x этот тип убран вообще, но зато числа типа \lstinline{int} теперь не имеют ограничений на размер.}, \lstinline{float} и \lstinline{complex}. \lstinline{int} соответсвует \lstinline{long} языка \emph{C}. Для типа \lstinline{long} языка \emph{Python} нет ограничений на размер числа. \lstinline{float} языка \emph{Python} реализован с помощью типа \lstinline{double} языка \emph{C}. Комплексные числа имеют действительную и мнимую составляющие, каждая из которых представлена \lstinline{double} языка \emph{C}.

Комплексные числа записываются как \lstinline{x + yj}, где \lstinline{x} и \lstinline{y} — целый числа или числа с плавающей точкой.

\begin{pylst}{}{}
>>> z = 1.3 + 0.5j
>>> z
(1.3+0.5j)
>>> z.real
1.3
>>> z.imag
0.5
>>> z.conjugate()
(1.3-0.5j)
\end{pylst}

\subsubsection{Преобразование числовых типов}

Создавать числа и преобразовывать друг в друга можно, используя типы \lstinline{int}, \lstinline{long}, \lstinline{float} и \lstinline{complex}.

\begin{pylst}{}{}
>>> int(2)
2
>>> int(2.3)
2
>>> float(2)
2.0
>>> complex(2, 4)
(2+4j)
\end{pylst}

\subsubsection{Числовые операторы и не только}

Унарные операторы: \lstinline{+x, -x, ~x}. Унарный оператор \lstinline{+} не изменяет своего аргумента. Оператор \lstinline{-} возвращает противоположное значение относительно операции сложения. Оператор \lstinline{~} побитово инвертирует свой аргумент, эквивалентен выражению \lstinline{-(x + 1)}.

\begin{pylst}{}{}
>>> x = 111
>>> +x
111
>>> -x
-111
>>> bin(x)
'0b1101111'
>>> bin(~x)
'-0b1110000'
\end{pylst}

Бинарные арифметические операторы: \lstinline{x + y, x - y, x * y, x // y, x / y, x % y, x ** y}. Перед выполнением всех операций аргументы приводятся к общему типу. Операторы \lstinline{/} и \lstinline{//} возвращают частное деления. Если оба аргумента целочисленны, то результатом оператора \lstinline{/} будет целое число\footnote{В \emph{Python} 3.x это не так. Там оператор \lstinline{/} возвращает значение типа \lstinline{float}. Для того, чтобы включить такое поведение и в \emph{Python} 2.x, следует в начало файла вставить \lstinline{from __future__ import division}. См. \emph{PEP 238}: \url{http://www.python.org/dev/peps/pep-0238/}}. Оператор \lstinline{//} определён как $\lfloor \frac{x}{y} \rfloor$. Оператор \lstinline{%} возвращает остаток от деления; он также определён и для чисел с плавающей точкой. Оператор \lstinline{**} возводит \lstinline{x} в степень \lstinline{y}.

Для всех операторов с целочисленным аргументами определено следующее поведение: если результату вычисления недостаточно типа \lstinline{int}, то возвращается число типа \lstinline{long}.

\begin{pylst}{}{}
>>> 7 + 5
12
>>> 7 - 5
2
>>> 7 * 5
35
>>> 7 / 5
1
>>> 7.0 / 5
1.4
>>> 7.0 // 5
1.0
>>> 7 % 5
2
>>> 3.14 % 0.7
0.3400000000000003
>>> 2**100
1267650600228229401496703205376L
\end{pylst}

Бинарные побитовые операторы: \lstinline{x & y, x ^ y, x | y}. Перед вычислением аргументы преобразуются к общему типу. Типом аргумента может быть \lstinline{int} или \lstinline{long}. Оператор \lstinline{&} — побитовое И (AND); оператор \lstinline{^} — побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR); оператор \lstinline{|} — побитовое ИЛИ (OR).

\begin{pylst}{}{}
>>> hex(0xc4 & 0x72)
'0x40'
>>> hex(0xc4 ^ 0x72)
'0xb6'
>>> hex(0xc4 | 0x72)
'0xf6'
\end{pylst}

Операторы сдвига: \lstinline{x << y} и \lstinline{x >> y}. Перед вычислением аргументы преобразуются к общему типу. Типом аргумента может быть \lstinline{int} или \lstinline{long}. Операторы делают сдвиг \lstinline{x} на \lstinline{y} бит влево и вправо соответственно. Оператор \lstinline{<<} определён как \lstinline{x * pow(2, y)}, а \lstinline{>>} — как \lstinline{x / pow(2, y)}.

\begin{pylst}{}{}
>>> 1 << 5 == 1 * pow(2, 5)
True
>>> 256 >> 5 == 256 / pow(2, 5)
True
\end{pylst}

\subsubsection{Перегрузка операторов}

В \emph{Python} все операторы можно перегружать\footnote{По ссылке \url{http://docs.python.org/reference/datamodel.html\#special-method-names} перечислены все \emph{специальные методы}, часть которых используется для перегрузки операторов.}. Для небольшой иллюстрации напишем класс, который представляет нейтральный элемент относительно операций сложения и умножения.

\begin{pylst}{}{}
class IdentityElement(object):
    def __repr__(self):
        return "IdentityElement"
    def __str__(self):
        return self.__repr__()
    def __add__(self, other):
        return other
    def __radd__(self, other):
        return other
    def __mul__(self, other):
        return other
    def __rmul__(self, other):
        return other

>>> identity = IdentityElement()
>>> identity
IdentityElement
>>> 5 + identity
5
>>> identity * 5
5
\end{pylst}

\subsubsection{Числовые функции и модули}

В стандартной библиотеке \emph{Python} есть как модули, предоставляющие математические функции и константы, так и модули, предоставляющие реализации новых числовых типов.

Так модуль \lstinline{math} предоставляет различные функции округлений чисел с плавающей точкой, степенные, логарифмические, тригонометрические, гиперболические функции и т.д. Аналогичную функциональность, но уже для комплексных чисел, предоставляет модуль \lstinline{cmath}.

Модуль \lstinline{random} содержит функции для генерации случайных чисел различных распределений и функции, которые выбирают один или несколько случайных элементов из последовательности, перемешивают последовательность и т. д.

\begin{pylst}{}{}
>>> random.random()
0.37444887175646646
>>> random.uniform(1, 10)
1.1800146073117523
>>> random.randint(1, 10)
7
>>> random.choice('abcdefghij')
'c'

>>> items = [1, 2, 3, 4, 5, 6, 7]
>>> random.shuffle(items)
>>> items
[7, 3, 2, 5, 6, 4, 1]

>>> random.sample([1, 2, 3, 4, 5],  3)
[4, 1, 5]
\end{pylst}

Модуль \lstinline{fraction} предоставляет тип рациональных чисел с поддержкой всех арифметических операцией.

\begin{pylst}{}{}
>>> from fractions import Fraction
>>> x = Fraction(16, -10)
>>> x
Fraction(-8, 5)
>>> y = Fraction('3/7')
>>> y
Fraction(3, 7)
>>> z = Fraction(2.25)
>>> z
Fraction(9, 4)
>>> x + y + z
Fraction(151, 140)
>>> from decimal import Decimal
>>> Fraction(Decimal('1.1'))
Fraction(11, 10)
\end{pylst}

Модуль \lstinline{decimal} реализует поддержку \emph{чисел с десятичной плавающей точкой (decimal floating point numbers)}. Вот некоторые преимущества в сравнении с числами с двоичной плавающей точкой:
\begin{itemize}
  \item Более удобна для восприятия людьми.
  \item Десятичные числа могут быть представлены точно, в то время как $1.2$ не может быть представлена точно, используя числа с двоичной плавающей точкой.
\begin{pylst}{}{}
>>> 1.1 + 2.2
3.3000000000000003
\end{pylst}
  \item Эта точность сохраняется и при использовании арифтемических операций. Так $0.1 + 0.1 + 0.1 - 0.3$ будет равно $0$, в то время как:
\begin{pylst}{}{}
>>> 0.1 + 0.1 + 0.1 - 0.3
5.551115123125783e-17
\end{pylst}
  \item Можно изменять \emph{точность (precision)}.
\end{itemize}

Небольшая иллюстрация использования модуля \lstinline{decimal}:

\begin{pylst}{}{}
>>> from decimal import *
>>> D = Decimal
>>> D('1.1') + D('2.2')
Decimal('3.3')
>>> D('0.1') + D('0.1') + D('0.1') - D('0.3')
Decimal('0.0')

>>> D(2) ** D('0.5')
Decimal('1.414213562373095048801688724')
>>> D(1).exp()
Decimal('2.718281828459045235360287471')

>>> getcontext().prec = 6
>>> D('3.1415926535') + D('2.7182818285')
Decimal('5.85987')
>>> getcontext().rounding = ROUND_UP
>>> D('3.1415926535') + D('2.7182818285')
Decimal('5.85988')
\end{pylst}

\subsection{Последовательности}
В \emph{Python} семь типов последовательностей: \lstinline{str} (\emph{строки}), \lstinline{unicode} (\emph{юникодные строки}), \lstinline{list} (\emph{списки}), \lstinline{tuple} (\emph{кортежи}), \lstinline{bytearray}, \lstinline{buffer} и \lstinline{xrange}.\footnote{Последние три типа особо не будут рассматриваться, так как они не находят столь широкого применения, как первые четыре типа.}

Строковые литералы записываются в одинарных либо двойных кавычках: \lstinline{'foo'}, \lstinline{"foo"}. Списки записываются в квадратных скобках, посреди которых элементы разделяются запятыми: \lstinline{[1, 2, 3]}. Форма записи кортежей — элементы, разделённые запятыми; также могут присутствовать необязательные круглые скобки: \lstinline{(1, 2, 3)} и \lstinline{1, 2, 3} — эквивалентные записи. Для создания кортежа из одного элемента необходимо наличие запятой после этого элемента: \lstinline{(1,)}.

В \emph{Python} нет специального синтаксиса для создания последовательностей \lstinline{bytearray}, \lstinline{buffer} и \lstinline{xrange}. Они создаются встроенными функциями \lstinline{bytearray()}, \lstinline{buffer()} и \lstinline{xrange()} соответственно.

Отличительная черта \lstinline{xrange} — использование константного объёма памяти, какой бы длинной представляемая последовательноть не была. Объекты \lstinline{xrange} поддерживают итерирование, доступ по индексу и получение длины последовательности (\lstinline{len()}); но не поддерживают операции среза (\emph{slicing}), сцепки (\emph{concatenation}) и повтора (\emph{repetition}); также операторы \lstinline{in} и \lstinline{not in} и функции \lstinline{min()} и \lstinline{max()} очень неэффективны с данными объектами. Основное применение \emph{xrange} — итерирование по последовательности целых чисел:

\begin{pylst}{}{}
>>> for i in xrange(1, 10, 2):
...     print i,
...
1 3 5 7 9
\end{pylst}

Последовательности делятся на \emph{изменяемые} (\emph{mutable}) и \emph{неизменяемые} (\emph{immutable}). Последовательности поддерживают следующие операции:

\lstinline{x in s}. Результат — истинный, если какой либо элемент последовательности \lstinline{s} равен \lstinline{x}; иначе — ложный. В случае строк эта операция — проверка, является ли \lstinline{x} подстрокой \lstinline{s}.
\begin{pylst}{}{}
>>> 2 in [1, 2, 3]
True
>>> 'boo' in 'boozers'
True
\end{pylst}

\lstinline{x not in s}. Операция, обратная предыдущей. Возвращает истину, если \lstinline{x} не присутствует в \lstinline{s}.
\begin{pylst}{}{}
>>> 4 not in [1, 2, 3]
True
\end{pylst}

\lstinline{s + t}. Сцепка последовательностей одного типа \lstinline{s} и \lstinline{t}.
\begin{pylst}{}{}
>>> (1, 2, 3) + (4, 5)
(1, 2, 3, 4, 5)
>>> 'foo' + 'bar'
'foobar'
\end{pylst}

\lstinline{s * n} и \lstinline{n * s}. Повтор последовательности \lstinline{n} раз. Если \lstinline{n <= 0}, то возвращается пустая последовательность. Нужно помнить, что при выполнении этой операции делается \emph{shallow}\footnote{Копирование бывает \emph{shallow} и \emph{deep}. В первом случае копируется только сама последовательность, во втором же случае — и все элементы, причём рекурсивно.} копирование.
\begin{pylst}{}{}
>>> [1, 2, 3] * -1
[]
>>> [1, 2, 3] * 0
[]
>>> [1, 2, 3] * 2
[1, 2, 3, 1, 2, 3]

>>> lists = [[]] * 3
>>> lists
[[], [], []]
>>> lists[0].append(3)
>>> lists
[[3], [3], [3]]
\end{pylst}

\lstinline{s[i]}. Доступ к $i$-тому элементу последовательности \lstinline{s}. Первый элемент имеет индекс \lstinline{0}. Индекс также может быть отрицательным, в таком случае отсчёт идёт с конца последовательности. Последний элемент имеет индекс \lstinline{-1}.
\begin{pylst}{}{}
>>> s = list(xrange(1, 10, 3))
>>> s
1, 4, 7
>>> s[2]
7
>>> s[-2]
4
\end{pylst}

\lstinline{s[i:j]}. Срез последовательности, который состоит из элементов, индекс которых больше либо равен \lstinline{i} и меньше \lstinline{j}. Оба индекса могут отсутствовать. Если отсутствует \lstinline{i}, то элементы берутся начиная с первого; если же — \lstinline{j}, то элементы обрабатываются до конца последовательности.

\lstinline{s[i:j:k]}. Также срез, но уже с шагом \lstinline{k}.
\begin{pylst}{}{}
>>> s = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> s[3:-1]
[3, 4, 5, 6, 7, 8]
>>> s[3:]
[3, 4, 5, 6, 7, 8, 9]
>>> s[3:-1:2]
[3, 5, 7]
>>> s[:]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{pylst}

\lstinline{len(s)}. Возвращает количество элементов в последовательности \lstinline{s}.
\begin{pylst}{}{}
>>> len(xrange(10))
10
\end{pylst}

\lstinline{min(s)} и \lstinline{max(s)}. Соответственно минимальный и максимальный элементы последовательности \lstinline{s}.
\begin{pylst}{}{}
>>> s = [4, 1, 9, 5, 6]
>>> min(s)
1
>>> max(s)
9
\end{pylst}

\lstinline{s.index(x[, start[, end]])}. Возвращает индекс первого элемента слева, который равен \lstinline{x}, в последовательности \lstinline{s}. Необязательные аргументы \lstinline{start} и \lstinline{end} указывают интервал поиска.
\begin{pylst}{}{}
>>> s = [9, 4, 1, 8]
>>> s.index(1)
2
\end{pylst}

\lstinline{s.count(x)}. Возвращает количество элементов последовательности \lstinline{s}, которые равны \lstinline{x}. Необязательные аргументы \lstinline{start} и \lstinline{end} указывают интервал поиска.
\begin{pylst}{}{}
>>> s = [1, 2, 1, 2, 3]
>>> s.count(1)
2
\end{pylst}

\subsubsection{Операции над изменяемыми последовательностями}
Нижеперечисленные операции относятся к изменяемым последовательностям, в текущих реализациях \emph{Python} это списки и \lstinline{bytearray}.

\lstinline{s[i] = x}. Заменяет \lstinline{i}-тый элемент последовательности на \lstinline{x}.
\begin{pylst}{}{}
>>> s = [1, 2, 3]
>>> s[1] = 4
>>> s
[1, 4, 3]
\end{pylst}

\lstinline{s[i:j] = t}. Заменяет срез элементами последовательности \lstinline{t}.
\begin{pylst}{}{}
>>> s = [1, 2, 7, 8]
>>> s[:2] = [2, 3]
>>> s
[2, 3, 7, 8]

>>> s[2:2] = [4, 5, 6]
[2, 3, 4, 5, 6, 7, 8]

>>> s[1:6] = []
[2, 8]
\end{pylst}{}

\lstinline{s[i:j:k] = t}. То же самое поведение, что и у предыдущей операции, но на этот раз длина \lstinline{t} должна быть равна длине среза.
\begin{pylst}{}{}
>>> s = [1, 1, 3, 3]
>>> s[1::2] = [2, 4]
>>> s
[1, 2, 3, 4]
\end{pylst}

\lstinline{del s[i:j]} и \lstinline{del s[i:j:k]}. Удаляет элементы среза из последовательности \lstinline{s}.
\begin{pylst}{}{}
>>> s = [1, 2, 3, 4, 5]
>>> del s[-1]
>>> s
[1, 2, 3, 4]

>>> del[::2]
>>> s
[2, 4]
\end{pylst}

\lstinline{s.append(x)}. Добавляет \lstinline{x} в конец последовательности \lstinline{s}.
\begin{pylst}{}{}
>>> s = [1, 2]
>>> s.append(3)
>>> s
[1, 2, 3]
\end{pylst}

\lstinline{s.extend(t)}. Добавляет все элементы последовательности \lstinline{t} в конец последовательности \lstinline{s}.
\begin{pylst}{}{}
>>> s = [1, 2]
>>> s.extend([3, 4])
>>> s
[1, 2, 3, 4]
\end{pylst}

\lstinline{s.insert(i, x)}. Вставляет \lstinline{x} до элемента в последовательности с индексом \lstinline{i}.
\begin{pylst}{}{}
>>> s = [1, 2]
>>> s.insert(0, 0)
>>> s
[0, 1, 2]
\end{pylst}

\lstinline{s.pop([i])}. Удаляет элемент с индексом \lstinline{i} из последовательности. Если индекс не перадан при вызове, то берётся последний элемент.
\begin{pylst}{}{}
>>> s = [1, 2, 3, 4]
>>> s.pop()
4
>>> s
[1, 2, 3]
>>> s.pop(1)
2
>>> s
[1, 3]
\end{pylst}

\lstinline{s.remove(x)}. Удаляет из последовательности первый встреченный элемент, который равен \lstinline{x}.
\begin{pylst}{}{}
>>> s = [1, 3, 2, 3, 4]
>>> s.remove(3)
>>> s
[1, 2, 3, 4]
\end{pylst}

\lstinline{s.reverse()}. Переворачивает последовательность \emph{in-place}.
\begin{pylst}{}{}
>>> s = [1, 2, 3]
>>> s.reverse()
>>> s
[3, 2, 1]
\end{pylst}

\lstinline{s.sort([cmp[, key[, reverse]]])}. Сортирует последовательность \emph{in-place}. Стабильно. Необязательный параметр \lstinline{cmp} должен быть функцией двух аргументов, которая будет использоваться для сравнения элементов последовательности при сортировке. Функция должна возвращать отрицательное целое, нуль или положительное целое число, если первый элемент меньше, равен или больше второго соответственно. Параметр \lstinline{key} определяет функцию одного аргумента, которая будет использоваться для получения ключа для сравнения на основе каждого элемента последовательности. Параметр \lstinline{reverse} — булева типа. Если он равен \lstinline{True}, то результат сравнения будет заменяться на обратный.
\begin{pylst}{}{}
>>> s = ['C', 'd', 'E', 'A', 'b', 'f']
>>> s.sort()
>>> s
['A', 'C', 'E', 'b', 'd', 'f']

>>> s = ['C', 'd', 'E', 'A', 'b', 'f']
>>> s.sort(key=lambda x: x.lower())
>>> s
['A', 'b', 'C', 'd', 'E', 'f']

>>> s = ['C', 'd', 'E', 'A', 'b', 'f']
>>> s.sort(key=lambda x: x.lower(), reverse=True)
>>> s
['f', 'E', 'd', 'C', 'b', 'A']
\end{pylst}

\subsubsection{Строки}
Строка — неизменяемый тип данных. Все операции над последовательностями работают и со строками. Строковые литералы могут быть записаны двумя способами:
\begin{itemize}
  \item \lstinline{'string'} или \lstinline{"string"}. При использовании одинарных кавычек отпадает необходимость экранировать двойные, и наоборот.
  \item \lstinline{'''string'''} или \lstinline{"""string"""}. Строка при этом может занимать несколько строк. Также не нужно экранировать кавычки.
\begin{pylst}{}{}
>>> '''This
... makes
... sense.'''
'This\nmakes\nsense.'
\end{pylst}
\end{itemize}

Также строковые литералы могут иметь следующие префиксы:
\begin{itemize}
  \item \lstinline{r} или \lstinline{R}. С таким префиксом обратная наклонная черта не имеет никакого специального значения\footnote{Все управляющие последовательности перечислены на \url{http://docs.python.org/reference/lexical_analysis.html\#string-literals}}. Очень удобно при записи, например, регулярных выражений.
\begin{pylst}{}{}
>>> print 'one\ntwo'
one two
>>> print r'one\ntwo'
one\ntwo
\end{pylst}
  \item \lstinline{u} или \lstinline{U}. Этот префикс делает литерал юникодовым\footnote{В \emph{Python} 3.x все строки являются юникодовыми; начиная с этой версии типа \lstinline{unicode} нет вообще, а тип \lstinline{str} является тем, что есть \lstinline{unicode} в версии 2.x.}.
\end{itemize}

Для форматирования строк в \emph{Python} есть оператор \lstinline{%} и метод \lstinline{format(*args, **kwargs)}\footnote{В версии 3.x комильфо способом форматирования является метод \lstinline{format}, поэтому следует использовать его.}. Синтаксис и все спецификаторы форматирования, определение собственных спецификаторов и т. д. описаны в \emph{PEP 3101}\footnote{\url{http://www.python.org/dev/peps/pep-3101/}}. Здесь же ограничимся некоторыми примерами, из которых основная суть наглядно ясна:

\begin{pylst}{}{}
>>> 'My name is {0[name]}'.format(dict(name='Fred'))
'My name is Fred'

>>> '%(language)s has %(number)03d quote types.' % \
...     { "language" : "Python", "number" : 2 }
'Python has 002 quote types.'

>>> from datetime import datetime
>>> 'Today is: {0:%a %b %d %H:%M:%S %Y}'.format(datetime.now())
'Today is: Fri Nov 25 18:11:23 2011'
\end{pylst}

В \emph{Python} используется \emph{UTF-8} для представления юникодовых строк. У строк есть методы \lstinline{encode} и \lstinline{decode} для преобразования строк из и в различные кодировки.

\lstinline{s.encode([encoding[, errors]])}. Кодирует строку \lstinline{s}, используя кодировку \lstinline{encoding}. Параметр \lstinline{errros} может быть равен \lstinline{'strict'} (в таком случае будет создаваться исключение \lstinline{UnicodeEncodeError} при ошибках кодирования), \lstinline{'ignore'}, \lstinline{'replace'}, как и другие значения, специфичные для конкретных кодировок.

\lstinline{s.decode([encoding[, errors]])}. Декодирует строку \lstinline{s}, используя кодировку \lstinline{encoding}. Параметры могут принимать те же значения, что и для метода \lstinline{encode}, с тем лишь отличием, что исключение — \lstinline{UnicodeDecodeError}.

Ниже представлены часто употребляемые методы строк:

\lstinline{s.startswith(prefix[, start[, end]])}. Проверяет, начинается ли строка \lstinline{s} с префикса \lstinline{prefix}. Параметрами \lstinline{start} и \lstinline{end} можно задать интервал проверки. Параметр \lstinline{prefix} может быть кортежом префиксов.
\begin{pylst}{}{}
>>> 'substring'.startswith('sub')
True
\end{pylst}

\lstinline{s.endswith(suffix[, start[, end]])}. Проверяет, заканчивается ли строка \lstinline{s} строкой \lstinline{suffix}. В остальном значения параметров такие же, как и для метода \lstinline{startswith}.

\lstinline{s.strip([chars])}. Удаляет с обоих концов строки \lstinline{s} либо пробельные символы, либо символы из строки \lstinline{chars}.
\begin{pylst}{}{}
>>> '      centered      '.strip()
'centered'
\end{pylst}

\lstinline{s.lower()} и \lstinline{s.upper()}. Преобразуют строку к нижнему и верхнему регистру соответственно.
\begin{pylst}{}{}
>>> 'FOObar'.lower()
'foobar'
\end{pylst}

\lstinline{s.split([sep[, maxsplit]])}. Разбивает строку по разделителю \lstinline{sep} и возвращает список полученных элементов. Если же параметр \lstinline{sep} не задан, то разбивается по пробельным символам, причём подряд идущие пробельные символы считаются за один, а пробельные символы на концах строк просто удаляются. Количество разбиений можно ограничить параметром \lstinline{maxsplit}.
\begin{pylst}{}{}
>>> '1,2,3'.split(',')
['1', '2', '3']
>>> '1,,3'.split(',')
['1', '', '3']
>>> ' 1    2  3 '.split()
['1', '2', '3']
>>> ' 1    2  3 '.split(None, 1)
['1', '2  3 ']
\end{pylst}

\lstinline{s.join(iterable)}. Сцепляет строки, которые возвращает итерируемый объект \lstinline{iterable}, с разделителем \lstinline{s}.
\begin{pylst}{}{}
>>> ', '.join(str(i) for i in xrange(10))
'0, 1, 2, 3, 4, 5, 6, 7, 8, 9'
\end{pylst}

\subsubsection{Списки}
Список в \emph{Python} — изменяемая структура данных. Все операции над последовательностями применимы к спискам. Списки реализованы с помощью расширяемых массивов; этот факт нужно не упускать из виду при работе со списками. Так, вставка в начало списка не выполняется за $\Theta(1)$, как ожидается исходя из названия, но за $\Theta(n)$.

\subsubsection{Кортежи}
Кортеж — это неизменяемая последовательность элементов. Нельзя ни удалять элементы из кортежа, ни добавлять, ни изменять. Примеры создания кортежей:
\begin{pylst}{}{}
>>> tuple([1, 2, 3])
(1, 2, 3)
>>> ('a', 'b', 'c')
('a', 'b', 'c')
\end{pylst}

Объекты можно упаковывать (\emph{packing}) в кортеж, но можно и проделать обратную операцию (\emph{unpacking}):
\begin{pylst}{}{}
>>> t = 1, 2, 3
>>> a, b, c = t
>>> b
2
\end{pylst}

\subsection{Словари}
Словарь — изменяемая структура данных. Он отображает хешируемые значения на любые объекты. Словарь можно создавать несколькими способами:
\begin{itemize}
  \item С помощью встроенного синтаксиса:
\begin{pylst}{}{}
>>> d = { 'one' : 1, 'two' : 2 }
>>> d
{'one': 1, 'two': 2}
\end{pylst}

  \item С помощью конструктора и именованных аргументов:
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)
>>> d
{'one': 1, 'two': 2}
\end{pylst}

  \item С помощью конструктора и любой последовательности, содержащей последовательности длины $2$, первый элемент которых становится ключом, а второй — значением.
\begin{pylst}{}{}
>>> d = dict([('one', 1), ('two', 1)])
>>> d
{'one': 1, 'two': 2}
\end{pylst}

  \item Словарным влючением (\emph{dict comprehension})\footnote{Появились в \emph{Python} 2.7. Аналогичны списковым включениям, которые будут рассмотрены позднее.}.
\begin{pylst}{}{}
>>> d = { k : v for k, v in enumerate('ABCD') if v not in 'CB' }
>>> d
{0: 'A', 3: 'D'}
\end{pylst}
\end{itemize}

Ключами не могут быть изменяемые объекты, как списки и другие словари, так как они сравниваются структурно, а структура их может меняться (например, мы можем добавить новый элемент). В то же время ключом может быть произвольный объект, так как сравнение происходит по адресу в памяти, а не структурно. Проиллюстрируем:
\begin{pylst}{}{}
>>> d = dict()
>>> d[list()] = 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'

>>> class dummy(object):
...     def __init__(self):
...         self._list = list()
...
>>> d[dummy()] = 1
>>> d
{<__main__.dummy object at 0x7f922fb3a410>: 1}
\end{pylst}

Ниже рассмотрены некоторые операции над словарями:

\lstinline{d[key]}. Возвращает объект, ассоциированный с ключом \lstinline{key}. Если такового нет — исключение \lstinline{KeyError}.
\begin{pylst}{}{}
>>> d = dict(one=1)
>>> d['one']
1
\end{pylst}

\lstinline{d[key] = value}. Ассоциирует объект \lstinline{value} с ключом \lstinline{key}.
\begin{pylst}{}{}
>>> d = dict()
>>> d['fruits'] = ('banana', 'apple', 'pear')
>>> d
{'fruits': ('banana', 'apple', 'pear')}
\end{pylst}

\lstinline{del d[key]}. Удаляет объект, ассоциированный с ключом \lstinline{key}.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)
>>> del d['two']
>>> d
{'one': 1}
\end{pylst}

\lstinline{key in d} и \lstinline{key not in d}. Проверяют наличие или отсутствие соответственно ключа \lstinline{key} в словаре \lstinline{d}.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)
>>> 'one' in d
True
>>> 'three' in d
False
\end{pylst}

\lstinline{d.clear()}. Удаляет все элементы из словаря.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)
>>> d.clear()
>>> d
{}
\end{pylst}

\lstinline{d.items()} и \lstinline{d.iteritems()}. Метод \lstinline{items()} возвращает список пар вида \lstinline{(key, value)}. Метод же \lstinline{iteritems()} возвращает итератор по тем же парам.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)

>>> d.items()
[('two', 2), ('one', 1)]
>>> d.iteritems()
<dictionary-itemiterator object at 0x7f922fb88f18>

>>> for k, v in d.iteritems():
...     print k, ':', v
...
two : 2
one : 1
\end{pylst}

\lstinline{d.keys()} и \lstinline{d.iterkeys()}. Метод \lstinline{keys()} возвращает список всех ключей. Метод \lstinline{iterkeys()} возвращает итератор по ключам.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)

>>> d.keys()
['two', 'one']
>>> d.iterkeys()
<dictionary-keyiterator object at 0x7f922fb88f18>

>>> for k in d.iterkeys():
...     print k,
...
two one
\end{pylst}

\lstinline{d.values()} и \lstinline{d.itervalues()}. Метод \lstinline{values()} возвращает список всех значений. Метод \lstinline{itervalues()} возвращает итератор по значениям.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)

>>> d.values()
[2, 1]
>>> d.itervalues()
<dictionary-valueiterator object at 0x7f922fb88f18>

>>> for v in d.itervalues():
...     print v,
...
2 1
\end{pylst}

\lstinline{d.update(other)}. Обновляет словарь элементами словаря \lstinline{other}.
\begin{pylst}{}{}
>>> d = dict(one=1, two=2)
>>> d.update({ 'three' : 3 })
{'one': 1, 'three': 3, 'two': 2}
\end{pylst}

\lstinline{d.get(key[, default])}. Если в словаре есть значение для ключа \lstinline{key}, то возвращает его, иначе — \lstinline{default}, если он передан, и исключение \lstinline{KeyError}, если нет.
\begin{pylst}{}{}
>>> d = dict(one=1)
>>> d.get('one', None)
1
>>> d.get('two', None)
None
\end{pylst}

\lstinline{d.setdefault(key[, default])}. Если в словаре нет значения для ключа \lstinline{key}, то ассоциирует с ним значение \lstinline{default}. Если \lstinline{default} не передан при вызове, то он равняется \lstinline{None}.
\begin{pylst}{}{}
>>> d = dict(furniture=['chair'])
>>> d
{'furniture': ['chair']}

>>> d.setdefault('furniture', list()).append('table')
>>> d
{'furniture': ['chair', 'table']}
\end{pylst}

\subsection{Множества}
Множество (\emph{set}) в \emph{Python} — неупорядоченная коллекция данных, в которой элементы не повторяются. Элементами множеств могут быть лишь хешируемые объекты. Есть два типа множеств: \lstinline{set} и \lstinline{frozenset}. \lstinline{set} — изменяемая структура данных, а \lstinline{frozenset} — нет. Создать их можно несколькими способами:
\begin{itemize}
  \item С помощью встроенных функций \lstinline{set()} и \lstinline{frozenset()}.
\begin{pylst}{}{}
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> fruits = set(basket)
>>> fruits
set(['apple', 'banana', 'orange', 'pear'])
\end{pylst}

  \item Непустое изменяемое множество может быть создано специальным синтаксисом:
\begin{pylst}{}{}
>>> { 'apple', 'orange', 'apple', 'pear', 'orange', 'banana' }
set(['apple', 'banana', 'orange', 'pear'])
\end{pylst}

  \item Изменяемое множество может быть создано множественным включением (\emph{set comprehension})\footnote{Появились \emph{Python} 2.7. Аналогичны списковым включениям, которые будут рассмотрены позднее.}.
\begin{pylst}{}{}
>>> s = { v for v in 'ABCDABCD' if v not in 'CB' }
>>> s
set(['A', 'D'])
\end{pylst}
\end{itemize}

Множества поддерживают ожидаемый набор операций: проверка на присутствие, объединение, пересечение и т. д. Вот некоторые из них, применимые как к изменяемым, так и к неизменяемым множествам:

\lstinline{len(s)}. Возвращает размер множества \lstinline{s}.
\begin{pylst}{}{}
>>> s = set([1, 2, 3])
>>> len(s)
3
\end{pylst}

\lstinline{x in s} и \lstinline{x not in s}. Проверяют, присутствует ли или не присутствует элемент \lstinline{x} в множестве \lstinline{s}.
\begin{pylst}{}{}
>>> s = set([1, 2, 3])
>>> 2 in s
True
>>> 0 in s
False
\end{pylst}

\lstinline{s.isdisjoint(other)}. Возвращает истину, если множество \lstinline{s} не имеет одинаковых элементов с \lstinline{other}, то есть пересечение \lstinline{s} и \lstinline{other} — пустое множество.
\begin{pylst}{}{}
>>> s1, s2, s3 = set([1, 2, 3]), set([4, 5, 6]), set([3, 4])
>>> s1.isdisjoint(s2)
True
>>> s1.isdisjoint(s3)
False
\end{pylst}

\lstinline{s.issubset(other)} или \lstinline{s <= other}. Проверяют, является ли \lstinline{s} подмножеством \lstinline{other}.
\begin{pylst}{}{}
>>> s = set([1, 2, 3])
>>> s.issubset(s)
True
\end{pylst}

\lstinline{s < other}. Проверяет, является ли \lstinline{s} подмножеством \lstinline{other}, причём \lstinline{s != other}.
\begin{pylst}{}{}
>>> s = set([1, 2, 3])
>>> s < s
False
\end{pylst}

\lstinline{s.issuperset(other)} или \lstinline{s >= other}. Проверяют, является ли \lstinline{other} подмножеством \lstinline{s}.
\begin{pylst}{}{}
>>> s = set([1, 2, 3])
>>> s.issuperset(s)
True
\end{pylst}

\lstinline{s > other}. Проверяет, является ли \lstinline{other} подмножеством \lstinline{s}, причём \lstinline{other != s}.
\begin{pylst}{}{}
>>> s = set([1, 2, 3])
>>> s > s
False
\end{pylst}

\lstinline{s.union(other)} или \lstinline{s | other}. Возвращают новое множество, которое является объединением обоих.
\begin{pylst}{}{}
>>> s1, s2 = set([1, 2]), set([2, 3])
>>> s1.union(s2)
set([1, 2, 3])
\end{pylst}

\lstinline{s.intersection(other)} или \lstinline{s & other}. Возвращают пересечение множеств.
\begin{pylst}{}{}
>>> s1, s2 = set([1, 2]), set([2, 3])
>>> s1.intersection(s2)
set([2])
\end{pylst}

\lstinline{s.difference(other)} или \lstinline{s - other}. Возвращают разность множеств.
\begin{pylst}{}{}
>>> s1, s2 = set([1, 2]), set([2, 3])
>>> s1.difference(s2)
set([1])
\end{pylst}

\lstinline{s.symmetric_difference(other)} или \lstinline{s ^ other}. Возвращают симметрическую разность.
\begin{pylst}{}{}
>>> s1, s2 = set([1, 2]), set([2, 3])
>>> s1.symmetric_difference(s2)
set([1, 3])
\end{pylst}

У изменяемых множеств есть следующие методы вдобавок:

\lstinline{s.add(x)}. Добавляет объект \lstinline{x} в множество \lstinline{s}.
\begin{pylst}{}{}
>>> s = set([1, 2])
>>> s.add(3)
>>> s
set([1, 2, 3])
\end{pylst}

\lstinline{s.remove(x)}. Удаляет объект \lstinline{x} из множества. Если же его в нём нет, то — исключение \lstinline{KeyError}.
\begin{pylst}{}{}
>>> s = set([1, 2])
>>> s.remove(1)
>>> s
set([2])
\end{pylst}

\lstinline{s.discard(x)}. Удаляет объект \lstinline{x} из множества, если он там присутствует.
\begin{pylst}{}{}
>>> s = set([1, 2])
>>> s.discard(1)
>>> s.discard(1)
>>> s
set([2])
\end{pylst}

\lstinline{s.clear()}. Удаляет все элементы из множества.
\begin{pylst}{}{}
>>> s = set([1, 2])
>>> s.clear()
>>> s
set([])
\end{pylst}

\section{Операторы}
\label{sec:py-statements}

\subsubsection{Оператор if}
Общая форма оператора \lstinline{if} выглядит следующим образом\footnote{Здесь и далее при записи общей формы оператора используется нотация регулярных выражений, а именно: \lstinline{(x, y, ...)} — круглые скобки группирует то, что они обрамляют графически; \lstinline{*} означает, что запись слева может появиться ноль или более раз; \lstinline{+} — запись слева может появиться один и более раз; \lstinline{[x, y]} — то, что внутри квадратных скобок, может появиться ноль или один раз; \lstinline{x | y} — может появиться либо \lstinline{x}, либо \lstinline{y}.}:
\begin{pylst}{}{}
if $expression$: $suite$
( elif $expression$: $suite$)*
[ else: $suite$ ]
\end{pylst}

Этот оператор вычисляет последовательно выражения $expression$ до тех пор, пока не будет найдено равное \lstinline{True}. После чего выполняется соответсвующее $suite$. Если все выражения оказались ложными, то выполняются операторы и выражения из \lstinline{else} ветки, если таковая присутствует.

Ниже представлена функция, которая печатает, является ли переданная строка путём к директории, файлу либо чему-нибудь ещё.
\begin{pylst}{}{}
import os.path

def whatsit(path):
    if os.path.isdir(path):
        print 'directory'
    elif os.path.isfile(path):
        print 'file'
    else:
        print 'something else'
\end{pylst}

Вот пример её использования:
\begin{pylst}{}{}
>>> whatsit('/tmp')
directory
>>> whatsit('/boot/grub/grub.conf')
file
\end{pylst}

\subsubsection{Оператор while}
Общая форма оператора \lstinline{while} выглядит следующим образом:
\begin{pylst}{}{}
while $expression$: $suite_1$
[ else: $suite_2$ ]
\end{pylst}

Оператор \lstinline{while} выполняет $suite_1$, пока $expression$ истинно. Как только $expression$ оказалось ложно, выполняется ветка \lstinline{else}, после чего цикл завершается.
\begin{pylst}{}{}
>>> expression = [3, 2, 1]
>>> while expression:
...     print 'suite-1:', expression.pop()
... else:
...     print 'suite-2'
...
suite-1: 1
suite-1: 2
suite-1: 3
suite-2
\end{pylst}

Оператор \lstinline{break} завершает цикл без выполнения ветки \lstinline{else}.
\begin{pylst}{}{}
>>> while True:
...     print 'suite-1'
...     break
... else:
...     print 'suite-2'
...
suite-1
\end{pylst}

Оператор \lstinline{continue} передает управление на начало цикла.

\subsubsection{Оператор for}
Общая форма оператора \lstinline{for} выглядит следующим образом:
\begin{pylst}{}{}
for $variable$ in $expression$: $suite_1$
[ else: $suite_2$ ]
\end{pylst}

$expression$ вычисляется единожды. Оно должно вычислятся в итерируемый объект. Затем $suite_1$ вычисляется столько раз, сколько объектов в итерируемом объекте, при этом переменной $variable$ присваивается очередной объект. По завершении вычисляется ветка \lstinline{else}.
\begin{pylst}{}{}
>>> for i in xrange(3):
...     print 'suite-1:', i
... else:
...     print 'suite-2'
...
suite-1: 0
suite-1: 1
suite-1: 2
suite-2
\end{pylst}

Оператор \lstinline{break} завершает цикл без выполнения ветки \lstinline{else}.
\begin{pylst}{}{}
>>> for i in xrange(3):
...     print 'suite-1:', i
...     if i > 1:
...         break
... else:
...     print 'suite-2'
...
suite-1: 0
suite-1: 1
\end{pylst}

Оператор \lstinline{continue} передает управление на начало цикла или, если больше нет очередного объекта, на ветку \lstinline{else}.

\subsubsection{Оператор try}
\label{sec:py-try-stmt}

Общая форма оператора \lstinline{try} выглядит следующим образом:
\begin{pylst}{}{}
try: $suite_1$
( except [ $expression$ [ ( as | , ) $target$ ] ]: $suite_2$ )+
[ else: $suite_3$ ]
[ finally: $suite_4$ ]
\end{pylst}
или
\begin{pylst}{}{}
try: $suite_1$
finally: $suite_4$
\end{pylst}

Блоки \lstinline{except} определяют обработчики исключительных ситуаций. Если при выполнении $suite_1$ не возникло исключительной ситуации, то ни один из обработчиков не выполняется.
\begin{pylst}{}{}
>>> try:
...     print 'Hello.'
... except ArithmeticError:
...     print 'Arithmetic error occured.'
... except:
...     print 'Error occured.'
...
Hello.
\end{pylst}

В ином случае происходит последовательный поиск подходящего обработчика по блокам \lstinline{except}. При поиске обработчика выражения $expression$ вычисляются, и соответствующий $suite_2$ выбирается для выполнения, если результатом вычисления $expression$ является класс, который присутствует в списке наследования объекта-исключения, или же кортеж, в котором хотя бы один элемент является таким классом.
\begin{pylst}{}{}
>>> try:
...     1 / 0
... except ZeroDivisionError:
...     print 'Illegal operation performed.'
...
Illegal operation performed.
\end{pylst}

Также это исключение можно словить, использую класс \lstinline{ArithmeticError}, который является базовым классом класса \lstinline{ZeroDivisionError}.
\begin{pylst}{}{}
>>> try:
...     1 / 0
... except ArithmeticError:
...     print 'Here we catch all arithmetic errors.'
...
Here we catch all arithmetic errors.
\end{pylst}

Блок \lstinline{except} без выражений $expression$, если таковой присутствует, должен быть последним. Этот блок выполняется по умолчанию, если более подходящего обработчика не было найдено.
\begin{pylst}{}{}
>>> try:
...     x
... except ArithmeticError:
...     print 'Here we catch all arithmetic errors.'
... except:
...     print 'Here we are catching even NameError.'
...
Here we are catching even NameError.
\end{pylst}

Если обработчик не найден, поиск происходит в обрамляющем коде и вверх дальше по стеку, если блок \lstinline{finally} не присутсвует. Если он присутствует, то он может бросить новое исключение, тогда старое «потеряется». Например, в следующем коде в блоке \lstinline{try} возникнет исключение \lstinline{NameError}, но блок \lstinline{finally} перехватит его и бросит новое исключение \lstinline{Exception}.
\begin{pylst}{}{}
>>> try:
...     x
... finally:
...     raise Exception
...
Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
Exception
\end{pylst}

Если при выполнении выражений $expression$ возникло исключение, то изначальное исключение отбрасывается, и начинается новый поиск для нового исключения в обрамляющем коде и вверх по стеку.

Если же подходящий блок \lstinline{except} найден, то $target$, если присутствует, присваивается результат вычисления $expression$, и блок исполняется. После чего управление передается, как правило, за пределы оператора \lstinline{try}.
\begin{pylst}{}{}
>>> try:
...     1 / 0
... except Exception, e:
...     print e
...
integer division or modulo by zero
\end{pylst}

Блок \lstinline{else} выполняется в том случае, если управление достигло конца блока \lstinline{try}. Исключения, возникшие в блоке \lstinline{else}, не обрабатываются предыдущими ему обработчиками.
\begin{pylst}{}{}
>>> try:
...     1 + 1
... except:
...     print 'Error occured.'
... else:
...     print 'Sum done well.'
...
2
Sum done well.
\end{pylst}

Блок \lstinline{finally} выполняется всегда независимо от того, возникла ли исключительная ситуация или нет и где: внутри блока \lstinline{try}, \lstinline{except} или же \lstinline{else}.
\begin{pylst}{}{}
>>> try:
...     raise Exception
... finally:
...     print 'in finally'
...
in finally
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
Exception
\end{pylst}

В обработчике можно вызвать функцию \lstinline{sys.exc_info()}, которая возвращает кортеж \lstinline{(exc_type, exc_value, exc_traceback)}, где \lstinline{exc_type} — объект исключения, \lstinline{exc_value} — параметры, переданные исключению, \lstinline{exc_traceback} — traceback объект. Всевозможные удобные функции для работы с этими объектами собраны в модуле \lstinline{traceback}. Ниже приводится банальная реализация интерпретатора \emph{Python} на \emph{Python}:
\begin{pylst}{}{}
import sys
import traceback

def run_user_code(envdir):
    source = raw_input(">>> ")
    try:
        exec source in envdir
    except:
        print "Exception in user code:"
        print '-' * 60
        traceback.print_exc(file=sys.stdout)
        print '-' * 60

envdir = {}
while True:
    run_user_code(envdir)
\end{pylst}

Следом — пример сессии этого игрушечного интерпретатора:
\begin{pylst}{}{}
>>> 1 / 0
Exception in user code:
------------------------------------------------------------
Traceback (most recent call last):
  File "test.py", line 7, in run_user_code
    exec source in envdir
  File "<string>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
------------------------------------------------------------
>>> Traceback (most recent call last):
  File "test.py", line 16, in <module>
    run_user_code(envdir)
  File "test.py", line 5, in run_user_code
    source = raw_input(">>> ")
EOFError
\end{pylst}

\subsubsection{Оператор with}
Общая форма оператора \lstinline{with} выглядит следующим образом:
\begin{pylst}{}{}
with $expression$ [ as $target$ ]: $suite$
\end{pylst}

Схема работы следующая:
\begin{enumerate}
  \item $expression$ вычисляется.
  \item Вызывается метод \lstinline{__enter__()} у результата вычисления $expression$.
  \item Если использовалась форма \lstinline{as target}, то значение возвращенное из \lstinline{__enter__} присваивается $target$.
  \item Исполняется $suite$.
  \item Вызывается метод \lstinline{__exit__()}. Если возникло исключение при исполнении $suite$ и метод \lstinline{__exit__()} вернул \lstinline{False}, то исключение порождается вновь.
\end{enumerate}

\begin{pylst}{}{}
import threading

lock = threading.Lock()
with lock: ...
\end{pylst}

\section{Функции}
Ниже приведено тривиальное определение функции:
\begin{pylst}{}{}
def add(a, b):
    return a + b
\end{pylst}

Как видно из примера, определение функции начинается с оператора \lstinline{def}, за которым идет имя функции, а следом — аргументы, заключенные в круглые скобки. Возврат значения происходит посредством оператора \lstinline{return}. Если возврат из функции происходит из-за того, что управление достигло конца функции, то возвращаемое значение равно \lstinline{None}. Определение функции связывает её имя с объектом функции (обёрткой над действительно исполняемым кодом) в текущем пространсве имён. Объект функции содержит ссылку на текущее глобальное пространство имён, которое будет использоваться при вызове функции.
\begin{pylst}{}{}
>>> type(add)
<type 'function'>
>>> add.__globals__
{'__builtins__': <module '__builtin__' (built-in)>,
 '__name__': '__main__', 'add': <function add at 0x7f4f81af8578>,
 '__doc__': None, '__package__': None}
\end{pylst}

Определение функции может быть обёрнуто декораторами\footnote{Декораторы рассматриваются в секции~«\nameref{sec:py-decorators}» на стр.~\pageref{sec:py-decorators}.}. Декораторы вычисляются во время определения функции в том же самом контексте, где находится определение функции.

Функция может иметь именованные аргументы, которые имеют значение по умолчанию. При вызове функции не обязательно передавать именованные аргументы, если устраивает значение по умолчанию. В определении функции после именованного аргумента могут идти только именованные аргументы.
\begin{pylst}{}{}
def yes_or_no(prompt, retries=4, complaint='Please enter Yes or No.'):
    while True:
        answer = raw_input(prompt)
        answer = answer.lower()
        if answer in ('y', 'ye', 'yes'):
            return True
        if answer in ('n', 'no', 'nop', 'nope'):
            return False

        retries -= 1
        if retries < 0:
            raise IOError('User has not approved or declined an action.')

        print complaint
\end{pylst}

Примеры вызовов вышеприведённой функции:
\begin{pylst}{}{}
>>> yes_or_no('Delete the file:', retries=3)
...
>>> yes_or_no('Will you marry me?',
              complaint="That's fine, but one more time...")
...
\end{pylst}

Значения по умолчанию для именованных аргументов вычисляются один раз при выполнении определения функции. После чего при любом вызове используется один и тот же объект. Если значение по умолчанию --- изменяемый (mutable) объект, то можно наткнуться на неприятности, что и проиллюстрировано ниже:
\begin{pylst}{}{}
def append(list=[]):
    list.append('a')
    return list

>>> append()
['a']
>>> append()
['a', 'a']
>>> append()
['a', 'a', 'a']
\end{pylst}

Ниже представлена версия, лишенная приведенного недостатка:
\begin{pylst}{}{}
def append(list=None):
    if list is None:
        list = []
    list.append('a')
    return list

>>> append()
['a']
>>> append()
['a']
\end{pylst}

Если в определении функции присутствует форма \lstinline{*identifier}, то \lstinline{identifier} будет равен кортежу, который содержит все аргументы, которые не были явно проименованы. Если же присутствует форма \lstinline{**identifier}, то \lstinline{identifier} будет словарём, который отображет имена аргументов на их значения.
\begin{pylst}{}{}
def fargs(*args):
    print args

def fkwargs(**kwargs):
    print kwargs

>>> fargs(1, 2, 3)
(1, 2, 3)
>>> fkwargs(one=1, two=2, three=3)
{'three': 3, 'two': 2, 'one': 1}
\end{pylst}

При вызове если происходит ошибка разбора аргументов, их нехватка или избыток и так далее, то порождается исключение \lstinline{TypeError}. Если при вызове присутствует форма \lstinline{*identifier}, то \lstinline{identifier} должен вычисляться в последовательность, элементы которой будут считаться дополнительными позиционными аргументами. Если же при вызове присутсвует форма \lstinline{**identifier}, то \lstinline{identifier} должен вычисляться в словарь, ключи которого будут использоваться в качестве именованных аргументов, а значения — в качестве значений этих аргументов.
\begin{pylst}{}{}
def fargs(a, b, c):
    print a, b, c

def fkwargs(a, b=2, c=3):
    print a, b, c

>>> args = [1, 2, 3]
>>> fargs(*args)
1 2 3

>>> kwargs = { 'a' : 2, 'b' : 3, 'c' : 4 }
>>> fkwargs(**kwargs)
2 3 4
\end{pylst}

Обе формы могут присутствовать одновременно как при определении функции, так и при вызове.

Функция может иметь \emph{строку документации} (\emph{docstring}), которая записывается на следующей строке после сигнатуры функции. Строка документации позже может быть получена из аттрибута функции \lstinline{__doc__}.
\begin{pylst}{}{}
def func():
   """Here goes docstring."""
   pass

>>> func.__doc__
'Here goes docstring.'
\end{pylst}

\subsubsection{Анонимные функции}
\emph{Анонимные (безымянные) функции} в \emph{Python} — объекты функций, которые не имеют имени ни в каком пространстве имён после \emph{непосредственного} определения. Они определяются с помощью \emph{лямбда-выражений}:
\begin{pylst}{}{}
lambda [ $parameters$ ]: $expression$
\end{pylst}

В отличии от обычного определения функции лямбда-выражение не может содержать операторов (\emph{statements}).
\begin{pylst}{}{}
>>> map(lambda i: i + 1, [1, 2, 3])
[2, 3, 4]
\end{pylst}

\section{Функциональное программирование}
В \emph{Python} возможно использовать некоторые идеи функционального программирования.

\subsection{Функции высшего порядка}
\emph{Функция высшего порядка} — функция, принимающая в качестве аргументов другие функции или возвращающая функцию в качестве результата. Как пример, реализуем композицию двух функций одного аргумента.
\begin{pylst}{}{}
def compose(g, f):
    return lambda x: g(f(x))

def f(x):
    return x + 3

def g(x):
    return 2 * x

>>> z = compose(g, f)
>>> z(2)
10
\end{pylst}

Ниже представлены наиболее общеупотребимые функции высшего порядка, определенные в \emph{Python}.

\subsubsection{Функция map}
\lstinline{map} — функция высшего порядка, которая применяет переданную функция к элементам одной или нескольких последовательностей. Количество аргументов переданной функции должно быть равно количеству переданных последовательностей. Если последовательности не одинаковой длины, то вместо недостающих элементов используется \lstinline{None}. Длина результирующего списка равна длине наибольшего списка. Если вместо функции передается \lstinline{None}, тогда элементы последовательностей никак не преобразуются, а используются как есть; при этом если последовательностей — несколько, то результатом будет список кортежей.
\begin{pylst}{}{}
map(function, sequence[, sequence, ...]) -> list

>>> map(lambda x, y: x + y, [1, 2, 3], [2, 3, 4])
[3, 5, 7]
>>> map(None, [1, 2], [3])
[(1, 3), (2, None)]
\end{pylst}

\subsubsection{Функция filter}
\lstinline{filter} — функция высшего порядка, которая конструирует итоговый список из элементов переданной последовательности, если конкретный элемент удовлетворяет функции-предикату. Если в качестве последовательности передается строка или кортеж, то и тип результата будет строка или кортеж, соответственно. Если функция равна \lstinline{None}, то возвращаемая последовательность будет состоять из элементов, которые истинны.
\begin{pylst}{}{}
filter(function or None, sequence) -> list, tuple, or string

>>> filter(lambda x: x % 2, [1, 2, 3, 4, 5])
[1, 3, 5]
\end{pylst}

\subsubsection{Функция reduce}
\lstinline{reduce} — функция высшего порядка, которая делает свёртку последовательности, в результате чего получается, как правило, значение типа элемента последовательности. Функция свёртки обычно принимает три аргумента: комбинирующую функцию \lstinline{function}, начальное значение \lstinline{initial} и последовательность \lstinline{sequence}.
\begin{pylst}{}{}
reduce(function, sequence[, initial]) -> value
\end{pylst}

$4!$ можно вычислить следующим образом, используя функцию \lstinline{reduce}:
\begin{pylst}{}{}
>>> reduce(lambda res, x: res * x, [2, 3, 4], 1)
24
\end{pylst}

Вычисление происходит следующим образом:
\begin{center}
  \begin{tikzpicture}[level/.style={sibling distance=50mm/#1}]
    \node [circle, draw] {$*$}
      child { node [circle, draw] {$*$}
        child { node [circle, draw] {$*$}
          child { node [circle, draw] {$1$} }
          child { node [circle, draw] {$2$} } }
        child { node [circle, draw] {$3$} } }
      child { node [circle, draw] {$4$} };
  \end{tikzpicture}
\end{center}

Другая иллюстрация:
\begin{pylst}{}{}
(((1 * 2) * 3) * 4)
\end{pylst}

\subsection{Рекурсия}
Хоть в \emph{Python} и существует рекурсия, но в наиболее популярной реализации этого языка — \emph{CPython} — она не православна, так как там нет \emph{оптимизации хвостовых вызовов} (\emph{tail call optimization}, \emph{TCO}).

\emph{Хвостовая рекурсия} — специальный случай рекурсии, при котором последней операцией, выполняемой рекурсивной функцией, является вызов самой себя. Подобный вид рекурсии примечателен тем, что может быть легко и автоматически заменён на итерацию, что и делают многие оптимизирующие компиляторы. Подобные рассуждения справедливы и для взаимно рекурсивных функций, хоть \emph{TCO} для них в компиляторах встречается еще реже.

\begin{pylst}{}{}
def infinite():
    infinite()

>>> infinite()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
...
RuntimeError: maximum recursion depth exceeded
\end{pylst}

Получить и установить максимальное возможное количество рекурсивные вызовов можно с помощью функцией \lstinline{sys.getrecursionlimit()} и \lstinline{sys.setrecursionlimit(limit)}.

\subsection{Замыкания}
\emph{Замыкание} — первоклассная функция со свободными переменными, которые связаны с определенными значениями в своем лексическом окружении. \emph{Свободная переменная} — переменная, которая встречается в теле функции, но которая не является параметром этой функции или локальной переменной.
\begin{pylst}{}{}
def make_adder(y):
    def add(x):
        return x + y
    return add

>>> add5 = make_adder(5)
>>> add5(5)
10
>>> add5(7)
12
\end{pylst}

Замыкание \lstinline{add} создается при каждом вызове функции \lstinline{make_adder}. В замыкании \lstinline{add} переменная \lstinline{y} является свободной переменной.

Замыкания в \emph{Python} также не доведены до логического конца, хоть в версиях 3.x уже такая претензия есть. В версии 3.0 введен оператор \lstinline{nonlocal}, суть которого видна из следующего примера:
\begin{pylst}{}{}
def make_counter():
    count = 0
    def get():
        return count
    def inc():
        count += 1

    return get, inc

>>> get, inc = make_counter()
>>> get()
>>> 0
>>> inc()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/tmp/py9637pml", line 11, in inc
UnboundLocalError: local variable 'count' referenced before assignment

def make_counter():
    count = 0
    def get():
        nonlocal count
        return count
    def inc():
        count += 1

    return get, inc

>>> get, inc = make_counter()
>>> get()
>>> 0
>>> inc()
>>> get()
1
\end{pylst}

\subsection{Частичное применение функции}
\emph{Частичное применение} функции — это преобразование функции от $n$ аргументов к функции от $n - m$ аргументов ($m < n$), в которой $m$ аргументов привязаны к определенным значениям. То есть некоторые аргументы изначальной функции фиксируются.

Эта возможность предоставляется стандартной библиотекой \emph{Python}:
\begin{pylst}{}{}
from functools import partial
basetwo = partial(int, base=2)

>>> basetwo('10010')
18
\end{pylst}

\subsection{Списковые включения}
\emph{Списковое включение} (\emph{list comprehension}) — удобная конструкция для порождения списков. Часто предпочтительней использовать именно списковые включения, а не набор функций \lstinline{map} и \lstinline{filter}. Суть видна из следующих демонстраций:

\begin{pylst}{}{}
>>> [i for i in range(10)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

>>> [[i * j for j in range(5)] for i in range(5)]
[[0, 0, 0, 0, 0],
 [0, 1, 2, 3, 4],
 [0, 2, 4, 6, 8],
 [0, 3, 6, 9, 12],
 [0, 4, 8, 12, 16]]

>>> [i + j for i in range(3) for j in range(3)]
[0, 1, 2, 1, 2, 3, 2, 3, 4]

>>> [i + j for i in range(3) if i % 2 == 0 for j in range(3) if j % 2 == 1]
[1, 3]
\end{pylst}

\section{Модули}
\label{sec:py-modules}
Модуль представляет собой функционально законченный фрагмент программы, оформленный, как правило, в виде отдельного файла с исходным кодом, предназначенный для использования в других программах. Модули позволяют разбивать сложные задачи на более мелкие.

Модуль импортируются с помощью оператора \lstinline{import}. Оператор \lstinline{import} имеет две формы:
\begin{pylst}{}{}
import $module$
\end{pylst}
и
\begin{pylst}{}{}
from $module$ import ( $something$ [ as $someothername$ ] )+
\end{pylst}

При импорте модуля вычисление выражений и операторов верхнего уровня (top-level) происходит лишь единожды, иначе они бы вычислялись неопределённое количество раз. Проиллюстрируем это. Создадим бесполезный модуль \lstinline{dummy}, в котором будет лишь один оператор: оператор вывода.
\begin{pylst}{dummy.py}{}
print 'in dummy module'
\end{pylst}

Теперь импортируем его несколько раз из интерпретатора:
\begin{pylst}{}{}
>>> import dummy
in dummy module
>>> import dummy
\end{pylst}

Как видно, вывод на консоль случился только один раз. При импорте модуля в текущем модуле создаётся переменная, которая связана с объектом импортируемого модуля.
\begin{pylst}{}{}
>>> import sys
>>> sys
<module 'sys' (built-in)>
>>> sys.argv
['/usr/bin/ipython']
\end{pylst}

При импорте же из модуля конкретных объектов в текущем модуле создаются также переменные, которые связаны с импортируемыми объектами.
\begin{pylst}{}{}
>>> from sys import argv, modules
>>> argv
['/usr/bin/ipython']
>>> modules.popitem()
('IPython.Prompts',
 <module 'IPython.Prompts' from '/usr/lib64/python2.7/site-packages/IPython/Prompts.pyc'>)
\end{pylst}

Итак, импорт модуля состоит из двух шагов:
\begin{enumerate}
  \item Поиск модуля и его инициализация, если необходима.
  \item Определение локальных имен в той области видимости, где находится сам оператор \lstinline{import}.
\end{enumerate}
Первая форма оператора делает как первый шаг, так и второй. Вторая же форма оператора выполняет первый шаг единожды, после чего повторяет второй шаг для всех импортируемых имён. Поиск модулей происходит в директориях, перечисленных в списке \lstinline{sys.path}.
\begin{pylst}{}{}
>>> import sys
>>> sys.path.insert(0, '/var/www/site')
>>> sys.path[:3]
['/var/www/site', '', '/usr/bin']
\end{pylst}

Если при импортировании модуль не может быть найден, то возникает исключение \lstinline{ImportError}. При использовании формы импорта модуля со звёздочкой в текущее пространство импортируются все публичные (public) имена. Их список определяется в переменной \lstinline{__all__} модуля или же конструируется из всех глобальных имён импортируемого модуля.
\begin{pylst}{}{}
>>> import threading
>>> threading._sleep
<built-in function sleep>

>>> from threading import *
>>> _sleep
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name '_sleep' is not defined

>>> '_sleep' in threading.__all__
False
\end{pylst}

Модуль имеет пространство имён в виде словаря (это тот самый словарь, на который ссылает аттрибут \lstinline{func_global} любой определенной функции в этом модуле). Чтение аттрибута модуля \lstinline{m.x} эквивалентно поиску по ключу в словаре \lstinline{m.__dict__['x']}. Каждый модуль имеет несколько специальных аттрибутов:
\begin{itemize}
  \item \lstinline{__name__} — имя модуля;
  \item \lstinline{__doc__} — строка документации модуля или \lstinline{None}, если её нет;
  \item \lstinline{__file__} — путь к файлу, если таковой существует, из которого модуль был загружен.
\end{itemize}

\begin{pylst}{}{}
>>> import threading
>>> threading.__name__
'threading'
>>> threading.__doc__[:50]
"Thread module emulating a subset of Java's threadi"
>>> threading.__file__
'/usr/lib64/python2.7/threading.pyc'
\end{pylst}

Модули и пакеты могут образовывать иерархию. Модули не могут содержать ни другие модули, ни другие пакеты. В то время как пакет может содержать как другие модули, так и другие пакеты. Если эту структуру отображать на файловую систему, то модулям сответствуют файлы, а пакетам — директории, в которых находиться файл \lstinline{__init__.py}. Посмотрим на часть иерархии проекта \emph{Django}:
\begin{plainlst}{}{}
django/
       __init__.py
       db/
                 __init__.py
                 backends/
                 models/
                 transaction.py
                 utils.py
       forms/
                 __init__.py
                 extras/
                 fields.py
                 forms.py
                 ...
       http/
                 __init__.py
                 multipartparser.py
                 utils.py
       template/
                 __init__.py
                 loaders/
                 base.py
                 context.py
                 debug.py
                 ...
       ...
\end{plainlst}

Вот несколько примеров использования оператора \lstinline{import} с \emph{Django}:
\begin{pylst}{}{}
from django.db import models
from django.http import Http404, HttpResponse
from django.template import Context

class Poll(models.Model):
    question = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')
\end{pylst}

Импорт может быть относительным. Точка перед модулем значит, что путь до модуля нужно искать от того модуля, где происходит импорт. Если две точки, то начинать надо с уровня выше. И так далее. Например, если импорт \lstinline{from . import mod} происходит из модуля в пакете \lstinline{pkg}, то импортирован будет модуль \lstinline{pkg.mod}. Если же импорт \lstinline{from ..subpkg2 import mod} --- из пакета \lstinline{pkg.subpkg1}, импортирован модуль \lstinline{pkg.subpkg2.mod}.

При выполненении \lstinline{from mod import *} не импортируются имена, которые начинаются с \lstinline{_}. Модули можно подгружать динамически, используя встроенную функцию \lstinline{__import__}.

\section{Декораторы}
\label{sec:py-decorators}
\emph{Декоратор} — объект, который можно вызвать с одним аргументом. На практике декоратор — это либо функция одного аргумента, либо объект с методом \lstinline{__call__(self, f)}. Назначение декоратора — динамически «оборачивать» функцию, метод либо класс в какую-либо дополнительную функциональность. Как пример, напишем декоратор, который печатает аргументы вызываемой функции и результат её выполнения:
\begin{pylst}{}{}
def debug(func):
    def wrapped(*args, **kwargs):
        print "%s called with: %s, %s" % (func.__name__, args, kwargs)
        ret = func(*args, **kwargs)
        print "%s returned: %s" % (func.__name__, ret)
        return ret
    return wrapped
\end{pylst}

Отдекорируем им функцию увеличения аргумента на единицу:
\begin{pylst}{}{}
def inc(i):
    return i + 1

inc = debug(inc)
\end{pylst}

Теперь при вызове \lstinline{inc} будет печататься отладочная информация:
\begin{pylst}{}{}
>>> inc(1)
inc called with: (1,), {}
inc returned: 2
\end{pylst}

В \emph{Python} был введён специльный \lstinline{@}-синтаксис для декораторов. Предыдущее декорирование функции можно записать следующим предпочтительным и более наглядным способом:
\begin{pylst}{}{}
@debug
def inc(i):
    return i + 1
\end{pylst}

\subsection{Примеры декораторов}
\subsubsection{Псевдокаррирование}
Каррирование или карринг (англ. currying) в информатике — преобразование функции от пары аргументов в функцию, берущую свои аргументы по одному. Напишем декоратор, который фиксирует произвольное количество аргументов функции произвольного числа аргументов:
\begin{pylst}{}{}
class curried(object):
    def __init__(self, func, *a):
        self.func = func
        self.args = a

    def __call__(self, *a):
        args = self.args + a
        if len(args) < self.func.__code__.co_argcount:
            return curried(self.func, *args)
        else:
            return self.func(*args)
\end{pylst}

Напишем банальнейшую функцию сложения двух чисел и отдекорируем её:
\begin{pylst}{}{}
@curried
def add(a, b):
    return a + b
\end{pylst}

Теперь функции можно передавать часть аргументов, которые будут фиксированы в «новой» функции меньшего числа аргументов:
\begin{pylst}{}{}
>>> add1 = add(1)
>>> add1(2)
3
\end{pylst}

\subsubsection{Синхронизация}
Допустим, мы имеем функцию. Эту функцию исполняют множество потоков, но в каждый момент времени выполняться должен лишь один поток. Для этого напишем декоратор, который захватывает взаимное исключение (lock) перед началом выполнения функции и освобождает его при завершении функции.
\begin{pylst}{}{}
def synchronized(lock):
    def wrap(f):
        def sync(*args, **kwargs):
            with lock:
                return f(*args, **kwargs)
        return sync
    return wrap
\end{pylst}

Для иллюстрации напишем функцию вывода на консоль заданных сообщений, которую отдекорируем \lstinline{synchronized} с новосозданным взаимным исключением:
\begin{pylst}{}{}
import time
import threading
import sys
lock = threading.Lock()

@synchronized(lock)
def msg(what, then):
    print what,
    sys.stdout.flush()
    time.sleep(0.5)
    print then,
    sys.stdout.flush()
\end{pylst}

Теперь запустим несколько потоков, исполняющих эту функцию с разными значениями аргументов:
\begin{pylst}{}{}
import thread

def start_threads():
    thread.start_new_thread(msg, ('A', 'B'))
    thread.start_new_thread(msg, ('C', 'D'))
    thread.start_new_thread(msg, ('E', 'F'))

>>> start_threads()
E F A B C D
>>> start_threads()
C D A B E F
\end{pylst}

Как видно, порядок букв не нарушен: за \lstinline{A} следует \lstinline{B} и т. д.

\subsubsection{Декоратор, муштрующий декораторы}
Есть проблема с декорированной функцией: например, её свойство \lstinline{__name__} больше не равно ее действительному имени после декорирования. Следующий декоратор, призванный декорировать другие декораторы, этот досадный недостаток устраняет.
\begin{pylst}{}{}
def well_behaved(decorator):
    def new(f, *args, **kwargs):
        g = decorator(f, *args, **kwargs)
        g.__name__ = f.__name__
        g.__doc__ = f.__doc__
        g.__dict__.update(f.__dict__)
        return g
    new.__name__ = decorator.__name__
    new.__doc__ = decorator.__doc__
    new.__dict__.update(decorator.__dict__)
    return new
\end{pylst}

В качестве примера отдекорируем простейшую функцию с помощью \lstinline{debug}:
\begin{pylst}{}{}
@debug
def dummy():
    "Dummy's docstring"
    pass

>>> dummy.__name__
'wrapped'
>>> dummy.__doc__
\end{pylst}

Как видно, имя совсем не \lstinline{dummy} и строка документации исчезла. После применения \lstinline{well_behaved} к \lstinline{debug} получим:
\begin{pylst}{}{}
debug = well_behaved(debug)

@debug
def dummy():
    "Dummy's docstring"
    pass

>>> dummy.__name__
'dummy'
>>> dummy.__doc__
"Dummy's docstring"
\end{pylst}

Вуаля! проблема устранена!

\subsubsection{Проверка типов аргументов функции и её результата}
Напишем два декоратора: один для проверки во время вызова типов аргументов функции, другой же — типа возвращаемого значения. Для простоты введём ограничение: пусть аргументы у функции лишь позиционные.
\begin{pylst}{}{}
@well_behaved
def accepts(*types):
    def check_types(f):
        def wrapped(*args, **kwargs):
            for (a, t) in zip(args, types):
                assert isinstance(a, t), \
                       "arg %r does not match %s" % (a, t)
            return f(*args, **kwargs)
        return wrapped
    return check_types

@well_behaved
def returns(rtype):
    def check_types(f):
        def wrapped(*args, **kwargs):
            result = f(*args, **kwargs)
            assert isinstance(result, rtype), \
                   "return value %r does not match %s" % (result, rtype)
            return result
        return wrapped
    return check_types
\end{pylst}

Напишем функцию сложения двух целых чисел с проверкой типов и проверим, всё ли работает, как ожидается:
\begin{pylst}{}{}
@accepts(int, int)
@returns(int)
def add(a, b):
    return a + b

>>> add(2, 2)
4
>>> add(2, 2.0)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/tmp/py10971mml", line 7, in wrapped
AssertionError: arg 2.0 does not match <type 'int'>
\end{pylst}

\section{Объектно-ориентированное программирование}
\label{sec:py-oop}

В \emph{Python} всё — объекты, и даже типы. Типы — экземпляры \lstinline{type}. \emph{Python} поддерживает множественное наследование и перегрузку операторов. Например, оператор \lstinline{+} можно перегрузить для объекта путём определения методов \lstinline{__add__} и \lstinline{__radd__}.

Ниже представлено простейшее определение класса:
\begin{pylst}{}{}
class klass(object):
    pass
\end{pylst}

Видно, что \lstinline{klass} отнаследован от класса \lstinline{object}. Если надо, чтобы объект наследовался от многих классов, то их следует записать через запятую. В месте указания базовых классов может быть любое выражение, лишь бы результатом его вычисления был тип. Следующее определение класса аналогично предыдущему:
\begin{pylst}{}{}
def get_object():
    return object

class klass(get_object()):
    pass
\end{pylst}

В \emph{Python} поля могут принадлежать как классу целиком, так и конкретным экземлярам класса. Проиллюстрируем для предельной ясности:
\begin{pylst}{}{}
class storage(object):
    i = 1

    def __init__(self):
        self.i = 3

>>> s = storage()
>>> storage.i += 1
>>> s.i += 1
>>> storage.i
2
>>> storage.i
4
\end{pylst}

Методу \lstinline{__init__(self)} передаётся для инициализации созданный экземляр класса \lstinline{storage}. Выражение \lstinline{self.i = 3} поэтому создаёт аттрибут вновь созданного объекта, которому присвоено значение \lstinline{3}.

Возможно использование не-очень-приватных полей:
\begin{pylst}{}{}
class klass(object):
    def __init__(self):
        self.__private = 1

>>> c = klass()
>>> c.__dict__
{'_klass__private': 1}
\end{pylst}

Как видно, происходит \emph{name mangling}: любое имя вида \lstinline{__*} внутри определения класса \lstinline{klass} преобразуется в \lstinline{_klass__*}.

Определение метода — аналогично определению функцию. Отличие в том, что метод определяется в классе и ему при вызове передаётся первым параметром экземпляр класса.
\begin{pylst}{}{}
class klass(object):
    def m(self):
        print self

>>> c = klass()
>>> c.m()
<__main__.klass object at 0x1188f10>
\end{pylst}

Так как метод всего лишь функция, то метод \lstinline{m} можно было бы определить следующим образом:
\begin{pylst}{}{}
class klass(object):
    pass

def m(self):
    print self

>>> c = klass()
>>> klass.m = m
>>> c.m()
<__main__.klass object at 0x1225990>
\end{pylst}

В \emph{Python} существуют ещё два типа методов в дополнение к обычным: \emph{статические} (\emph{static}) методы и \emph{методы класса} (\emph{class methods}). Метод класса определяется вот так вот:
\begin{pylst}{}{}
class klass(object):
    @classmethod
    def clsmethod(cls):
        print 'class:', cls

>>> c = klass()
>>> klass.clsmethod()
class: <class '__main__.klass'>
>>> c.clsmethod()
class: <class '__main__.klass'>
\end{pylst}

Как видно, методу класса первым параметром при вызове передаётся сам класс, а не экземляр класса. Статический метод определяется следующим образом:
\begin{pylst}{}{}
class klass(object):
    @staticmethod
    def staticmethod():
        print 'static'

>>> c = klass()
>>> klass.staticmethod()
static
>>> c.staticmethod()
static
\end{pylst}

Его отличие от других типов метода в том, что ему не передаётся неявно никаких дополнительных параметров при вызове.

Инициализация — и только! — происходит в методе \lstinline{__init__()}. Если надо контролировать процесс создания объекта, то следует переопределять \lstinline{__new__(cls[, ...])}, как один из вариантов.
\begin{pylst}{}{}
class complex(object):
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

>>> c = complex(5.1, 3.0)
>>> c.real, c.imag
(5.1, 3.0)
\end{pylst}

\subsection{Свойства}

В классах можно определять свойства с помощью \lstinline{property}, который имеет следующую сигнатуру:
\begin{pylst}{}{}
property(fget=None, fset=None, fdel=None, doc=None)
\end{pylst}
где \lstinline{fget} — метод для получения значения свойства; \lstinline{fset} — для установки; \lstinline{fdel} — для удаления свойства при использовании оператора \lstinline{del}; \lstinline{doc} — собственно, строка документации для свойства.

\begin{pylst}{}{}
class klass(object):
    def __init__(self):
        self._x = 0

    def getx(self):
        return self._x

    def setx(self, val):
        self._x = val

    def delx(self):
        del self._x

    x = property(getx, setx, delx, "I'm the 'x' property.")

>>> c = klass()
>>> c.x = 3
>>> c.x
3
>>> klass.x.__doc__
"I'm the 'x' property."
\end{pylst}

Также можно определить свойство используя синтаксис декораторов:
\begin{pylst}{}{}
class klass(object):
    def __init__(self):
        self._x = 0

    @property
    def x(self):
        "I'm the 'x' property."
        return self._x

    @x.setter
    def x(self, val):
        self._x = val

    @x.deleter
    def x(self):
        del self._x
\end{pylst}

Если параметр \lstinline{doc} не передан, то используется строка документации метода, используемого для доступа. Можно, например, определить свойство только для чтения, если передать \lstinline{property} только метод для чтения.

\subsection{Иерархии классов и MRO}

Для вызовы методов базовых классов из какого-либо метода следует использовать встроенную функцию \lstinline{super(type[, object-or-type])}. Типичное использование функции \lstinline{super}:
\begin{pylst}{}{}
class C(B):
    def method(self, arg):
        super(C, self).method(arg)
\end{pylst}

Аттрибут \lstinline{__mro__} типа \lstinline{type} является списком типов, который определяет по каким типам и в каком порядке будет происходить поиск нужного метода при использовании функции \lstinline{super()}. \lstinline{__mro__} может изменяться, когда изменяется иерархия наследования.
\begin{pylst}{}{}
class A(object):
    def f(self):
        print 'A'

class B(A):
    def f(self):
        print 'B'
        super(B, self).f()

class C(A):
    def f(self):
        print 'C'
        super(C, self).f()

class D(B, C):
    def f(self):
        print 'D'
        super(D, self).f()

>>> D.__mro__
(<class '__main__.D'>,
 <class '__main__.B'>,
 <class '__main__.C'>,
 <class '__main__.A'>,
 <type 'object'>)

>>> D().f()
D
B
C
A
\end{pylst}

То есть \lstinline{__mro__} содержит линеаризованный граф с уникальными элементами, чтобы ни один метод какого-либо базового класса не вызывался несколько раз, если переопределенный метод достижим по нескольким путям.

Проверять отношения наследования можно функциями \lstinline{isinstance(object, class-or-type-or-tuple)} и \lstinline{issubclass(C, B)}.
\begin{pylst}{}{}
>>> issubclass(D, D), issubclass(D, A), isinstance(D(), A)
(True, True, True)
\end{pylst}

\subsection{Специальные методы}

\subsubsection{Доступ к аттрибутам}
\begin{itemize}
  \item \lstinline{object.__getattr__(self, name)}. Вызывается, если аттрибут не найден обычном поиском. Должен вернуть имя аттрибута или же породить исключение \lstinline{AttributeError}.
  \item \lstinline{object.__setattr__(self, name, value)}. Вызывается всегда для установки значения \lstinline{value} аттрибуту с именем \lstinline{name}.
  \item \lstinline{object.__delattr__(self, name)}.
  \item \lstinline{object.__getattribute__(self, name)}. Вызывается всегда. Если порождает исключение \lstinline{AttributeError}, вызывается метод \lstinline{object.__getattr__(self, name)}.
\end{itemize}

\subsubsection{Настройка проверок экземпляров и подклассов}
\begin{itemize}
  \item \lstinline{class.__instancecheck__(self, instance)}. Возвращает \lstinline{True}, если \lstinline{instance} должен рассматриваться как экземпляр класса.
  \item \lstinline{class.__subclasscheck__(self, subclass)}. Возвращает \lstinline{True}, если \lstinline{subclass} должен рассматриваться как потомок класса.
\end{itemize}

\section{Исключения}
\label{sec:py-exceptions}

Порождаются исключения оператором \lstinline{raise}, которому передаётся объект-исключение либо же класс ислючения.
\begin{pylst}{}{}
>>> raise NameError
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError
>>> raise ValueError("Wrong value")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: Wrong value
\end{pylst}

Стандартные исключения, определённые в \emph{Python}, перечислены в документации по адресу: \url{http://docs.python.org/library/exceptions.html}.

\subsubsection{Исключения, определённые пользователем}
Для определения нового типа исключения, следует определить новый класс, который является — явно или неявно — потомком класса \lstinline{Exception}.
\begin{pylst}{}{}
class MyError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

>>> try:
...     raise MyError(2 * 2)
... except MyError as e:
...     print 'My exception occurred, value:', e.value
...
My exception occurred, value: 4

>>> raise MyError('oops!')
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
__main__.MyError: 'oops!'
\end{pylst}

\subsubsection{Обработка исключений}
Обработка исключений рассмотрена в секции~«\nameref{sec:py-try-stmt}» на стр.~\pageref{sec:py-try-stmt}.

\section{Итераторы и генераторы}
\label{sec:py-iterators}

\subsubsection{Итераторы}
\emph{Итератор} — объект, представляющий собой поток данных. Каждый вызов метода \lstinline{__next__()} этого объекта возвращает следующую порцию данных. Когда же данных больше нет, он должен порождать исключение \lstinline{StopIteration}.

Для реализации итерирования необходимо переопределить метод \lstinline{__iter__()}, который возвращает объект с реализованными методами \lstinline{__iter__()} и \lstinline{next()}. Метод \lstinline{__iter__()} итератора должен возвращать сам же итератор, чтобы как объекты, так и итераторы можно было использовать, например, с оператором \lstinline{for}.

Ниже представлена реализация счётчика-итератора, который возвращает все целые числа от нуля до \lstinline{limit}:
\begin{pylst}{}{}
class counter(object):
    def __init__(self, limit):
        assert limit >= 0
        self._limit = limit
        self._value = 0

    def __iter__(self):
        return self

    def next(self):
        if self._value < self._limit:
            self._value += 1
            return self._value - 1
        else:
            raise StopIteration

>>> [i for i in counter(10)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{pylst}

Для удобного создания итераторов и работы с ними в \emph{Python} есть модуль \lstinline{itertools}. Вот некоторые из частоиспользуемых функцией этого модуля:

\lstinline{count(start=0, step=1)}. Бесконечная последовательность чисел, начиная с \lstinline{start}, с шагом \lstinline{step}.
\begin{pylst}{}{}
>>> import itertools
>>> i = itertools.count(1, 1.5)
>>> i.next()
1
>>> i.next()
2.5
\end{pylst}

\lstinline{cycle(iterable)}. Бесконечная последовательность, состоящая из повторяемых по кругу элементов итератора \lstinline{iterable}.
\begin{pylst}{}{}
>>> i = itertools.cycle('ABCD')
>>> for j, k in enumerate(i):
...     print k,
...     if j > 7:
...         break
A B C D A B C D A
\end{pylst}

\lstinline{repeat(object[, times])}. Возвращает объект либо бесконечное число раз, либо \lstinline{times} раз.
\begin{pylst}{}{}
>>> i = itertools.repeat(1, 5)
>>> list(i)
[1, 1, 1, 1, 1]
\end{pylst}

\lstinline{chain(*iterables)}. Возвращает последовательно элементы всех итераторов \lstinline{iterables}.
\begin{pylst}{}{}
>>> i = itertools.chain(xrange(3), xrange(3, 6), xrange(6, 9))
>>> list(i)
[0, 1, 2, 3, 4, 5, 6, 7, 8]
\end{pylst}

\lstinline{dropwhile(predicate, iterable)}. Отбрасывает элементы до тех пор, пока функция-предикат \lstinline{predicate} возвращает истину. После чего возвращает все оставшиеся элементы \lstinline{iterable}.
\begin{pylst}{}{}
>>> i = itertools.dropwhile(lambda x: x < 5, xrange(10))
>>> list(i)
[5, 6, 7, 8, 9]
\end{pylst}

\lstinline{takewhile(predicate, iterable)}. Возвращает элементы из \lstinline{iterable} до тех пор, пока функция-предикат \lstinline{predicate}, применённая к очередному элементу, возвращает истину.
\begin{pylst}{}{}
>>> i = itertools.takewhile(lambda x: x < 5, xrange(10))
>>> list(i)
[0, 1, 2, 3, 4]
\end{pylst}

\lstinline{ifilter(function or None, sequence)}. Аналог функции \lstinline{filter} с тем лишь отличием, что возвращает итератор.
\begin{pylst}{}{}
>>> i = itertools.ifilter(None, [1, 0, 2, 0, 3])
>>> list(i)
[1, 2, 3]
\end{pylst}

\lstinline{imap(function, *iterables)}. Аналог функции \lstinline{map}. Отличия: возвращает итератор и останавливается, как только один из итераторов \lstinline{iterables} заканчивается.
\begin{pylst}{}{}
>>> i = itertools.imap(lambda x, y: x + y, [1, 2, 3, 4], [2, 3, 4])
>>> list(i)
[3, 5, 7]
\end{pylst}

\lstinline{izip(*iterables)}. Возвращает итератор кортежей, в которых $i$-ым элементом является следующий элемент из $i$-ого итератора \lstinline{iterables}. Проделывает это, пока все итераторы возвращают объекты.
\begin{pylst}{}{}
>>> i = itertools.izip(xrange(5), xrange(1, 5))
>>> list(i)
[(0, 1), (1, 2), (2, 3), (3, 4)]
\end{pylst}

\subsubsection{Генераторы}
Генераторы позволяют удобно реализовывать протокол итератора. Генератор есть функция, в которой используется оператор \lstinline{yield}, то есть для определения генератора достаточно просто записать оператор \lstinline{yield} в теле функции, это не имеет никакого отношения к времени исполнения.

При вызове генератора возвращается итератор (технически, объект-генератор). Когда вызывается какой-либо метод итератора, начинается выполнение до первого встреченного оператора \lstinline{yield}, выполнение приостанавливается, запоминается точка возврата, и, наконец, возвращается значение при операторе \lstinline{yield}. При следующем вызове итератора выполнение начинается с точки останова. Так продолжается до тех пор, пока генератор не завершится любым отличным от оператора \lstinline{yield} способом (достигнет конца тела функции, при помощи оператора \lstinline{return}, исключительная ситуация).

В объекте-генераторе определены следующие методы:
\begin{itemize}
  \item \lstinline{next()}. Начинает выполнение функции-генераторы сначала или же вместе останова, если таковой присутствовал. Если выполнение начинается с точки останова, то текущий оператор \lstinline{yield} вычисляется в \lstinline{None}, и вычисление продолжается дальше. Если функция завершается не посредством \lstinline{yield}, то порождается исключение \lstinline{StopIteration}.

  \item \lstinline{send(value)}. Возобновляет выполнение и передает значение \lstinline{value} в точку останова. \lstinline{value} подставляется вместо текущего оператора \lstinline{yield}. Возвращает следующее значение, которое вернул оператор \lstinline{yield}, или порождает исключение \lstinline{StopIteration}, если функция-генератор завершилась другим способом. Если \lstinline{send(value)} вызывается для пуска генератора, то \lstinline{value} должно быть \lstinline{None}.
  \item \lstinline{throw(type[, value[, traceback]])}. Порождает исключение типа \lstinline{type} там, где функция-генератор была остановлена, и возвращает следующее значение, которая вернет функция-генератор. Если функция просто завершается, то порождается исключение \lstinline{StopIteration}.
  \item \lstinline{close()}. Порождает исключение \lstinline{GeneratorExit} в месте останова. Если функция-генератор затем порождает \lstinline{StopIteration} (или завершаясь нормально, или если уже была завершена) или \lstinline{GeneratorExit} (просто не обрабатывая его), происходит возврат из \lstinline{close}. Если функция возвращает значение оператором \lstinline{yield}, то возникает исключение \lstinline{RuntimeError}.
\end{itemize}

\begin{pylst}{}{}
def infinite(i):
    while True:
        yield i

>>> g = infinite(5)
>>> g.next()
5
>>> g.next()
5
\end{pylst}

С помощью генераторов можно реализовать, например, координатор сопрограмм (coroutines). Сопрограмма --- компонент программы, обобщающий понятие подпрограммы, который дополнительно поддерживает множество входных точек и остановку и продолжение выполнения.
\begin{pylst}{Из PEP 342}{}
import collections
import sys
import types

class Trampoline(object):
    def __init__(self):
        self.running = False
        self.queue = collections.deque()

    def add(self, coroutine):
        self.schedule(coroutine)

    def run(self):
        result = None
        self.running = True
        try:
            while self.running and self.queue:
                func = self.queue.popleft()
                return func()
            return result
        finally:
            self.running = False

    def stop(self):
        self.running = False

    def schedule(self, coroutine, stack=(), val=None, *exc):
        def resume():
            try:
                if exc:
                    value = coroutine.throw(val, *exc)
                else:
                    value = coroutine.send(val)
            except:
                if stack:
                    # send the error back to the co-caller
                    self.schedule(stack[0], stack[1], *sys.exc_info())
                else:
                    # propogate it to the real caller
                    raise

            if isinstance(value, types.GeneratorType):
                # push the new coroutine and call the new one
                self.schedule(value, (coroutine, stack))
            elif stack:
                # got a result, pop the stack and send the result
                # to the caller
                self.schedule(stack[0], stack[1], value)
            # else: this co-routine has ended

        self.queue.append(resume)

# simple echo server giving that we have non-blocking operations

# coroutine function that echos data back on a connected socket
def echo_handler(sock):
    while True:
        try:
            data = yield nonblocking_read(sock)
            yield nonblocking_write(sock, data)
        except ConnectionLost:
            pass  # exit normally if connection lost

# coroutine function that listens for connections on a
# socket, and then launches a service "handler" coroutine
# to service the connection
def listen_on(trampoline, sock, handler):
    while True:
        # get the next incoming connection
        connected_socket = yield nonblocking_accept(sock)

        # start another coroutine to handle the connection
        trampoline.add(handler(connected_socket))

# Create a scheduler to manage all our coroutines
trampoline = Trampoline()

# Create a coroutine instance to run the echo_handler on
# incoming connections

# Add the coroutine to the scheduler
trampoline.add(listen_on(trampoline,
                         listening_socket("localhost", "echo"),
                         echo_handler))

# loop forever, accepting connections and servicing them
trampoline.run()
\end{pylst}

\subsubsection{Генераторные выражения}
Генераторное выражение --- выражение, которое возвращает итератор. Выглядит, как списковое включение, лишь с тем отличием, что вместо квадратных скобок используются круглые.
\begin{pylst}{}{}
>>> sum(i*i for i in range(10))
285
\end{pylst}

\section{Дескрипторы}
\label{sec:py-descriptors}

\emph{Дескриптор} — это объект, который реализует хотя бы один из нижеперечисленных методов. Эти методы вызываются при доступе к аттрибуту класса \lstinline{owner}, когда значением аттрибута является объект-дескриптор.
\begin{itemize}
  \item \lstinline{d.__get__(self, instance, owner)}. Здесь \lstinline{owner} — класс, которому принадлежит дескриптор \lstinline{d}. \lstinline{instance} равен либо экземляру класса, если доступ производится через экземпляр, либо \lstinline{None}, если доступ — через класс \lstinline{owner}. Этот метод должен возвратить значение аттрибута либо породить исключение \lstinline{AttributeError}.
  \item \lstinline{d.__set__(self, instance, value)}. Вызывается для установки нового значения \lstinline{value} для аттрибута экземпляра класса \lstinline{instance}.
  \item \lstinline{d.__delete__(self, instance)}. Вызывается для удаления аттрибута, который принадлежит экземпляру \lstinline{instance}.
\end{itemize}

При поиске обычного аттрибута \lstinline{x} у объекта \lstinline{a} происходит следующее: сначала проверяется \lstinline{a.__dict__['x']}, затем \lstinline{type(a).__dict__['x']}, после чего повторяется тоже самое и с базовыми классами до тех пор, пока не будет найден аттрибут. Если аттрибута не оказалось, то — исключение \lstinline{AttributeError}.

Если же аттрибут \lstinline{x} объекта \lstinline{a} — дескриптор, то выражение \lstinline{a.x} будет преобразовано в \lstinline{type(a).__dict__['x'].__get__(a, type(a))}, если \lstinline{a} — экземпляр, и в \lstinline{a.__dict__['x'].__get__(None, a)}, если \lstinline{a} является классом.

Напишем простейший дескриптор для демонстрации вызовов методов:
\begin{pylst}{}{}
class RevealAccess(object):
    def __init__(self, initval=None, name='var'):
        self.val = initval
        self.name = name

    def __get__(self, obj, objtype):
        print 'Retrieving', self.name
        return self.val

    def __set__(self, obj, val):
        print 'Updating', self.name
        self.val = val

>>> class MyClass(object):
    x = RevealAccess(10, 'x')
    y = 5

>>> m = MyClass()
>>> m.x
Retrieving x
10
>>> m.x = 20
Updating var "x"
>>> m.x
Retrieving var "x"
20
>>> m.y
5
\end{pylst}

Видно по печати, что при доступе к аттрибуту \lstinline{x} вызываются соответствующие методы дескриптора.

С помощью дескрипторов в \emph{Python} реализованы свойства. Следом — подобная реализация:
\begin{pylst}{}{}
class Property(object):
    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel

        if fget is not None:
            self.__doc__ = fget.__doc__
        else:
            self.__doc__ = doc

    def __get__(self, obj, klass=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError, "unreadble attribute"
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError, "unsetable attribute"
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError, "undeletable attribute"
        self.fdel(obj)
\end{pylst}

\lstinline{staticmethod} и \lstinline{classmethod} также реализованы дескрипторами:
\begin{pylst}{}{}
class StaticMethod(object):
    def __init__(self, fn):
        self.fn = fn

    def __get__(self, obj, klass=None):
        return self.fn

class ClassMethod(object):
     def __init__(self, fn):
          self.fn = fn

     def __get__(self, obj, klass=None):
          if klass is None:
               klass = type(obj)
          def m(*args):
               return self.fn(klass, *args)
          return m
\end{pylst}

Как пример напишем дескриптор для проверки типа значения:
\begin{pylst}{}{}
class WellTyped(object):
    of_type = object

    def __init__(self, default):
        self._check(default)
        self._default = default
        self._value   = dict()

    def __get__(self, obj, klass=None):
        if obj is None:
            return self
        if obj in self._value:
            return self._value[obj]
        else:
            return self._default

    def __set__(self, obj, val):
        self._check(val)
        self._value[obj] = val

    def _check(self, val):
        if not isinstance(val, self.of_type):
            raise ValueError

class Int(WellTyped):
    of_type = int

class Str(WellTyped):
    of_type = str

class PositiveInt(Int):
    def _check(self, val):
        super(PositiveInt, self)._check(val)
        if val < 0:
            raise ValueError
\end{pylst}

Проверим, работает ли, как ожидается:
\begin{pylst}{}{}
>>> t = Test()
>>> t.i = 1.0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/tmp/py6835YLA", line 19, in __set__
  File "/tmp/py6835YLA", line 24, in _check
ValueError
>>> t.i = 2
>>> t.i
2
>>> t.pi = -1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/tmp/py6835YLA", line 19, in __set__
  File "/tmp/py6835YLA", line 36, in _check
ValueError
\end{pylst}

\section{Метаклассы}
В \emph{Python} классы — такие же объекты, как и всё остальное. Их можно передавать в качестве аргументов функциям или рассматривать под микроскопом.
\begin{pylst}{}{}
>>> class klass(object):
...     pass

>>> c = klass()
>>> c
<__main__.klass object at 0xc14a90>
>>> klass
<class '__main__.klass'>
>>> id(klass)
12861152
\end{pylst}

Функция \lstinline{id} возвращает адрес объекта в памяти, и, как видно, класс является тоже объектом, размещённым в памяти во  время исполнения.

Так же как класс определяет поведение объектов, так и метакласс определяет поведение своих классов. Самый распростаненный метакласс в Python — \lstinline{type}.

\begin{pylst}{}{}
>>> object.__class__
<type 'type'>
>>> type(object)
<type 'type'>
\end{pylst}

Метаклассом следующих базовых типов данных является \lstinline{type}:
\begin{pylst}{}{}
>>> int.__class__
<type 'type'>
>>> str.__class__
<type 'type'>
>>> tuple.__class__
<type 'type'>
>>> list.__class__
<type 'type'>
\end{pylst}

Когда \emph{Python} создаёт новый класс (при выполнении оператора \lstinline{class}), он вызывает метакласс. Метакласс в свою очередь может поместить класс в какой-нибудь регистр или же вернуть \emph{совсем} другой класс. Для подавляющего большинства — если не всех — встроенных типов метаклассом является метакласс \lstinline{type}. С помощью этого метакласса можно создать класс, аналогично оператору \lstinline{class}.

\begin{pylst}{}{}
# prototype
type(name, bases, dict)
\end{pylst}
где \lstinline{name} — имя нового класса, \lstinline{bases} — последовательность базовый классов (может быть пустой), а \lstinline{dict} — словарь, ключи которого являются именами аттрибутов создаваемого класса, а значения — значениями этих аттрибутов.

Определение
\begin{pylst}{}{}
class MyClass(BaseClass):
    attribute = 42
\end{pylst}
эквивалентно
\begin{pylst}{}{}
MyClass = type("MyClass", (BaseClass,), { 'attribute' : 42 })
\end{pylst}

Метакласс для класса указывается с помощью поля \lstinline{__metaclass__}. В метаклассе можно (пере)определять любые методы, как и в любом классе, с тем отличием, что методам класса передается экземпляр первым аргументом (отсюда и общеупотребимое \lstinline{self}), а методам метакласса — класс. Поэтому первый аргумент часто именуется \lstinline{cls}.

Напишем, метакласс, который будет демонстрировать время вызова некоторых методов.
\begin{pylst}{}{}
>>> class UselessType(type):
...     def __new__(metacls, name, bases, dct):
...         print "Allocating memory for class", name
...         return super(UselessType, metacls).__new__(metacls, name, bases, dct)
...
...     def __init__(cls, name, bases, dct):
...         print "Initing (configuring) class", name
...         super(UselessType, cls).__init__(name, bases, dct)
...
...     def __call__(cls, *args, **kwargs):
...         print "Calling %s" % cls.__name__
...         return super(UselessType, cls).__call__(*args, **kwargs)
...
...     def whoami(cls):
...         print cls.__name__

>>> class UselessClass(object):
...     __metaclass__ = UselessType

Allocating memory for class UselessClass
Initing (configuring) class UselessClass

>>> u = UselessClass()
Calling UselessClass

>>> UselessClass.whoami()
UselessClass
>>> u.whoami()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'UselessClass' object has no attribute 'whoami'
\end{pylst}

Как видим, методы \lstinline{__new__} и \lstinline{__init__} метакласса вызываются при создании класса. Метод же \lstinline{__call__} метакласса вызывается при создании экземпляра класса.

Когда выполняется оператор \lstinline{class}, Python вначале выполняет внутреннее содержимое как обычный блок кода. В результате получается пространство имен, представленное словарем. Затем Python ищет метакласс для создаваемого класса в следующей последовательности:
\begin{enumerate}
  \item Если \lstinline{dict['__metaclass__']} существуют, то используется он.
  \item В ином случае, если у класса есть базовые классы, их метакласс используется (сначала проверяется аттрибут \lstinline{__class__}, и если такого нет, то используется тип базового класса).
  \item В ином случае, если есть глобальная переменная \lstinline{__metaclass__}, то используется она.
\end{enumerate}

После чего метакласс вызывается с именем вновь создаваемого класса, его базовыми классами и словарем аттрибутов как аргументами.

Полю \lstinline{__metaclass__} можно присваивать не только метаклассы, но и \emph{любой вызываемый} (\emph{callable}) объект, который принимает три аргумента.
\begin{pylst}{}{}
def meta(name, bases, dct):
    # setting useless attr
    dct['foo'] = 'bar'
    return type(name, bases, dct)

class Bar(object):
    __metaclass__ = meta

>>> Bar().foo
'bar'
\end{pylst}

Следом идет реализация паттерна \emph{Singleton} с помощью метакласса:
\begin{pylst}{}{}
class SingletonMetaclass(type):
    instance = None

    def __call__(cls, *args, **kwargs):
        if cls.instance is None:
            cls.instance = super(SingletonMetaclass, cls).__call__(
                *args, **kwargs)
        return cls.instance

class Foo(object):
     __metaclass__ = SingletonMetaclass

>>> Foo() is Foo()
True
\end{pylst}

Как говорится в руководстве по \emph{Python}, области применения метаклассов безграничны, что, конечно же, является бесстыдным враньём. Вот несколько из общеизвестных применений: ведение журнала событий, проверка интерфейсов, автоматическое делегирование, автоматическое создание свойств класса, прокси, ORM и автоматическая синхронизация/захват ресурса.

Для примера напишем метакласс, который инициализирует некоторые аттрибуты вновь создаваемого класса, беря значения из файла, указанного в переменной класса \lstinline{dump_file}, который хранится в формате \emph{JSON}.
\begin{pylst}{}{}
import json

class InitFromDumpMeta(type):
    def __new__(metacls, name, bases, dct):
        if 'dump_file' in dct:
            try:
                dump_file = file(dct['dump_file'])
                dump = json.load(dump_file)
            except (IOError, ValueError):
                pass
            else:
                dct.update(dump)

        return super(InitFromDumpMeta, metacls).__new__(metacls, name, bases, dct)
\end{pylst}

Имея файл \lstinline{/tmp/dump.json} со следующим содержимым:
\begin{plainlst}{}{}
{ "one" : 1, "two" : 2 }
\end{plainlst}
и определив следующий класс:
\begin{pylst}{}{}
class InitFromDumpClass(object):
    __metaclass__ = InitFromDumpMeta

    dump_file = '/tmp/dump.json'
\end{pylst}
получим:
\begin{pylst}{}{}
>>> InitFromDumpClass.one
1
>>> InitFromDumpClass.two
2
\end{pylst}

\section{Интроспекция}
\label{sec:py-introspection}

В \emph{Python} можно получить подробную информацию о внутренней структуре любого объекта и среды исполнения. Необходимые для интроспекции данные хранятся в специальных атрибутах. Так, например, получить все пользовательские атрибуты большинства объектов можно из специального атрибута — словаря (или объекта, предоставляющего \lstinline{dict} интерфейс) \lstinline{__dict__}.
\begin{pylst}{}{}
class klass(object):
    pass

>>> c = klass()
>>> c.attr = 'some'
>>> print c.__dict__
{'attr': 'some'}
>>> print klass.__dict__
{'__dict__': <attribute '__dict__' of 'klass' objects>,
 '__module__': '__main__',
 '__weakref__': <attribute '__weakref__' of 'klass' objects>,
 '__doc__': None}
\end{pylst}

Аналогично можно исследовать, например, иерархию наследования классов:
\begin{pylst}{}{}
class BaseA(object):
    pass

class BaseB(object):
    pass

class Child(BaseA, BaseB):
    pass

>>> c = Child()
>>> c.__class__
<class '__main__.Child'>
>>> c.__class__.__base__
<class '__main__.BaseA'>
>>> c.__class__.__bases__
(<class '__main__.BaseA'>, <class '__main__.BaseB'>)
>>> c.__class__.__mro__
(<class '__main__.Child'>,
 <class '__main__.BaseA'>,
 <class '__main__.BaseB'>,
 <type 'object'>)
\end{pylst}

Для более удобного получения информации о внутреннем устройстве различных объектов был введён модуль \lstinline{inspect}.
\begin{pylst}{}{}
import inspect

def f(a, b, c=3):
    return a + b + c

>>> inspect.getargspec(f)
ArgSpec(args=['a', 'b', 'c'], varargs=None, keywords=None, defaults=(3,))
>>> f.func_code.co_code
'|\x00\x00|\x01\x00\x17|\x02\x00\x17S'
\end{pylst}

\begin{thebibliography}{9}

\bibitem{python:pilgrim09}
  M. Pilgrim,
  \emph{Dive into Python 3}.
  Apress,
  2nd ed.,
  2009.

\bibitem{python:officialtutorial}
  \emph{Official Python Tutorial}.
  \url{http://docs.python.org/tutorial/index.html}.

\bibitem{python:officialtutorial}
  \emph{Python Library Reference}.
  \url{http://docs.python.org/library/index.html}.

\bibitem{python:officialtutorial}
  \emph{Python Language Reference}.
  \url{http://docs.python.org/reference/index.html}.

\end{thebibliography}
