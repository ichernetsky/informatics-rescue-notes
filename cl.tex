\chapter{Введение в Common Lisp}
\label{ch:cl}
На вопрос о том, а надо ли оно, ответ приходит после медитации над следующими положениями:
\begin{itemize}
  \item программируемый язык программирования;
  \item код есть данные;
  \item предельно динамичный;
  \item мультипарадигменный;
  \item идеален для инкрементальной интерактивной разработки;
  \item макросы;
  \item условия и перезапуски (ошибки можно отлаживать интерактивно!);
  \item мощная объектная система, \emph{CLOS};
  \item метаобъектный протокол.
\end{itemize}

\section{Функции}
В простейшем случае функции определяются с помощью макроса \lstinline{DEFUN}. Типичное определение функции:

\begin{cllst}{}{}
(defun function-name (parameter*)
  "Optional documentation string"
  body*)
\end{cllst}

Как правило, имена функций содержат только буквы, цифры и знак ``минус''. Иногда имя может содержать даже пробельный символ.

Список параметров функции определяет переменные, которые будут использоваться для хранения аргументов, переданных при вызове функции. Различают обязательные, необязательные, множественные, и именованные (keyword) параметры.

За списком параметров может находиться строка, которая описывает назначение функции. После того, как функция определена, эта строка (строка документации) будет ассоциирована с именем функции и может быть позже получена с помощью функции \lstinline{DOCUMENTATION}.

Тело \lstinline{DEFUN} состоит из любого числа выражений CL. При вызове функции они вычисляются по порядку, и результат вычисления последнего выражения возвращается, как значение функции. Для возврата из любой точки функции может использоваться специальный оператор \lstinline{RETURN-FROM}.
\begin{cllst}{}{}
(defun verbose-sum (x y)
  "Sum any two numbers after printing a message."
  (format t "Summing ~d and ~d.~%" x y)
  (+ x y))(defun foo ()

(documentation 'verbose-sum 'function) => "Sum any two numbers after printing a message."
\end{cllst}

\subsection{Параметры функций}
Есть несколько типов параметров функций.

\subsubsection{Обязательные параметры}
Если список параметров является простым списком символов (имён переменных), то параметры называются обязательными. Когда функция вызывается, её должно быть передано ровно по одному аргументу для каждого из обязательных параметров. Каждый параметр связывается с соответствующим аргументом. Если функция вызывается с меньшим или большим количеством аргументов, чем требуется, то CL сообщит об ошибке.

\subsubsection{Необязательные параметры}
Параметры могут иметь значения по умолчанию. При вызове функции можно не использовать такие параметры.
\begin{cllst}{}{}
(defun foo (a b &optional c d) 
  (list a b c d))

(foo 1 2)     => (1 2 NIL NIL)
(foo 1 2 3)   => (1 2 3 NIL)
(foo 1 2 3 4) => (1 2 3 4)
\end{cllst}

Если значение по умолчанию не указано при определении функции, то значением по умолчанию является \lstinline{NIL}. Значение по умолчанию задаётся заменой имени параметра на список, состоящий из имени и выражения. Выражение будет вычислено при вызове функции, если вызывающий не указал значения для данного параметра.
\begin{cllst}{}{}
(defun foo (a &optional (b 10)) 
    (list a b))

(foo 1 2) => (1 2)
(foo 1)   => (1 10)
\end{cllst}

В выражениях, используемых для определения необязательных параметров, можно ссылаться на параметры, ранее встречавшиеся в списке параметров.
\begin{cllst}{}{}
(defun make-rectangle (width &optional (height width)) 
  ...)
\end{cllst}

Иногда необходимо знать, задано ли значение необязательного параметра вызывающей стороной или используется значение по умолчанию. Для этого надо добавить в список, определяющий параметр, третьим элементом имя переменной. Новая переменная будет равна \lstinline{T}, если вызывающая сторона задала значение по умолчанию при вызове, и будет равна \lstinline{NIL} в ином случае.
\begin{cllst}{}{}
(defun foo (a b &optional (c 3 c-supplied-p))
  (list a b c c-supplied-p))

(foo 1 2)   => (1 2 3 NIL)
(foo 1 2 3) => (1 2 3 T)
(foo 1 2 4) => (1 2 4 T)
\end{cllst}

\subsubsection{Остаточный (rest) параметр}
Если требуется определить функцию, которой можно передавать переменное количество аргументов, можно указать остаточный параметр. Этот параметр будет равен списку всех аргументов, которые остались после связывания обязательных и необязательных параметров.
\begin{cllst}{}{}
(defun + (&rest numbers) ...)
\end{cllst}

\subsubsection{Именованные параметры}
Для того, чтобы задать именованные параметры, необходимо после всех требуемых, необязательных и остаточных параметров, указать символ \lstinline{&key} и затем перечислить любое количество спецификаторов именованных параметров.
\begin{cllst}{}{}
(defun foo (&key a b c) 
  (list a b c))

(foo)                => (NIL NIL NIL)
(foo :a 1)           => (1 NIL NIL)
(foo :b 1)           => (NIL 1 NIL)
(foo :c 1)           => (NIL NIL 1)
(foo :a 1 :c 3)      => (1 NIL 3)
(foo :a 1 :b 2 :c 3) => (1 2 3)
(foo :a 1 :c 3 :b 2) => (1 2 3)
\end{cllst}

Также как и для необязательных параметров, для именованных параметров можно задавать выражение для вычисления значения по умолчанию и имя supplied-p-переменной. Также в варажении, которое используется для вычисления значения по умолчанию, можно ссылаться на параметры, указанные ранее.
\begin{cllst}{}{}
(defun foo (&key (a 0) (b 0 b-supplied-p) (c (+ a b)))
  (list a b c b-supplied-p))

(foo :a 1)           => (1 0 1 NIL)
(foo :b 1)           => (0 1 1 T)
(foo :b 1 :c 4)      => (0 1 4 T)
(foo :a 2 :b 1 :c 4) => (2 1 4 T)
\end{cllst}

Также если необходимо, чтобы вызывающий использовал имена аргументов, отличающиеся от имен параметров, то вы можете заменить имя параметра на список, содержащий имя, которое будет использоваться при вызове, и имя параметра.
\begin{cllst}{}{}
(defun foo (&key ((:apple a)) ((:box b) 0) ((:charlie c) 0 c-supplied-p))
  (list a b c c-supplied-p))

(foo :apple 10 :box 20 :charlie 30) => (10 20 30 T)
\end{cllst}

\subsubsection{Совместное использование различных типов параметров}
Использование всех четырех типов параметров в одной функции хоть и возможно, но встречается редко. Когда используется более одного типа параметров, они должны быть объявлены в порядке, в котором они обсуждались здесь: сначала идут обязательные параметры, затем — необязательные, потом — остаточный, и в заключение — именованные. Но обычно в функциях, которые используют несколько типов параметров, комбинируют обязательные параметры с одним из других типов параметров. Или используют вместе необязательные и остаточные параметры. Два других сочетания – необязательных или остаточных параметров с именованными параметрами — могут привести к очень удивительному поведению функции.
\begin{cllst}{}{}
(defun foo (x &optional y &key z) 
  (list x y z))

(foo 1 2 :z 3) => (1 2 3)
(foo 1)        => (1 nil nil)
(foo 1 :z 3)   => ERROR

(defun foo (&rest rest &key a b c) 
    (list rest a b c))

(foo :a 1 :b 2 :c 3)  => ((:A 1 :B 2 :C 3) 1 2 3)
\end{cllst}

\subsection{Возврат значений из функций}
Как правило, результатом вычисления функции является результат последнего вычисленного выражения в теле функции. Иногда необходимы исключения из этого правила. Для этого можно использовать специальный оператор \lstinline{RETURN-FROM}, который предназначен для немедленного возвращения любого значения из функции.
\begin{cllst}{}{}
(defun foo (n)
  (dotimes (i 10)
    (dotimes (j 10)
      (when (> (* i j) n)
        (return-from foo (list i j))))))
\end{cllst}

\subsection{Функции высшего порядка}
В CL функции являются первоклассными объектами. При определение функции с помощью \lstinline{DEFUN} происходит две вещи:
\begin{enumerate}
  \item Создаётся новый объект-функция.
  \item Создаётся новое имя, с которым ассоциирован объект-функция.
\end{enumerate}

Чтобы получить объект-функцию по имени нужно использовать \lstinline{FUNCTION} или же \lstinline{#'}.
\begin{cllst}{}{}
(defun foo (x) (* 2 x))

(function foo) => #<FUNCTION FOO>
#'foo          => #<FUNCTION FOO>
\end{cllst}

Полученный объект-функцию можно выполнить, используя \lstinline{FUNCALL} или \lstinline{APPLY}. Они отличаются тем, как они получают аргументы, которые будут переданы вызываемой функции. \lstinline{FUNCALL} — это функция, используемая, когда известно количество аргументов, которые будут переданы функции. Первым аргументом \lstinline{FUNCALL} является запускаемый объект-функция, а оставшиеся аргументы передаются данному объекту-функции при вызове.

Следующая функция демонстрирует использование \lstinline{FUNCALL}. Она принимает объект-функцию в качестве аргумента и рисует простую текстовую диаграмму значений, возвращенных переданной функцией, вызываемой для значений от \lstinline{min} до \lstinline{max} с шагом \lstinline{step}.
\begin{cllst}{}{}
(defun plot (fn min max step)
  (loop for i from min to max by step do
        (loop repeat (funcall fn i) do (format t "*"))
        (format t "~%")))

CL-USER> (plot #'exp 0 4 1/2)
*
*
**
****
*******
************
********************
*********************************
******************************************************
NIL
\end{cllst}

Первым аргументом \lstinline{APPLY} является также объект-функция, а вторым аргументом она принимает список. Затем \lstinline{APPLY} применяет объект-функцию к значениям в списке.
\begin{cllst}{}{}
(apply #'plot '(#'exp 0 4 1/2))
(apply #'plot #'exp '(0 4 1/2))
\end{cllst}

\subsection{Анонимные функции}
Анонимные функции определяются с помощью \lstinline{LAMBDA}.
\begin{cllst}{}{}
(lambda (parameters) body)

(funcall #'(lambda (x y) (+ x y)) 2 3) => 5
((lambda (x y) (+ x y)) 2 3)           => 5
\end{cllst}

\section{Переменные}
CL поддерживает два вида переменных: \emph{лексические} и \emph{динамические} (\emph{специальные}).

В CL переменные не типизированы. Переменная может содержать значения любого типа, а сами значения содержат информацию о типе, которая может быть использована для проверки типов во время выполнения.

Одной из форм, позволяющих вводить новые переменные, является \lstinline{LET}. Эта форма имеет следующий вид:
\begin{cllst}{}{}
(let (variable*)
  body-form*)
\end{cllst}
где каждая \lstinline{variable} является либо списком, состоящим из имени переменной и начального значения, либо просто именем переменной (в таком случае значение переменной равно \lstinline{NIL}).
\begin{cllst}{}{}
(let ((x 10) (y 20) z)
  (list x y z))         => (10 20 NIL)
\end{cllst}

Сначала вычисляются все выражения, результаты которых будут использоваться в качестве начальных значений. Затем создаются и инициализируются в начальные значения переменные. После чего выполняются формы из \lstinline{body-form*}.
\begin{cllst}{}{}
(defun foo (x)
  (format t "Parameter: ~a~%" x)
  (let ((x 2))
    (format t "External LET: ~a~%" x)
    (let ((x 3))
      (format t "Internal LET: ~a~%" x))
    (format t "External LET: ~a~%" x))
  (format t "Parameter: ~a~%" x))

CL-USER> (foo 1)
Parameter: 1
External LET: 2
Internal LET: 3
External LET: 2
Parameter: 1
NIL
\end{cllst}

Ещё одной связывающей формой является вариант \lstinline{LET}: \lstinline{LET*}. Различие состоит в том, что в \lstinline{LET} имена переменных могут быть использованы только в теле \lstinline{LET}, а в \lstinline{LET*} формы начальных значений могут ссылаться на переменные, введенные ранее.

\subsection{Замыкания и лексические переменные}

\begin{cllst}{}{}
(let ((count 0))
  (list
   #'(lambda () (incf count))
   #'(lambda () (decf count))
   #'(lambda () count)))


(funcall (first *count-fns*))  => 1
(funcall (first *count-fns*))  => 2
(funcall (second *count-fns*)) => 1
(funcall (third *count-fns*))  => 1
\end{cllst}

Анонимная функция называется \emph{замыканием (closure)}, потому что она замыкается вокруг привязки, созданной \lstinline{LET}. В замыканиях захватывается не значение переменной, а привязка. Поэтому замыкание может не только иметь доступ ко значению переменной, вокруг которой оно замкнуто, но и присваивать ей новые значения.

\subsection{Динамические (специальные) переменные}
CL предоставляет два способа создания динамических переменных: \lstinline{DEFVAR} и \lstinline{DEFPARAMETER}. Единственное отличие в том, что \lstinline{DEFVAR} не изменит значение уже определенной переменной, а \lstinline{DEFPARAMETER} — изменит. Обе формы принимают имя переменной, начальное значение и необязательную строку документации.

Принято, что имена динамических переменных начинаются и заканчиваются ``звёздочкой''.
\begin{cllst}{}{}
(defvar *count* 0 "Number of created widgets so far.")
*count* => 0
(defvar *count* 1)
*count* => 0

(defparameter *count* 2)
*count* => 2
\end{cllst}

Форма \lstinline{DEFVAR} может использоваться без начального значения для определения переменной без значения. Такая переменная называется \emph{несвязанной (unbound)}.

Присваивание нового значения динамической переменной в какой-либо связывающей форме приводит к тому, что весь код, который находится в теле этой связывающей форме, и код, который вызывается из кода в теле, будет видеть новое значение динамической переменной (отсюда и название).
\begin{cllst}{}{}
(defun hello-world ()
  (format *standard-output* "Hello, world!~%"))

CL-USER> (hello-world)
Hello, world!
NIL

(with-open-file (stream #p"/tmp/scream.txt" :direction :output)
  (let ((*standard-output* stream))
    (hello-world)))

CL-USER> (hello-world)
Hello, world!
NIL
\end{cllst}

В итоге \texttt{/tmp/scream.txt} содержит:
\begin{plainlst}{}{}
% cat scream.txt 
Hello, world!
\end{plainlst}

Также возможно локально объявить имя динамическим (специальным). Если в связывающей форме объявить имя специальным, то привязка, созданная для этой переменной, будет динамической, а не лексической. Другой код может локально определить имя специальным, чтобы обращаться к динамической привязке.

\subsection{Константы}
Все константы являются глобальными и определяются с помощью \lstinline{DEFCONSTANT}. Базовая форма \lstinline{DEFCONSTANT} подобна \lstinline{DEFPARAMETER}.
\begin{cllst}{}{}
(defconstant name initial-value-form [ documentation-string ])
\end{cllst}

К константе можно только обращаться. При попытке изменить константу зависит от реализации.

\subsection{Присваивание}
Чтобы присвоить новое значение переменной, следует использовать макрос \lstinline{SETF}, являющийся в CL оператором присваивания:
\begin{cllst}{}{}
(setf place value)
\end{cllst}

\lstinline{SETF} раскрывается (expand) в зависимости от того, чем является \lstinline{place}. Когда \lstinline{place} является переменной, то он раскрывается в вызов специальной формы \lstinline{SETQ}, который имеет доступ как лексическим, так и к динамическим переменным. \lstinline{SETF} возвращает последнее присвоенное значение.
\begin{cllst}{}{}
(defvar *x*)
(defvar *y*)

(setf *x* 10) => 10
(setf *x* 1 y 2) => 2
(setf *x* (setf *y* (random 10))) => 6
\end{cllst}

\subsubsection{Обобщённое присваивание}
Местом может быть не только привязки переменных. \lstinline{SETF} может присвоить значение любому месту (place). В CL можно присваивать, например, элементу списка.
\begin{cllst}{}{}
(let ((x 1))
  (setf x 10)
  x) => 10

(let ((x '(2 2 3)))
  (setf (first x) 1)
  x) => (1 2 3)

(let ((x #(2 2 3)))
  (setf (aref x 0) 1)
  x) => #(1 2 3)

(let ((x (make-hash-table)))
  (setf (gethash 'key x) 10)
  (gethash 'key x)) => 10
\end{cllst}

Новые места можно определять с помощью \lstinline{DEFSETF} и \lstinline{DEFINE-SETF-EXPANDER}.

\section{Примитивные типы данных}
\subsection{Числа}
CL поддерживает несколько числовых типов:
\begin{itemize}
  \item целые числа, максимальная величина которых аппаратно-зависима;
  \item целые числа произвольной величины;
  \item числа с плавающей точкой;
  \item дроби;
  \item комплексные числа.
\end{itemize}

\subsubsection{Запись}
Примеры записи и печати рациональных чисел:
\begin{cllst}{}{}
CL-USER> (list +1 -1 2/1 3/2 6/4 #xA #b01001 #b1010/1011 #o777 #36rABFG 1.)
(1 -1 2 3/2 3/2 10 9 10/11 511 481372 1)
\end{cllst}{}

Во время чтения дроби сокращаются, если это возможно. Как видно из примера, возможна запись чисел с основанием отличным от $10$. Если числу предшествует \lstinline{#B} или \lstinline{#b}, то число считывается как двоичное. Строки \lstinline{#O} или \lstinline{#o} используются для восьмеричных чисел, а \lstinline{#X} или \lstinline{#x} используются для шестнадцатеричных. Возможно записывать числа в системах с другими основаниями (от 2 до 36) с указанием префикса \lstinline{#nR}, где \lstinline{n} — основание (всегда записывается в десятичном виде). В качестве дополнительных ``цифр'' используются буквы A-Z или a-z.

Примеры записи и печати чисел с плавающей точкой:
\begin{cllst}{}{}
CL-USER> (list 1.0 1e0 1d0 0.1 .1 1e-3)
(1.0 1.0 1.0d0 0.1 0.1 0.001)
\end{cllst}

В CL есть четыре подтипа чисел с плавающей точкой: \lstinline{short}, \lstinline{single}, \lstinline{double} и \lstinline{long}. Количество бит, отведённых для представления значений каждого типа, зависит от реализации и аппаратной платформы. Маркеры экспоненты: \lstinline{s}, \lstinline{f}, \lstinline{d,} \lstinline{l} обозначают использование \lstinline{short}, \lstinline{single}, \lstinline{double} и \lstinline{long}. Буква \lstinline{e} указывает, что должно использоваться представление по умолчанию.

Примеры записи и печати комплексных чисел:
\begin{cllst}{}{}
CL-USER> (list #c(2 1) #c(2/3 3/4) #c(2 1.0) #c(2.0 1.0d0)
               #c(1/2 1.0) #c(3 0) #c(3.0 0.0) #c(1/2 0) #c(-6/3 0))
s
(#C(2 1) #C(2/3 3/4) #C(2.0 1.0) #C(2.0d0 1.0d0)
 #C(0.5 1.0) 3 #C(3.0 0.0) 1/2 -2)
\end{cllst}

Синтаксис: префикс \lstinline{#C} или \lstinline{#c}, за которым следует список из двух чисел, представляющих реальную и мнимую часть комплексного числа.

\subsubsection{Математические операции}
\begin{cllst}{}{}
(+)        => 0      (+ 1 2)    => 3
(+ 1 2 3)  => 6      (- 5 4)    => 1
(- 2)      => -2     (- 10 3 5) => 2
(*)        => 1      (* 2 3 4)  => 24
(/ 10 5 2) => 1      (/ 2 3)    => 2/3

(+ #c(1 2) 3) => #c(4 2)
\end{cllst}

В CL есть четыре вида функций для усечения и округления для вещественных чисел (рациональных или с плавающей точкой) в целые числа:
\begin{enumerate}
  \item \lstinline{FLOOR} усекает число в сторону отрицательной бесконечности, возвращая наибольшее целое, меньшее или равное аргументу.
  \item \lstinline{CEILING} усекает число в сторону положительной бесконечности, возвращая наименьшее целое, большее или равное аргументу.
  \item \lstinline{TRUNCATE} усекает число в сторону нуля, ведя себя как \lstinline{FLOOR} для положительных аргументов, и как \lstinline{CEILING} для отрицательных.
  \item \lstinline{ROUND} округляет число до ближайшего целого. Если аргумент находится ровно между двумя целыми числами, то округление происходит в сторону ближайшего четного числа.
\end{enumerate}

Функция \lstinline{MOD} и \lstinline{REM} возвращают модуль и остаток деления с усечением чисел. Эти две функции соотносятся с \lstinline{FLOOR} и \lstinline{TRUNCATE} следующим образом:
\begin{cllst}{}{}
(+ (* (floor    (/ x y)) y) (mod x y)) == x
(+ (* (truncate (/ x y)) y) (rem x y)) == x
\end{cllst}

\subsubsection{Сравнение чисел}
Функция \lstinline{=} является предикатом для проверки равенства чисел, который игнорирует разницу в типах, то есть сравнивает математически. Функции \lstinline{<}, \lstinline{>}, \lstinline{<=} и \lstinline{>=} сравнивают рациональные числа и числа с плавающей точкой.
\begin{cllst}{}{}
(= 1 1.0 #c(1.0 0.0) #c(1 0))  => T

(/= 1 1)     => NIL    (/= 1 2)       => T
(/= 1 2 3)   => T      (/= 1 2 3 1.0) => NIL
(<= 2 3 3 4) => T      (<= 2 3 4 3)   => NIL
\end{cllst}

Другими часто используемыми функциями и предикатами являются: \lstinline{ZEROP}, \lstinline{MINUSP}, \lstinline{PLUSP}, \lstinline{EVENP}, \lstinline{ODDP}, \lstinline{MIN} и \lstinline{MAX}.

\subsection{Знаки}
В CL знаки являются отдельным типом объектов, а не числами. Синтаксис чтения: префикс \lstinline{#\}, за которым следует нужный знак. После \lstinline{#\} может использоваться любой знак. Пробел и другие аналогичные знаки можно записывать другим способом: вместа знака за \lstinline{#\} следует название знака. Список поддерживаемых имен зависит от набора знаков и реализации Lisp, но все реализации поддерживают имена \lstinline{Space} и \lstinline{Newline}. Другими распространёнными, но не стандартными именами являются \lstinline{Tab}, \lstinline{Page}, \lstinline{Rubout}, \lstinline{Linefeed}, \lstinline{Return} и \lstinline{Backspace}.

Для сравнения знаков, не учитывая их регистр, следует использовать функции: \lstinline{CHAR=}, \lstinline{CHAR=/}, \lstinline{CHAR<}, \lstinline{CHAR>}, \lstinline{CHAR<=} и \lstinline{CHAR>=}. Для сравнения знаков, учитывая их регистр, следует использовать функции: \lstinline{CHAR-EQUAL}, \lstinline{CHAR-NOT-EQUAL}, \lstinline{CHAR-LESSP}, \lstinline{CHAR-GREATERP}, \lstinline{CHAR-NOT-GREATERP} и \lstinline{CHAR-NOT-LESSP}.

\subsection{Строки}
Строка является одномерным массивом знаков. Строки записываются, заключенными в двойные кавычки. Можно включить в строку любой знак, поддерживаемый набором знаков, за исключением двойной кавычки (\lstinline{"}) и обратного слеша (\lstinline{\}). Эти два знака необходимо экранировать.

Для сравнения строк, не учитывая их регистр, следует использовать функции: \lstinline{STRING=}, \lstinline{STRING=/}, \lstinline{STRING<}, \lstinline{STRING>}, \lstinline{STRING<=} и \lstinline{STRING>=}. Для сравнения строк, учитывая их регистр, следует использовать функции: \lstinline{STRING-EQUAL}, \lstinline{STRING-NOT-EQUAL}, \lstinline{STRING-LESSP}, \lstinline{STRING-GREATERP}, \lstinline{STRING-NOT-GREATERP} и \lstinline{STRING-NOT-LESSP}. Эти функции могут сравнивать только две строки, в отличии от аналогов для чисел.

Каждая из этих функций имеет четыре именованных параметра: \lstinline{:start1}, \lstinline{:end1}, \lstinline{:start2} и \lstinline{:end2}.
\begin{cllst}{}{}
(string= "foobarbaz" "quuxbarfoo" :start1 3 :end1 6 :start2 4 :end2 7) => T
\end{cllst}
