\chapter{Базовые структуры данных и алгоритмы}
\label{ch:basic-ds}

\section{$O$-нотация}
\label{sec:o-notation}

\textbf{Размер входных данных} зависит от рассматриваемой задачи.

\textbf{Время работы} алгоритма измеряется в количестве элементарных операций. Оно зависит от размера входных данных.

\textbf{Порядок роста}, или \textbf{скорость роста}. Пусть время работы алгоритма в наихудшем случае выражается формулой $an^2 + bn + c$, где $a$, $b$ и $c$ --- некоторые константы. Поскольку при больших $n$ членами меньшего порядка можно пренебречь, то рассматривается только главный член формулы $n^2$. Таким образом, время работы алгоритма в наихудшем случае равно $\Theta(n^2)$.

При \emph{асимптотическом анализе} нас интересует то, как растет время выволнения алгоритмы с увеличением размера входных данных \emph{в пределе}.

\subsection{Обозначения}
\begin{tabular}{lp{11cm}}
  \toprule
  Обозначение & Объяснение \\
  \midrule
  $f(n) \in O(g(n))$ & $f$ ограничена сверху функцией $g$ (с точностью до постоянного множителя) асимптотически \\
  $f(n) \in \Omega(g(n))$ & $f$ ограничена снизу функцией $g$ (с точностью до постоянного множителя) асимптотически \\
  $f(n) \in \Theta(g(n))$ & $f$ ограничена снизу и сверху функцией $g$ асимптотически \\
  $f(n) \in o(g(n))$ & $g$ доминирует над $f$ асимптотически \\
  $f(n) \in \omega(g(n))$ & $f$ доминирует над $g$ асимптотически \\
  \bottomrule
\end{tabular}

\subsection{Определения}
\begin{align}
  f(n) \in O(g(n)) \quad = \quad &\exists c > 0, n_0 \quad \forall n > n_0 \quad f(n) \leq c \cdot g(n),\\
  f(n) \in \Omega(g(n)) \quad = \quad &\exists c > 0, n_0 \quad \forall n > n_0 \quad c \cdot g(n) \leq f(n),\\
  f(n) \in \Theta(g(n)) \quad = \quad &\exists c_1 > 0, c_2 > 0, n_0 \quad \forall n > n_0 \nonumber\\
                                      &c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n),\\
  f(n) \in o(g(n)) \quad = \quad &\forall \varepsilon > 0 \quad \exists n_0 \quad \forall n > n_0 \quad f(n) < \varepsilon \cdot g(n),\\
  f(n) \in \omega(g(n)) \quad = \quad &\forall c > 0 \quad \exists n_0 \quad \forall n > n_0 \quad c \cdot g(n) < f(n).
\end{align}

\section{Двоичный поиск}
\label{sec:binary-search}

Алгоритм поиска элемента в отсортированном массиве. В худшем случае выполняется за $\log{n}$.

\lstset{label=lst:iter-bin-seaerch,caption=Итеративный алгоритм бинарного поиска}
\begin{lstlisting}
int binary_search (int elem, int array[], size_t length) {
  int mid, min = 0, max = length - 1;

  do {
    mid = min + ((max - min) / 2);
    if (elem > array[mid])
      min = mid + 1;
    else
      max = mid - 1;
  } while ((min <= max) && array[mid] != elem);

  if (array[mid] == elem)
    return mid;
  return -1;
}
\end{lstlisting}

\lstset{label=lst:rec-bin-seaerch,caption=Рекурсивный алгоритм бинарного поиска}
\begin{lstlisting}
int binary_search (int elem, int array[], size_t length) {
  return binary_search_aux (elem, array, 0, length - 1);
}

int binary_search_aux (int elem, int array[], int low, int high) {
  if (high < low)
    return -1;

  int mid = low + ((high - low) / 2);
  if (array[mid] > elem)
    return binary_search_aux (elem, array, low, mid - 1);
  else {
    if (array[mid] < elem)
      return binary_search_aux (elem, array, mid + 1, high);
    else
      return mid;
  }
}
\end{lstlisting}

\section{Сортировка}
\label{sec:sorting}

\section{Расширяемые массивы}
\label{sec:ext-arrays}

\section{Списки}
\label{sec:lists}

Последовательность элементов. Различают \emph{односвязный} и \emph{двусвязный} списки. В односвязном списке можем двигаться в лишь одну сторону, находясь на каком-либо элементе; в двусвязном --- в любую.
\begin{center}
  \begin{tabular}{lc}
    \toprule
    Операция & Стоимость \\
    \midrule
    Доступ к $n$-ому элементу & $\Theta(n)$ \\
    Затраты памяти & $\Theta(n)$ \\
    Вставка в начало & $\Theta(1)$ \\
    \bottomrule
  \end{tabular}
\end{center}

Ниже приведено определение списка и реализация некоторых операций над ним.

\lstset{label=lst:list-impl,caption=Некоторые операции}
\begin{lstlisting}
typedef struct list list;
struct list {
  int data;
  list *next;
};

list *new_item (int data) {
  list *new = (list *) malloc (sizeof (list));

  new->data = data;
  new->next = NULL;

  return new;
}

list *add_front (list *head, list *new) {
  new->next = head;
  return new;
}

list *add_end (list *head, list *new) {
  if (NULL == head)
    return new;

  list *p;
  for (p = head; p->next != NULL; p = p->next)
    ;
  p->next = new;
  return head;
}

void print_backwards (list *elem) {
  if (NULL == elem)
    return;

  print_backwards (elem->next);
  printf ("%x\n", elem->data);
}
\end{lstlisting}

\lstset{label=lst:list-usage,caption=Пример использования}
\begin{lstlisting}
list *head = NULL;

head = add_front (head, new_item (1));
head = add_front (head, new_item (2));
head = add_front (head, new_item (3));
head = add_end (head, new_item (4));
head = add_end (head, new_item (5));

print_backwards (head);
\end{lstlisting}

\section{Бинарные деревья поиска}
\label{sec:trees}

\textbf{Бинарное дерево} --- иерархическая структура данных. Каждый элемент содержит данные и указывает на $0..2$ других элементов. На каждый элемент, кроме \emph{корня}, указывает только один другой элемент. \emph{Листья} не указывают ни на один элемент.

\textbf{Бинарное дерево поиска} --- бинарное дерево, для каждого узла которого выполняются:
\begin{enumerate}
  \item Элементы левого поддерева ``меньше'' самого узла.
  \item Элементы правого поддерева ``больше'' самого узла.
  \item Оба поддерева -- бинарные деревья поиска.
\end{enumerate}

\begin{center}
  \begin{tabular}{lcc}
    \toprule
    Операция & Стоимость & Вырожденный случай \\
    \midrule
    Поиск элемента & $\Theta(\log n)$ & $\Theta(n)$ \\
    Затраты памяти & $\Theta(n)$ & \\
    Вставка & $\Theta(\log n)$ & $\Theta(n)$ \\
    Обход & $\Theta(n)$ & \\
    \bottomrule
  \end{tabular}
\end{center}

\lstset{label=lst:bst-impl,caption=Некоторые операции}
\begin{lstlisting}
typedef struct tree tree;
struct tree {
  int data;
  tree *left;
  tree *right;
};

tree *new_item (int data) {
  tree *new = (tree *) malloc (sizeof (tree));

  new->data = data;
  new->left = NULL;
  new->right = NULL;

  return new;
}

tree *insert (tree *root, tree *new) {
  if (NULL == root)
    return new;

  if (root->data < new->data)
    root->right = insert (root->right, new);
  else if (root->data > new->data)
    root->left = insert (root->left, new);
  /* skipping items that are already in the tree */

  return root;
}

void apply_preorder (tree *root, void (*fn) (tree *)) {
  if (NULL == root)
    return;

  (*fn) (root);
  apply_preorder (root->left, fn);
  apply_preorder (root->right, fn);
}

void print_tree (tree *root) {
  apply_preorder (root, &print_tree_aux);
}

void print_tree_aux (tree *root) {
  printf ("%d\n", root->data);
}
\end{lstlisting}

\lstset{label=lst:bst-usage,caption=Пример использования}
\begin{lstlisting}
tree *root = NULL;

root = insert (root, new_item (8));
root = insert (root, new_item (3));
root = insert (root, new_item (1));
root = insert (root, new_item (6));
root = insert (root, new_item (10));

print_tree (root);
\end{lstlisting}

\section{Хэш-таблицы}
\label{sec:hash-tables}

\section{Динамическое программирование}
\label{sec:dyn-programming}

\section{Некоторые заметки о языке C}
\label{sec:c-notes}
