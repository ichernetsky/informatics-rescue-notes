\chapter{Базовые структуры данных и алгоритмы}
\label{ch:basic-ds}

\section{$O$-нотация}
\label{sec:o-notation}

\textbf{Размер входных данных} зависит от рассматриваемой задачи.

\textbf{Время работы} алгоритма измеряется в количестве элементарных операций. Оно зависит от размера входных данных.

\textbf{Порядок роста}, или \textbf{скорость роста}. Пусть время работы алгоритма в наихудшем случае выражается формулой $an^2 + bn + c$, где $a$, $b$ и $c$ --- некоторые константы. Поскольку при больших $n$ членами меньшего порядка можно пренебречь, то рассматривается только главный член формулы $n^2$. Таким образом, время работы алгоритма в наихудшем случае равно $\Theta(n^2)$.

При \emph{асимптотическом анализе} нас интересует то, как растет время выволнения алгоритма с увеличением размера входных данных \emph{в пределе}.

\subsection{Обозначения}
\begin{tabular}{lp{11cm}}
  \toprule
  Обозначение & Объяснение \\
  \midrule
  $f(n) \in O(g(n))$ & $f$ ограничена сверху функцией $g$ (с точностью до постоянного множителя) асимптотически \\
  $f(n) \in \Omega(g(n))$ & $f$ ограничена снизу функцией $g$ (с точностью до постоянного множителя) асимптотически \\
  $f(n) \in \Theta(g(n))$ & $f$ ограничена снизу и сверху функцией $g$ асимптотически \\
  $f(n) \in o(g(n))$ & $g$ доминирует над $f$ асимптотически \\
  $f(n) \in \omega(g(n))$ & $f$ доминирует над $g$ асимптотически \\
  \bottomrule
\end{tabular}

\subsection{Определения}
\begin{align}
  f(n) \in O(g(n)) \quad = \quad &\exists c > 0, n_0 \quad \forall n > n_0 \quad f(n) \leq c \cdot g(n),\\
  f(n) \in \Omega(g(n)) \quad = \quad &\exists c > 0, n_0 \quad \forall n > n_0 \quad c \cdot g(n) \leq f(n),\\
  f(n) \in \Theta(g(n)) \quad = \quad &\exists c_1 > 0, c_2 > 0, n_0 \quad \forall n > n_0 \nonumber\\
                                      &c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n),\\
  f(n) \in o(g(n)) \quad = \quad &\forall \varepsilon > 0 \quad \exists n_0 \quad \forall n > n_0 \quad f(n) < \varepsilon \cdot g(n),\\
  f(n) \in \omega(g(n)) \quad = \quad &\forall c > 0 \quad \exists n_0 \quad \forall n > n_0 \quad c \cdot g(n) < f(n).
\end{align}

\section{Двоичный поиск}
\label{sec:binary-search}

Алгоритм поиска элемента в отсортированном массиве. В худшем случае выполняется за $\log{n}$.

\lstset{label=lst:iter-bin-seaerch,caption=Итеративный алгоритм бинарного поиска}
\begin{lstlisting}
int binary_search (int elem, int array[], size_t length) {
  int mid, min = 0, max = length - 1;

  do {
    mid = min + ((max - min) / 2);
    if (elem > array[mid])
      min = mid + 1;
    else
      max = mid - 1;
  } while ((min <= max) && array[mid] != elem);

  if (array[mid] == elem)
    return mid;
  return -1;
}
\end{lstlisting}

\lstset{label=lst:rec-bin-seaerch,caption=Рекурсивный алгоритм бинарного поиска}
\begin{lstlisting}
int binary_search (int elem, int array[], size_t length) {
  return binary_search_aux (elem, array, 0, length - 1);
}

int binary_search_aux (int elem, int array[], int low, int high) {
  if (high < low)
    return -1;

  int mid = low + ((high - low) / 2);
  if (array[mid] > elem)
    return binary_search_aux (elem, array, low, mid - 1);
  else {
    if (array[mid] < elem)
      return binary_search_aux (elem, array, mid + 1, high);
    else
      return mid;
  }
}
\end{lstlisting}

\section{Сортировка}
\label{sec:sorting}

\subsection{Быстрая сортировка}

Она же \emph{quicksort}. Алгоритм состоит из следующих этапов:
\begin{itemize}
  \item выбирается опорный элемент;
  \item оставшиеся элементы делятся на две группы:
    \begin{enumerate}
      \item первая группа состоит из элементов, которые меньше опорного;
      \item вторая из тех, что больше либо равны;
    \end{enumerate}
  \item каждая группа обрабатывается аналогично.
\end{itemize}

\begin{center}
  \begin{tabular}{lc}
    \toprule
    Случай & Стоимость \\
    \midrule
    Худший & $\Theta(n^2)$ \\
    Лучший & $\Theta(n \log n)$ \\
    В среднем & $\Theta(n \log n)$ \\
    \bottomrule
  \end{tabular}
\end{center}

\lstset{label=lst:qsort,caption=Реализация}
\begin{lstlisting}
void swap (int a[], int i, int j) {
  int tmp;

  tmp = a[i];
  a[i] = a[j];
  a[j] = tmp;
}

void quicksort (int a[], int n) {
  int i, last;
  if (n <= 1)
    return;

  swap (a, 0, rand () % n);
  last = 0;
  for (i = 1; i < n; i++)
    if (a[i] < a[0])
      swap (a, ++last, i);
  swap (a, 0, last);

  quicksort (a, last);
  quicksort (a + last + 1, n - last - 1);
}
\end{lstlisting}

\subsection{Пирамидальная сортировка}

Она же \emph{heapsort}. Алгоритм состоит из следующих шагов:
\begin{itemize}
  \item Создается невозрастающая бинарная пирамида in-place.
  \item Первый элемент (максимальный) меняется с последним. Подмассив $[1..(n - 1)]$ легко преобразуется в пирамиду. Повторять эти действия пока необходимо.
\end{itemize}

\lstset{label=lst:heapsort,caption=Реализация}
\begin{lstlisting}
void heapsort (binheap *heap) {
  int i;
  int size = heap->size;

  build_max_heap (heap);
  for (i = size - 1; i > 0; i--) {
    swap (heap->data, 0, i);
    heap->size -= 1;
    max_heapify (heap, 0);
  }
  heap->size = size;
}
\end{lstlisting}

\section{Расширяемые массивы}
\label{sec:ext-arrays}

Массив, который расширяется по мере необходимости.
\begin{center}
  \begin{tabular}{lc}
    \toprule
    Операция & Стоимость \\
    \midrule
    Доступ к $n$-ому элементу & $\Theta(1)$ \\
    Затраты памяти & $\Theta(n)$ \\
    Вставка в конец & $\Theta(1)$ \\
    Вставка в произвольное место & $\Theta(n)$ \\
    \bottomrule
  \end{tabular}
\end{center}

\lstset{label=lst:dynarray-impl,caption=Некоторые операции}
\begin{lstlisting}
typedef struct extarray extarray;
struct extarray {
  int count;
  int max;
  int *array;
};

extarray arr;

enum { EXTARRAY_INIT = 1,
       EXTARRAY_GROW = 2 };

int add (int value) {
  if (NULL == arr.array) {
    arr.array = (int *) malloc (EXTARRAY_INIT * sizeof (int));
    if (NULL == arr.array)
      return -1;
    arr.max = EXTARRAY_INIT;
    arr.count = 0;
  } else if (arr.count >= arr.max) {
    int i;

    int *newarr = (int *) malloc ((EXTARRAY_GROW * arr.max) * sizeof (int));
    if (NULL == newarr)
      return -1;
    memcpy (newarr, arr.array, arr.count * sizeof (int));
    free (arr.array);
    arr.max *= EXTARRAY_GROW;
    arr.array = newarr;
  }
  arr.array[arr.count] = value;
  return arr.count++;
}

int del (int value) {
  int i;

  for (i = 0; i < arr.count; i++)
    if (value == arr.array[i]) {
      memmove (arr.array + i, arr.array + i + 1,
	       (arr.count - (i + 1)) * sizeof (int));
      arr.count--;
      return 1;
    }
  return 0;
}
\end{lstlisting}

\lstset{label=lst:dynarray-usage,caption=Пример использования}
\begin{lstlisting}
int i;

(void) add (5);
(void) add (3);
(void) add (2);
(void) add (7);
(void) add (6);

for (i = 0; i < arr.count; i++)
  printf ("%d ", arr.array[i]);
printf ("\n");

(void) del (2);
(void) del (7);
for (i = 0; i < arr.count; i++)
  printf ("%d ", arr.array[i]);
printf ("\n");
\end{lstlisting}

\section{Списки}
\label{sec:lists}

Последовательность элементов. Различают \emph{односвязный} и \emph{двусвязный} списки. В односвязном списке можем двигаться в лишь одну сторону, находясь на каком-либо элементе; в двусвязном --- в любую.
\begin{center}
  \begin{tabular}{lc}
    \toprule
    Операция & Стоимость \\
    \midrule
    Доступ к $n$-ому элементу & $\Theta(n)$ \\
    Затраты памяти & $\Theta(n)$ \\
    Вставка в начало & $\Theta(1)$ \\
    \bottomrule
  \end{tabular}
\end{center}

Ниже приведено определение списка и реализация некоторых операций над ним.

\lstset{label=lst:list-impl,caption=Некоторые операции}
\begin{lstlisting}
typedef struct list list;
struct list {
  int data;
  list *next;
};

list *new_item (int data) {
  list *new = (list *) malloc (sizeof (list));

  new->data = data;
  new->next = NULL;

  return new;
}

list *add_front (list *head, list *new) {
  new->next = head;
  return new;
}

list *add_end (list *head, list *new) {
  if (NULL == head)
    return new;

  list *p;
  for (p = head; p->next != NULL; p = p->next)
    ;
  p->next = new;
  return head;
}

list *remove_item (list *head, int data) {
  list *current, *prev = NULL;

  for (current = head; current != NULL; current = current->next) {
    if (data == current->data) {
      if (NULL == prev)
	head = current->next;
      else
	prev->next = current->next;
      free (current);
      return head;
    }
    prev = current;
  }
  return head;
}

void print_backwards (list *elem) {
  if (NULL == elem)
    return;

  print_backwards (elem->next);
  printf ("%x ", elem->data);
}
\end{lstlisting}

\lstset{label=lst:list-usage,caption=Пример использования}
\begin{lstlisting}
list *head = NULL;

head = add_front (head, new_item (1));
head = add_front (head, new_item (2));
head = add_front (head, new_item (3));
head = add_end (head, new_item (4));
head = add_end (head, new_item (5));

print_backwards (head);
printf ("\n");

head = remove_item (head, 3);
head = remove_item (head, 1);
head = remove_item (head, 5);

print_backwards (head);
printf ("\n");
\end{lstlisting}

\section{Бинарные деревья поиска}
\label{sec:trees}

\textbf{Бинарное дерево} --- иерархическая структура данных. Каждый элемент содержит данные и указывает на $0..2$ других элементов. На каждый элемент, кроме \emph{корня}, указывает только один другой элемент. \emph{Листья} не указывают ни на один элемент.

\textbf{Бинарное дерево поиска} --- бинарное дерево, для каждого узла которого выполняются:
\begin{enumerate}
  \item Элементы левого поддерева ``меньше'' самого узла.
  \item Элементы правого поддерева ``больше'' самого узла.
  \item Оба поддерева --- бинарные деревья поиска.
\end{enumerate}

\begin{center}
  \begin{tabular}{lcc}
    \toprule
    Операция & Стоимость & Вырожденный случай \\
    \midrule
    Поиск элемента & $\Theta(\log n)$ & $\Theta(n)$ \\
    Затраты памяти & $\Theta(n)$ & \\
    Вставка & $\Theta(\log n)$ & $\Theta(n)$ \\
    Обход & $\Theta(n)$ & \\
    \bottomrule
  \end{tabular}
\end{center}

\lstset{label=lst:bst-impl,caption=Некоторые операции}
\begin{lstlisting}
typedef struct tree tree;
struct tree {
  int data;
  tree *left;
  tree *right;
};

tree *new_item (int data) {
  tree *new = (tree *) malloc (sizeof (tree));

  new->data = data;
  new->left = NULL;
  new->right = NULL;

  return new;
}

tree *insert (tree *root, tree *new) {
  if (NULL == root)
    return new;

  if (root->data < new->data)
    root->right = insert (root->right, new);
  else if (root->data > new->data)
    root->left = insert (root->left, new);
  /* skipping items that are already in the tree */

  return root;
}

void apply_preorder (tree *root, void (*fn) (tree *)) {
  if (NULL == root)
    return;

  (*fn) (root);
  apply_preorder (root->left, fn);
  apply_preorder (root->right, fn);
}

void print_tree (tree *root) {
  apply_preorder (root, &print_tree_aux);
}

void print_tree_aux (tree *root) {
  printf ("%d\n", root->data);
}
\end{lstlisting}

\lstset{label=lst:bst-usage,caption=Пример использования}
\begin{lstlisting}
tree *root = NULL;

root = insert (root, new_item (8));
root = insert (root, new_item (3));
root = insert (root, new_item (1));
root = insert (root, new_item (6));
root = insert (root, new_item (10));

print_tree (root);
\end{lstlisting}

\section{Бинарные пирамиды}
\label{sec:bin-heaps}

Бинарное дерево, для которого выполнены следующие условия:
\begin{itemize}
  \item Значение в узле больше значений его потомков.
  \item Любой лист находится на высоте либо $d - 1$, либо $d$.
  \item Низший уровень заполняется слева направо.
\end{itemize}

\begin{center}
  \begin{tabular}{lc}
    \toprule
    Операция & Стоимость \\
    \midrule
    Поиск max элемента & $\Theta(1)$ \\
    Удаление max элемента & $\Theta(\log n)$ \\
    Вставка & $\Theta(\log n)$ \\
    \bottomrule
  \end{tabular}
\end{center}

\lstset{label=lst:binheap-impl,caption=Некоторые операции}
\begin{lstlisting}
#define HEAP_SIZE 50

typedef struct binheap binheap;
struct binheap {
  int data[HEAP_SIZE];
  int size;
};

inline int topos (int i) {
  return i + 1;
}

inline int toindex (int i) {
  return i - 1;
}

inline int parent (int i) {
  return toindex (topos (i) / 2);
}

inline int left (int i) {
  return toindex (2 * topos (i));
}

inline int right (int i) {
  return toindex (2 * topos (i) + 1);
}

void max_heapify (binheap *heap, int i) {
  int l = left (i);
  int r = right (i);
  int largest = i;
  int tmp;

  if (l < heap->size && heap->data[l] > heap->data[i])
    largest = l;
  if (r < heap->size && heap->data[r] > heap->data[largest])
    largest = r;

  if (largest != i) {
    swap (heap->data, i, largest);
    max_heapify (heap, largest);
  }
}

void build_max_heap (binheap *heap) {
  int i;
  if (heap->size == 0)
    return;
  for (i = toindex (heap->size / 2); i >= 0; i--)
    max_heapify (heap, i);
}
\end{lstlisting}

\lstset{label=lst:binheap-usage,caption=Пример использования}
\begin{lstlisting}
binheap heap = { { 9, 1, 8, 2, 7, 3, 6, 4, 5 },
                   9 };
int i;

build_max_heap (&heap);
for (i = 0; i < heap.size; i++)
  printf ("%d ", heap.data[i]);
\end{lstlisting}

\section{Хеш-таблицы}
\label{sec:hash-tables}

Используются для отображения \emph{ключей} на \emph{значения}, иными словами --- для реализации \emph{словарей}. Ключи получают из значений при помощи \emph{хеш-функций}. В идеальном случае хеш-функция отображает каждый ключ на единственное значение. В неидеальном случае случаются коллизии.

\begin{center}
  \begin{tabular}{lcc}
    \toprule
    Операция & Стоимость & Вырожденный случай \\
    \midrule
    Поиск элемента & $O(1)$ & $\Theta(n)$ \\
    Затраты памяти & $\Theta(n)$ & \\
    Вставка & $O(1)$ & \\
    \bottomrule
  \end{tabular}
\end{center}

\subsection{Построение хеш-функций}
Значения качественной хеш-функции распределены (приблизительно) равномерно.

\textbf{Метод деления}. Отображение ключа $k$ в одну из ячеек путем получения остатка от деления $k$ на $m$, т.е $h(k) = k \mod m$.

\textbf{Метод умножения}. $h(k) = \lfloor m (kA \mod 1) \rfloor$, где $0 < A < 1$.

\subsection{Разрешение коллизий}
\textbf{Метод цепочек}. Каждая ячейка хеш-таблицы указывает на голову списка \emph{пар ключ-значение}. Значения, которые имеют одинаковые ключи, добавляются в один и то же список.

\textbf{Открытая адресация}. Все элементы хранятся непосредственно в самой хеш-таблице. Множество ячеек для проверки \emph{вычисляется}, а не представляется в виде списка. Распространенные методы вычисления:
\begin{itemize}
  \item \textbf{Линейное исследование}. $h(k, i) = (h^{'}(k) + i) \mod m$, где $h^{'}$ --- вспомогательная хеш-функция, $i \in [0, m -1 ]$.
  \item \textbf{Квадратичное исследование}. $h(k, i) = (h^{'}(k) + c_1i + c_2i^2) \mod m$, где $h^{'}$ --- вспомогательная хеш-функция, $i \in [0, m -1 ]$, $c_1$ и $c_2$ --- вспомогательные константы, отличные от $0$.
  \item \textbf{Двойное хеширование}. $h(k, i) = (h_1(k) + ih_2(k)) \mod m$, где $h_1$ и $h_2$ --- вспомогательные хеш-функции, $i \in [0, m -1 ]$.
\end{itemize}

\subsection{Реализация}
Хеш-таблица построена на основе обычного массива длины $m$. Разрешение коллизий по методу цепочек.

\lstset{label=lst:htable-impl,caption=Некоторые операции}
\begin{lstlisting}
#define HTABLE_SIZE 20
#define MULTIPLIER  31

typedef struct item item;
struct item {
  char *name;
  int value;
  item *next;
};

item *htable[HTABLE_SIZE];

item *new_item (char *name, int value) {
  item *new = (item *) malloc (sizeof (item));

  new->name = name;
  new->value = value;
  new->next = NULL;

  return new;
}

item *lookup (char *name, int create, int value) {
  int h = hash (name);
  item *i = htable[h];

  for (; i != NULL; i = i->next)
    if (strcmp (name, i->name) == 0)
      return i;

  if (create) {
    i = new_item (name, value);
    i->next = htable[h];
    htable[h] = i;
  }
  return i;
}

unsigned int hash (char *str) {
  unsigned int h = 0;
  unsigned char *p = (unsigned char *) str;

  for (; *p != '\0'; p++)
    h = MULTIPLIER * h + *p;
  return h % HTABLE_SIZE;
}
\end{lstlisting}

\lstset{label=lst:htable-usage,caption=Пример использования}
\begin{lstlisting}
char *strings[] = { "string1", "string2", "string3",
                    "string4", "string5" };
int i;
item *it;

for (i = 0; i < 3; i++)
  lookup (strings[i], 1, i + 1);
for (i = 0; i < 5; i++) {
  it = lookup (strings[i], 0, 0);
  if (it)
    printf ("%s in hash table, value = %d\n", it->name, it->value);
  else
    printf ("%s somewhere else\n", strings[i]);
}
\end{lstlisting}

\section{Динамическое программирование}
\label{sec:dyn-programming}

\section{Некоторые заметки о языке C}
\label{sec:c-notes}
