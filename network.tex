\chapter{Сетевое программирование}
\label{ch:network}

\section{Протокол TCP}
\label{sec:tcp}
Он же \emph{протокол управления передачей}; он же \emph{Transmission Control Protocol}. Является протоколом, ориентированным на установление соединения и предоставляющим надежный двусторонний байтовый поток использующим его приложениям. TCP обеспечивает отправку и прием подтверждений, обработку тайм-оутов, повторную передачу и т.п.

Прежде всего, TCP обеспечивает установление соединений. Клиент TCP устанавливает соединение с выбранным сервером, обменивается с ним данными по этому соединению и затем разрывает его.

TCP надежен, но не магичен. Все отправленные данные должны быть подтверждены. Если этого нет, то данные автоматически пересылаются. Время ожидания подтверждения при этом увеличивается.

TCP может оценивать \emph{время обращения} (\emph{round-trip-time}, \emph{RTT}) между двумя узлами и таким образом определять необходимое время для получения подтверждения. TCP постоянно обновляет RTT.

TCP упорядочивает данные, связывая некоторый порядковый номер с каждым отправляемым им байтом. Пусть приложение записывает 2048 байт в сокет TCP, что приводит к отправке двух сегментов TCP. Первый из них содержит данные с порядковыми номерами 1--1024, второй --- с номерами 1025--2048. Если какой-либо сегмент приходит вне очереди, принимающий TCP заново упорядочит сегменты, основываясь на их порядковых номерах, перед тем как отправить данные принимающему приложению. Если TCP получает дублированные данные, он может определить, что они были дублированы, и они будут проигнорированы.

TCP обеспечивает \emph{управление потоком} (\emph{flow control}). TCP сообщает своему собеседнику, сколько именно байтов он хочет получить от него. Это называется объявлением \emph{окна} (\emph{window}).

\subsection{Диаграмма состояний TCP}

% взята с http://www.texample.net/tikz/examples/tcp-state-machine/

\noindent
\begin{tikzpicture}[>=latex]

  %
  % Styles for states, and state edges
  %
  \tikzstyle{state} = [draw, very thick, fill=white, rectangle, minimum height=3em, minimum width=7em, node distance=8em, font={\sffamily\bfseries}]
  \tikzstyle{stateEdgePortion} = [black,thick];
  \tikzstyle{stateEdge} = [stateEdgePortion,->];
  \tikzstyle{edgeLabel} = [pos=0.5, text centered, font={\sffamily\small}];

  %
  % Position States
  %
  \node[state, name=closedStart] {CLOSED};
  \node[state, name=listen, below of=closedStart] {LISTEN};
  \node[state, name=synSent, below of=listen, right of=listen, xshift=8em] {SYN\_SENT};
  \node[state, name=synRcvd, below of=listen, left of=listen, xshift=-8em] {SYN\_RCVD};
  \node[state, name=established, below of=listen, node distance=14em] {ESTABLISHED};
  \node[state, name=finWait1, below of=established, left of=established, node distance=7em, xshift=-9em] {FIN\_WAIT\_1};
  \node[state, name=finWait2, below of=finWait1] {FIN\_WAIT\_2};
  \node[state, name=closeWait, below of=established, right of=established, node distance=7em, xshift=9em] {CLOSE\_WAIT};
  \node[state, name=closing, below of=established, node distance=14em] {CLOSING};
  \node[state, name=lastAck, below of=closeWait] {LAST\_ACK};
  \node[state, name=timeWait, below of=closing] {TIME\_WAIT};

  %
  % Connect States via edges
  %
  \draw ($(closedStart.south) + (-.5em,0)$)
      edge[stateEdge] node[edgeLabel, xshift=-3em]{\emph{Passive open}}
      ($(listen.north) + (-.5em,0)$);
  \draw ($(listen.north) + (.5em,0)$)
      edge[stateEdge] node[edgeLabel, xshift=2em]{\emph{Close}}
      ($(closedStart.south) + (.5em,0)$);

  \draw ($(listen.south) + (-1em,0)$)
      edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-2em, yshift=1em]{SYN/SYN + ACK}
      ($(synRcvd.east) + (0,1em)$);
  \draw ($(listen.south) + (1em,0)$)
      edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=1em, yshift=1em]{\emph{Send}/SYN}
      ($(synSent.west) + (0,1em)$);

  \draw ($(synRcvd.north) + (.5em,0)$)
      edge[stateEdge, bend left=45] node[edgeLabel,xshift=-4em]{\emph{Timeout}/RST}
      ($(closedStart.west) + (0,-.5em)$);

  \draw ($(synSent.north) + (-.5em,0)$)
      edge[stateEdge, bend right=45] node[edgeLabel,xshift=-1em, yshift=-1em]{\emph{Close}}
      ($(closedStart.east) + (0,-.5em)$);
  \draw ($(closedStart.east) + (0,.5em)$)
      edge[stateEdge, bend left=45] node[edgeLabel,xshift=4em]{\emph{Active open}/SYN}
      ($(synSent.north) + (.5em,0)$);

  \draw (synSent.west)
      edge[stateEdge] node[edgeLabel, yshift=1em]{SYN/SYN + ACK}
      (synRcvd.east);
  \draw (synRcvd)
      edge[stateEdge] node[edgeLabel, xshift=-2.5em]{\emph{Close}/FIN}
      (finWait1);

  \draw ($(synRcvd.east) + (0,-1em)$)
      edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-1em, yshift=-1em]{ACK}
      ($(established.north) + (-1em,0)$);
  \draw ($(synSent.west) + (0,-1em)$)
      edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=3em, yshift=-1em]{SYN + ACK/ACK}
      ($(established.north) + (1em,0)$);

  \draw ($(established.south) + (-1em,0)$)
      edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-1em, yshift=1em]{\emph{Close}/FIN}
      ($(finWait1.east) + (0,.5em)$);
  \draw ($(established.south) + (1em,0)$)
      edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=1em, yshift=1em]{FIN/ACK}
      ($(closeWait.west) + (0,1em)$);

  \draw (finWait1.south)
      edge[stateEdge] node[edgeLabel, xshift=-2em]{ACK}
      (finWait2.north);
  \draw ($(finWait1.east) + (0,-.5em)$)
      edge[stateEdge, bend left=22.5] node[edgeLabel, yshift=1em]{ACK}
      (closing.north);
  \draw (finWait1.south east)
      edge[stateEdge] node[edgeLabel, xshift=1em, yshift=2em, text width=3em]{FIN + ACK/ACK}
      (timeWait.north west);

  \draw (finWait2.south)
      edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=-2em, yshift=-1em]{FIN/ACK}
      (timeWait.west);

  \draw (closing)
      edge[stateEdge] node[edgeLabel, xshift=-2em]{ACK}
      (timeWait);

  \draw (closeWait)
      edge[stateEdge] node[edgeLabel,xshift=2.5em]{\emph{Close}/FIN}
      (lastAck);

  %
  % Connect lastAck to closed is slightly more complicated
  % no direct line-of-sight, so we need to take the scenic route
  %
  \coordinate (lastAck2ClosedA) at ($(lastAck.east) + (2em,0)$);
  \coordinate (lastAck2ClosedB) at ($(closedStart.north -| lastAck.east) + (2em,1em)$);
  \coordinate (lastAck2ClosedC) at ($(closedStart.north) + (0.5em,1em)$);
  \draw (lastAck.east) edge[stateEdgePortion] (lastAck2ClosedA);
  \draw (lastAck2ClosedA) edge[stateEdgePortion] node[edgeLabel,xshift=-1.5em, yshift=-4em]{ACK} (lastAck2ClosedB);
  \draw (lastAck2ClosedB) edge[stateEdgePortion] (lastAck2ClosedC);
  \draw (lastAck2ClosedC) edge[stateEdge] ($(closedStart.north) + (0.5em,0)$);

  %
  % likewise for timeWait to closed
  %
  \coordinate (timeWait2ClosedA) at ($(timeWait.south) + (0,-1em)$);
  \coordinate (timeWait2ClosedB) at ($(timeWait.south -| finWait2.west) + (-2em,-1em)$);
  \coordinate (timeWait2ClosedC) at ($(closedStart.north -| finWait2.west) + (-2em,1em)$);
  \coordinate (timeWait2ClosedD) at ($(closedStart.north) + (-0.5em,1em)$);
  \draw (timeWait.south) edge[stateEdgePortion] (timeWait2ClosedA);
  \draw (timeWait2ClosedA) edge[stateEdgePortion] (timeWait2ClosedB);
  \draw (timeWait2ClosedB) edge[stateEdgePortion] (timeWait2ClosedC);
  \draw (timeWait2ClosedC) edge[stateEdgePortion]
    node[edgeLabel, text width=12.25em, yshift=1.5em]{\emph{Timeout after two maximum segment lifetimes (2*MSL)}}
    (timeWait2ClosedD);
  \draw (timeWait2ClosedD) edge[stateEdge] ($(closedStart.north) + (-0.5em,0)$);

  % draw dotted lines around passive and active closes
  \begin{pgfonlayer}{background}
    \draw [join=round,black,dotted] ($(closeWait.north west) + (-1em, -1em)$) rectangle ($(lastAck.south east) + (1em, 1em)$);
    \draw [join=round,black,dotted] ($(finWait1.north west) + (-1em, -1em)$) rectangle ($(timeWait.south east) + (1em, 1em)$);
  \end{pgfonlayer}

\end{tikzpicture}

\section{Протокол UDP}
\label{sec:udp}
Он же \emph{протокол пользовательских дейтаграмм}; он же \emph{User Datagram Protocol}. Является протоколом, не ориентированным на установление соединения. Не гарантирует доставку дейтаграмм.

Приложение записывает в сокет UDP дейтаграмму, которая упаковывается в дейтаграмму IP и затем посылается в пункт назначения. Ее доставка не гарантируется. Если требуются какие-либо гарантии, вы сами должны реализовать их в своем приложении. Каждая дейтаграмма имеет длину, поэтому ее можно рассматривать как \emph{запись} (\emph{record}). В отличии от TCP, который является потоковым протоколом, без каких бы то ни было границ записей.

Если дейтаграмма UDP дублируется в сети, на принимающий узел могут быть доставлены два экземпляра. Также, если клиент UDP отправляет две дейтаграммы в одно и то же место назначения, их порядок может быть изменен сетью.

UDP не обеспечивает управления потоком. Быстрый отправитель UDP может передавать дейтаграммы с такой скоростью, с которой не может работать получатель UDP.
