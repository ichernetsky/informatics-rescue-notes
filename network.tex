\chapter{Сетевое программирование}
\label{ch:network}

\section{Протокол TCP}
\label{sec:tcp}
Он же \emph{протокол управления передачей}; он же \emph{Transmission Control Protocol}. Является протоколом, ориентированным на установление соединения и предоставляющим надежный двусторонний байтовый поток использующим его приложениям. TCP обеспечивает отправку и прием подтверждений, обработку тайм-оутов, повторную передачу и т.п.

Прежде всего, TCP обеспечивает установление соединений. Клиент TCP устанавливает соединение с выбранным сервером, обменивается с ним данными по этому соединению и затем разрывает его.

TCP надежен, но не магичен. Все отправленные данные должны быть подтверждены. Если этого нет, то данные автоматически пересылаются. Время ожидания подтверждения при этом увеличивается.

TCP может оценивать \emph{время обращения} (\emph{round-trip-time}, \emph{RTT}) между двумя узлами и таким образом определять необходимое время для получения подтверждения. TCP постоянно обновляет RTT.

TCP упорядочивает данные, связывая некоторый порядковый номер с каждым отправляемым им байтом. Пусть приложение записывает 2048 байт в сокет TCP, что приводит к отправке двух сегментов TCP. Первый из них содержит данные с порядковыми номерами 1--1024, второй --- с номерами 1025--2048. Если какой-либо сегмент приходит вне очереди, принимающий TCP заново упорядочит сегменты, основываясь на их порядковых номерах, перед тем как отправить данные принимающему приложению. Если TCP получает дублированные данные, он может определить, что они были дублированы, и они будут проигнорированы.

TCP обеспечивает \emph{управление потоком} (\emph{flow control}). TCP сообщает своему собеседнику, сколько именно байтов он хочет получить от него. Это называется объявлением \emph{окна} (\emph{window}).

\subsection{Трехэтапное рукопожатие}
\begin{enumerate}
  \item Сервер должен быть подготовлен для принятия входящего соединения. Это называется \emph{пассивным открытием} (\emph{passive open}).
  \item Клиент выполняет \emph{активное открытие} (\emph{active open}), то есть посылает сегмент SYN, чтобы сообщить серверу начальный порядковый номер данных. Этот сегмент содержит заголовок IP, заголовок TCP и параметры TCP.
  \item Сервер подтверждает получение клиентского сегмента SYN и вслед посылает свой собственный сегмент SYN, содержащий порядковый номер своих данных. SYN и ACK отсылаются в одном сегменте.
  \item Клиент подтверждает получение SYN сервера.
\end{enumerate}

\noindent
\begin{figure}[h!]
  \centering
  \begin{tikzpicture}
    \tikzstyle{tcpStep} = [];
    \node at (0,0) (client) {Клиент};
    \node at (4,0) (server) {Сервер};

    \draw[thick,->,-stealth] (client.south)  -- +(0,-4)
      node (client socket) [tcpStep,left,pos=.1] {\lstinline{socket}}
      node (connect) [tcpStep,left,pos=.35,text width=3.3cm, text justified] {\lstinline{connect}, блокировка, активное открытие}
      node (close connect) [tcpStep,left,pos=.75] {Завершение \lstinline{connect}};
    \draw[thick,->,-stealth] (server.south)  -- +(0,-4)
      node (server socket) [tcpStep,right,pos=.2] {\lstinline{socket, bind, listen}}
      node (accept) [tcpStep,,right,pos=.5] {\lstinline{accept}, блокировка}
      node (close accept) [tcpStep,right,pos=.85] {Завершение \lstinline{accept}};

    \draw[thick,->,-stealth] (connect) edge node [above,sloped] {SYN J} (accept);
    \draw[thick,->,-stealth] (accept) edge node [above,sloped] {SYN K, ACK J+1} (close connect);
    \draw[thick,->,-stealth] (close connect) edge node [above,sloped] {ACK K+1} (close accept);
  \end{tikzpicture}
  \caption{Трехэтапное рукопожатие TCP}
  \label{fig:tcp-handshake}
\end{figure}

Для подобного обмена нужно как минимум три пакета (cм. рис. \vref{fig:tcp-handshake}), поэтому он называется \emph{трехэтапным рукопожатием TCP} (\emph{TCP three-way handshake}).

\subsection{Параметры TCP}
Каждый сегмент SYN может содержать параметры TCP. Следом наиболее общеупотребительные:
\begin{itemize}
  \item \emph{Параметр MSS}. Позволяет объявить свой максимальный размер сегмента (maximum segment size, MSS) --- максимальное количество данных, которое он будет принимать в каждом сегмента TCP на этом соединении.
  \item \emph{Параметр масштабирования окна (Window scale option)}. Максимальный размер окна, который может быть установлен в заголовке TCP, равен $65535$, поскольку соответствующее поле занимает 16 бит. Но высокоскоростные соединения или линии с большой задержкой требуют большего размера окна для получения максимально возможной пропускной способности. Этот параметр определяет, что объявленная в заголовке TCP величина окна должна быть отмасштабирована --- сдвинута влево на 0--14 разрядов, предоставляя максимально возможное окно размером почти гигабайт ($65535 \times 2^{14}$).
  \item \emph{Временная метка (Timestamp option)}. Этот параметр необходим для высокоскоростных соединений, чтобы предотвратить возможное повреждение данных, вызванное приходом устаревших, задержавшихся и дублированных сегментов.
\end{itemize}

\subsection{Завершение соединения TCP}
Для завершения соединения требуется четыре сегмента.

\begin{enumerate}
  \item Один из сетевых узлов выполняет \emph{активное закрытие} (\emph{active close}). TCP этого узла отправляет сегмент FIN.
  \item Другой узел, получающий сегмент FIN, выполняет \emph{пассивное закрытие} (\emph{passive close}). Полученный сегмент FIN подтверждается TCP. Получение сегмента FIN передается приложению как признак конца файла.
  \item Через некоторое время после того, как приложение получило признак конца файла, оно закрывает свой сокет. TCP отправляет сегмент FIN первому узлу.
  \item Первый узел подтверждает получение сегмента FIN.
\end{enumerate}

Иногда первый FIN отправляется в сегменте вместе с данными. Также сегменты, отправляемые на шагах 2 и 3, могут быть объединены. Возможно, что между шагами 2 и 3 какие-то данные будут переданы от узла, выполняющего пассивное закрытие, к узлу, выполняющему активное закрытие. Это состояние называется \emph{частичным закрытием} (\emph{half-close}).

\subsection{Диаграмма состояний TCP}
Смотрите рис.~\ref{fig:tcp-states} на стр.~\pageref{fig:tcp-states}.
% взята с http://www.texample.net/tikz/examples/tcp-state-machine/
\noindent
\begin{figure}[t!]
  \centering
  \begin{tikzpicture}[>=latex]
    %
    % Styles for states, and state edges
    %
    \tikzstyle{state} = [draw, very thick, fill=white, rectangle, minimum height=3em, minimum width=6em, node distance=6.5em, font={\sffamily\bfseries\footnotesize}]
    \tikzstyle{stateEdgePortion} = [black,thick];
    \tikzstyle{stateEdge} = [stateEdgePortion,->];
    \tikzstyle{edgeLabel} = [pos=0.5, text centered, font={\sffamily\small}];

    %
    % Position States
    %
    \node[state, name=closedStart] {CLOSED};
    \node[state, name=listen, below of=closedStart] {LISTEN};
    \node[state, name=synSent, below of=listen, right of=listen, xshift=7em] {SYN\_SENT};
    \node[state, name=synRcvd, below of=listen, left of=listen, xshift=-7em] {SYN\_RCVD};
    \node[state, name=established, below of=listen, node distance=14em] {ESTABLISHED};
    \node[state, name=finWait1, below of=established, left of=established, node distance=6em, xshift=-7.5em] {FIN\_WAIT\_1};
    \node[state, name=finWait2, below of=finWait1] {FIN\_WAIT\_2};
    \node[state, name=closeWait, below of=established, right of=established, node distance=6em, xshift=6.5em] {CLOSE\_WAIT};
    \node[state, name=closing, below of=established, node distance=14em] {CLOSING};
    \node[state, name=lastAck, below of=closeWait] {LAST\_ACK};
    \node[state, name=timeWait, below of=closing] {TIME\_WAIT};

    %
    % Connect States via edges
    %
    \draw ($(closedStart.south) + (-.5em,0)$)
        edge[stateEdge] node[edgeLabel, xshift=-3em]{\emph{Passive open}}
        ($(listen.north) + (-.5em,0)$);
    \draw ($(listen.north) + (.5em,0)$)
        edge[stateEdge] node[edgeLabel, xshift=2em]{\emph{Close}}
        ($(closedStart.south) + (.5em,0)$);

    \draw ($(listen.south) + (-1em,0)$)
        edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-2em, yshift=1em]{SYN/SYN + ACK}
        ($(synRcvd.east) + (0,1em)$);
    \draw ($(listen.south) + (1em,0)$)
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=1em, yshift=1em]{\emph{Send}/SYN}
        ($(synSent.west) + (0,1em)$);

    \draw ($(synRcvd.north) + (.5em,0)$)
        edge[stateEdge, bend left=45] node[edgeLabel,xshift=-4em]{\emph{Timeout}/RST}
        ($(closedStart.west) + (0,-.5em)$);

    \draw ($(synSent.north) + (-.5em,0)$)
        edge[stateEdge, bend right=45] node[edgeLabel,xshift=-1em, yshift=-1em]{\emph{Close}}
        ($(closedStart.east) + (0,-.5em)$);
    \draw ($(closedStart.east) + (0,.5em)$)
        edge[stateEdge, bend left=45] node[edgeLabel,xshift=4em,sloped,above]{\emph{Active open}/SYN}
        ($(synSent.north) + (.5em,0)$);

    \draw (synSent.west)
        edge[stateEdge] node[edgeLabel, yshift=1em]{SYN/SYN + ACK}
        (synRcvd.east);
    \draw (synRcvd)
        edge[stateEdge] node[edgeLabel, xshift=-2.5em]{\emph{Close}/FIN}
        (finWait1);

    \draw ($(synRcvd.east) + (0,-1em)$)
        edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-1em, yshift=-1em]{ACK}
        ($(established.north) + (-1em,0)$);
    \draw ($(synSent.west) + (0,-1em)$)
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=3em, yshift=-1em]{SYN + ACK/ACK}
        ($(established.north) + (1em,0)$);

    \draw ($(established.south) + (-1em,0)$)
        edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-1em, yshift=1em]{\emph{Close}/FIN}
        ($(finWait1.east) + (0,.5em)$);
    \draw ($(established.south) + (1em,0)$)
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=1em, yshift=1em]{FIN/ACK}
        ($(closeWait.west) + (0,1em)$);

    \draw (finWait1.south)
        edge[stateEdge] node[edgeLabel, xshift=-2em]{ACK}
        (finWait2.north);
    \draw ($(finWait1.east) + (0,-.5em)$)
        edge[stateEdge, bend left=22.5] node[edgeLabel, yshift=1em]{ACK}
        (closing.north);
    \draw (finWait1.south east)
        edge[stateEdge] node[edgeLabel, xshift=1em, yshift=2em, text width=3em]{FIN + ACK/ACK}
        (timeWait.north west);

    \draw (finWait2.south)
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=-2em, yshift=-1em]{FIN/ACK}
        (timeWait.west);

    \draw (closing)
        edge[stateEdge] node[edgeLabel, xshift=-2em]{ACK}
        (timeWait);

    \draw (closeWait)
        edge[stateEdge] node[edgeLabel,xshift=2.5em]{\emph{Close}/FIN}
        (lastAck);

    %
    % Connect lastAck to closed is slightly more complicated
    % no direct line-of-sight, so we need to take the scenic route
    %
    \coordinate (lastAck2ClosedA) at ($(lastAck.east) + (2em,0)$);
    \coordinate (lastAck2ClosedB) at ($(closedStart.north -| lastAck.east) + (2em,1em)$);
    \coordinate (lastAck2ClosedC) at ($(closedStart.north) + (0.5em,1em)$);
    \draw (lastAck.east) edge[stateEdgePortion] (lastAck2ClosedA);
    \draw (lastAck2ClosedA) edge[stateEdgePortion] node[edgeLabel,xshift=-1.5em, yshift=-4em]{ACK} (lastAck2ClosedB);
    \draw (lastAck2ClosedB) edge[stateEdgePortion] (lastAck2ClosedC);
    \draw (lastAck2ClosedC) edge[stateEdge] ($(closedStart.north) + (0.5em,0)$);

    %
    % likewise for timeWait to closed
    %
    \coordinate (timeWait2ClosedA) at ($(timeWait.south) + (0,-1em)$);
    \coordinate (timeWait2ClosedB) at ($(timeWait.south -| finWait2.west) + (-2em,-1em)$);
    \coordinate (timeWait2ClosedC) at ($(closedStart.north -| finWait2.west) + (-2em,1em)$);
    \coordinate (timeWait2ClosedD) at ($(closedStart.north) + (-0.5em,1em)$);
    \draw (timeWait.south) edge[stateEdgePortion] (timeWait2ClosedA);
    \draw (timeWait2ClosedA) edge[stateEdgePortion] (timeWait2ClosedB);
    \draw (timeWait2ClosedB) edge[stateEdgePortion] (timeWait2ClosedC);
    \draw (timeWait2ClosedC) edge[stateEdgePortion]
      node[edgeLabel, text width=12.25em, yshift=1.5em]{\emph{Timeout after two maximum segment lifetimes (2*MSL)}}
        (timeWait2ClosedD);
    \draw (timeWait2ClosedD) edge[stateEdge] ($(closedStart.north) + (-0.5em,0)$);

    % draw dotted lines around passive and active closes
    \begin{pgfonlayer}{background}
      \draw [join=round,black,dotted] ($(closeWait.north west) + (-1em, -1em)$) rectangle ($(lastAck.south east) + (1em, 1em)$);
      \draw [join=round,black,dotted] ($(finWait1.north west) + (-1em, -1em)$) rectangle ($(timeWait.south east) + (1em, 1em)$);
    \end{pgfonlayer}
  \end{tikzpicture}
  \caption{Диаграмма состояний TCP}
  \label{fig:tcp-states}
\end{figure}

\subsection{Состояние TIME\_WAIT}
Оно же --- время ожидания. Узел, выполняющий активное закрытие, проходит это состояние. Его продолжительность равно двум \emph{MSL} (\emph{maximum segment lifetime --- максимальное время жизни сегмента}). MSL --- это максимальное время, в течение которого дейтаграмма IP может оставаться в сети. Каждая дейтаграмма содержит 8-разрядное поле \emph{предельного количества прыжков} (\emph{hop limit}), максимальное значение которого равно 255. Считается, что пакет с максимальным значением этого пределеа не может существовать в сети более MSL секунд.

Причины существования состояния TIME\_WAIT:
\begin{itemize}
  \item необходимо обеспечить надежность разрыва двустороннего соединения TCP;
  \item необходимо подождать, когда истечет время жизни в сети старых дублированных сегментов.
\end{itemize}

Предположим, что последний сегмент ACK потерян. Сервер еще раз отправит свой последний сегмент FIN, поэтому клиент должен сохранять информацию о своем состоянии, что отправить завершающее подтверждение ACK повторно. Если бы клиент не сохранял информацию о состоянии, он ответил бы серверу сегментом RST, что сервер интерпретировал бы как ошибку.

Предположим, что только что завершилось соединение между двумя узлами, и через некоторое время снова создается соединение с теми же оконечными точками. TCP должен предотвратить появление старых дубликатов в новом соединении. Чтобы гарантировать это, TCP запрещает установление нового соединения, если старое соединение находится в состоянии TIME\_WAIT.

\section{Протокол UDP}
\label{sec:udp}
Он же \emph{протокол пользовательских дейтаграмм}; он же \emph{User Datagram Protocol}. Является протоколом, не ориентированным на установление соединения. Не гарантирует доставку дейтаграмм.

Приложение записывает в сокет UDP дейтаграмму, которая упаковывается в дейтаграмму IP и затем посылается в пункт назначения. Ее доставка не гарантируется. Если требуются какие-либо гарантии, вы сами должны реализовать их в своем приложении. Каждая дейтаграмма имеет длину, поэтому ее можно рассматривать как \emph{запись} (\emph{record}). В отличии от TCP, который является потоковым протоколом, без каких бы то ни было границ записей.

Если дейтаграмма UDP дублируется в сети, на принимающий узел могут быть доставлены два экземпляра. Также, если клиент UDP отправляет две дейтаграммы в одно и то же место назначения, их порядок может быть изменен сетью.

UDP не обеспечивает управления потоком. Быстрый отправитель UDP может передавать дейтаграммы с такой скоростью, с которой не может работать получатель UDP.

\section{POSIX API}
\label{sec:network-api}

\subsection{Простейший DAYTIME клиент}
Ниже приведен простейший DAYTIME клиент. В качестве аргументов командной строки должен быть указан IPv4-адрес и может быть указан номер порта.

\lstset{label=lst:date-client-basic,caption=Простейший DAYTIME клиент}
\lstinputlisting{src/network/date-client-basic.c}

Ниже приведен пример запуска клиента для сервера \texttt{time.ien.it}.

\lstset{language=,label=lst:basic-client-run,caption=Использование}
\begin{lstlisting}
% nslookup time.ien.it
Server:		10.6.0.6
Address:	10.6.0.6#53

Non-authoritative answer:
time.ien.it	canonical name = ntp.ien.it.
Name:	ntp.ien.it
Address: 193.204.114.105

% date-client-basic 193.204.114.105
20 OCT 2010 12:04:33 CEST
\end{lstlisting}

\subsubsection{Функция socket}
Сетевой ввод/вывод начинается с вызовы функции \lstinline{socket}, передавая ей тип желаемого протокола.
\lstset{language=C,caption=}
\begin{lstlisting}
#include <sys/socket.h>
int socket(int family, int type, int protocol);
\end{lstlisting}

Она возвращает неотрицательный дескриптор в случае успеха, -1 в случае ошибки. \lstinline{family} задает семейство протоколов.
\begin{table}[h!]
  \caption{Аргумент \lstinline{family} для функции \lstinline{connect}}
  \begin{center}
    \begin{tabular}{p{2.5cm}l}
      \toprule
      & \textbf{Описание} \\
      \midrule
      AF\_INET & Протоколы IPv4 \\
      AF\_INET6 & Протоколы IPv6 \\
      AF\_LOCAL & Протоколы доменных сокетов Unix \\
      AF\_ROUTE & Маршрутизирующие сокеты \\
      AF\_KEY & Сокет управления ключами \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

\begin{table}[h!]
  \caption{Тип сокета}
  \begin{center}
    \begin{tabular}{p{3.5cm}l}
      \toprule
      & \textbf{Описание} \\
      \midrule
      SOCK\_STREAM & Потоковый сокет \\
      SOCK\_DGRAM & Сокет дейтаграмм \\
      SOCK\_SEQPACKET & Сокет последовательных пакетов \\
      SOCK\_RAW & Символьный (неструктурированный) сокет \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

 Аргумент \lstinline{protocol} должен быть установлен в соответствии с используемым протоколом или равен нулю для выбора протокола, по умолчанию соответствующему заданному семейству и типу.
\begin{table}[h!]
  \caption{Возможные значения параметра \lstinline{protocol}}
  \begin{center}
    \begin{tabular}{p{3cm}l}
      \toprule
      & \textbf{Описание} \\
      \midrule
      IPPROTO\_TCP & Транспортный протокол TCP \\
      IPPROTO\_UDP & Транспортный протокол UDP \\
      IPPROTO\_SCTP & Транспортный протокол SCTP \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

Не все сочетания \lstinline{family} и \lstinline{type} допустимы. При успешном выполнении функция \lstinline{socket} возвращает неотрицательное число, аналогичное дескриптору файла. Чтобы получить дескриптор сокета, достаточно указать лишь семейство протоколов и тип сокета. Ни локальный адрес протокола, ни удаленный адрес протокола еще не заданы.

\subsubsection{Функция connect}
Функция \lstinline{connect} используется для установления соединения.
\lstset{language=C,caption=}
\begin{lstlisting}
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);
\end{lstlisting}

Аргумент \lstinline{sockfd} --- это дескриптор сокета, возвращенный функцией \lstinline{socket}. Структура адреса сокета должна содержать IP-адрес и номер порта сервера.

Клиенту не надо вызывать функцию \lstinline{bind} до вызова функции \lstinline{connect}, так как ядро само выберет и динамически назначаемый порт, и IP-адрес отправителя.

В случае сокета TCP функция \lstinline{connect} инициирует трехэтапное рукопожатие. Функция возвращает значение, только если установлено соединение или произошла ошибка. Возможны следующие ошибки:
\begin{enumerate}
  \item Если клиент не получает ответа на свой сегмент SYN, возвращается \lstinline{ETIMEDOUT}.
  \item Если на сегмент SYN сервер отвечает сегментом RST, это означает, что ни один процесс на узле сервера не находится в ожидании подключения к указанному порту. Клиенту возвращается \lstinline{ECONNREFUSED} при получении им сегмента RST.
  \item Если сегмент SYN клиента приводит к получению сообщения ICMP о недоступности получателя от какого-либо промежуточного маршрутизатора. Ядро сохраняет сообщение об ошибке, но продолжает отправлять сегменты SYN с определенными интервалами. Если же по истечении определенного фиксированного времени ответ не получен, то сохраненная ошибка ICMP возвращается процессу либо как \lstinline{EHOSTUNREACH}, либо как \lstinline{ENETUNREACH}.
\end{enumerate}

\subsubsection{Функции inet\_pton и inet\_ntop}
Преобразуют IP-адрес, заданный как строка, в двоичный формат представления с сетевым порядком байт, и наоборот. Симфолы p и n обозначают соответсвенно формат \emph{представления} и \emph{численный} формат.
\lstset{language=C,caption=}
\begin{lstlisting}
#include <arpa/inet.h>
int inet_pton(int family, const char *str, void *addr);

#include <arpa/inet.h>
const char *inet_ntop(int family, const void *addr, char *str,
                      socklen_t len);
\end{lstlisting}

Значение аргумента \lstinline{family} может быть либо \lstinline{AF_INET}, либо \lstinline{AF_INET6}. Если \lstinline{family} не поддерживается, функции возвращают ошибку со значением переменной \lstinline{errno}, равным \lstinline{EAFNOSUPPORT}. В качестве \lstinline{len} рекомендуется использовать макросы, определенные в \lstinline{<netinet/in.h>}:
\lstset{language=C,caption=}
\begin{lstlisting}
#define  INET_ADDRSTRLEN    16
#define  INET6_ADDRSTRLEN   46
\end{lstlisting}

\subsection{DAYTIME клиент, независящий от протокола}
В качестве адреса могут быть указаны IPv4-адрес, IPv6-адрес или же доменное имя.

\lstset{label=lst:date-client,caption=DAYTIME клиент}
\lstinputlisting{src/network/date-client.c}

Ниже приведен пример запуска клиента для сервера \texttt{time.ien.it}.
\lstset{language=,label=lst:client-run,caption=Использование}
\begin{lstlisting}
% date-client time.ien.it
20 OCT 2010 12:04:33 CEST
\end{lstlisting}

\subsubsection{Функция getaddrinfo}
Осущетсвляет трансляцию имен в адреса и служб в порты. Возвращает список структур \lstinline{sockaddr}. Функция \lstinline{getaddrinfo} скрывает все различия между протоколами в библиотеке функций.

\lstset{language=C,caption=}
\begin{lstlisting}
#include <netdb.h>
int getaddrinfo(const char *node, const char *service,
                const struct addrinfo *hints,
                struct addrinfo **res);
\end{lstlisting}

Через указатель \lstinline{res} функция возвращает указатель на связный список структур \lstinline{addrinfo}.
\lstset{language=C,caption=}
\begin{lstlisting}
struct addrinfo {
  int              ai_flags;      /* AI_PASSIVE, AI_CANONNAME */
  int              ai_family;     /* AF_xxx */
  int              ai_socktype;   /* SOCK_xxx */
  int              ai_protocol;   /* 0 or IPPROTO_xxx for IPv4 or IPv6 */
  size_t           ai_addrlen;    /* ai_addr length */
  struct sockaddr *ai_addr;       /* pointer to canonical name */
  char            *ai_canonname;  /* pointer to socket address structure */
  struct addrinfo *ai_next;       /* pointer to next structure in list */
};
\end{lstlisting}

Переменная \lstinline{node} --- это либо имя узла, либо строка адреса (точечно-десятичная запись для IPv4 или шестнадцатеричная строка для IPv6). Переменная \lstinline{service} --- это либо имя службы, либо строка, содержащая десятичный номер порта.

Аргумент \lstinline{hints} --- это либо пустой указатель, либо указатель на структуру \lstinline{addrinfo}, заполненную рекомендациями вызывающего процесса о типах информации, которую он хочет получить.
\begin{itemize}
  \item \lstinline{ai_flags} (несколько констант \lstinline{AI_xxx}, объединенных операцией ИЛИ);
  \item \lstinline{ai_family} (значение \lstinline{AF_xxx});
  \item \lstinline{ai_socktype} (значение \lstinline{SOCK_xxx});
  \item \lstinline{ai_protocol}.
\end{itemize}

Наиболее важные возможные значения поля \lstinline{ai_flags}:
\begin{itemize}
  \item \lstinline{AI_PASSIVE} указывает, что сокет будет использоваться для пассивного открытия;
  \item \lstinline{AI_CANONNAME} указывает функции на необходимость возвратить каноническое имя узла;
\end{itemize}

\subsection{Последовательный DAYTIME сервер}
В качестве аргументов командной строки может быть указан номер порта для прослушивания.

\lstset{label=lst:date-server,caption=DAYTIME сервер}
\lstinputlisting{src/network/date-server.c}

\subsubsection{Функция bind}
Функция \lstinline{bind} связывает сокет с локальным адресом протокола, комбинацией адреса IP с номером порта.
\lstset{language=C,caption=}
\begin{lstlisting}
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
\end{lstlisting}

Вторым аргументом является указатель на специфичный для протокола адрес, а третий аргумент --- это размер структуры адреса.

С помощью функции \lstinline{bind} процесс может связать конкретный IP-адрес с сокетом. IP-адрес должен соответствовать одному из интерфейсов узла. Так определяется IP-адрес, который будет использоваться для отправляемых через сокет IP-дейтаграмм. При этом на сокет накладывается ограничение: он может принимать только такие входящие соединения, которые предназначены именно для этого IP-адреса.

Если зададать нулевой номер порта, то при вызове функции \lstinline{bind} ядро выберет динамически назначаемый порт. Но если задать IP-адрес с помощью символов подстановки, ядро не выберет локальный IP-адрес, пока к сокету не присоединиться клиент либо на сокет не будет отправлена дейтаграмма.

В случае IPv4 универсальный адрес состоящий из символов подстановки, задается константой \lstinline{INADDR_ANY}.
\lstset{language=C,caption=}
\begin{lstlisting}
struct sockaddr_in addr;
servaddr.sin_addr.s_addr = htonl (INADDR_ANY);
\end{lstlisting}

\subsubsection{Функция listen}
Функция \lstinline{listen} вызывается только сервером TCP и выполняет два действия.
\begin{enumerate}
  \item Когда сокет создается с помощью функции \lstinline{socket}, считается, что это активный сокет, то есть клиентский сокет, который запустит функцию \lstinline{connect}. Функция \lstinline{listen} преобразует неприсоединенный сокет в пассивный сокет, запросы на подключение к которому начинают приниматься ядром.
  \item Второй аргумент этой функции задает максимальное число соединений, которые ядро может помещать в очередь этого сокета.
\end{enumerate}

\lstset{language=C,caption=}
\begin{lstlisting}
#include <sys/socket.h>
int listen(int sockfd, int backlog);
\end{lstlisting}

Чтобы уяснить смысл аргумента \lstinline{backlog}, необходимо понять, что для данного прослушиваемого сокета ядро поддерживает две очереди:
\begin{enumerate}
  \item \emph{Очередь не польностью установленных соединений} (\emph{incomplete connection queue}), содержащую запись для каждого сегмента SYN, пришедшег от клиента, для которого сервер ждет завершения трехэтапного рукопожатия TCP.
  \item \emph{Очередь польностью установленных соединений} (\emph{complete connection queue}), содержащую запись для каждого клиента, с которым завершилось трехэтапное рукопожатие TCP.
\end{enumerate}

Когда в очередь не польностью установленных соединений добавляется новая запись, параметры прослушиваемого сокета копируются на создаваемое соединение. Если трехэтапное рукопожатие завершается нормально, запись переходит из очереди не полностью установленных соединений в конец очереди полностью установленных соединений. Когда процесс вызывает функцию \lstinline{accept}, ему возвращается первая запись из очереди полностью установленных соединений, а если очередь пуста процесс переходит в состояние ожидания.

Некоторые заметки:
\begin{itemize}
  \item Если трехэтапное рукопожатие завершается нормально, запись остается в очереди не полностью установленных соединений на время одного периода обращения.
  \item Если очереди заполнены, когда приходит клиентский сегмент SYN, то TCP игнорирует приходящий сегмент SYN и не посылает RST. Это происходит потому, что состояние считается временным, и TCP клиента должен еще раз передать свой сегмент SYN, для которого в ближайшее время вероятно, найдется место в очереди.
  \item Данные, которые приходят после завершения трехэтапного рукопожатия, но до того, как сервер вызывает функцию \lstinline{accept}, должны помещаться в очередь TCP-сервера, пока не будет заполнен приемный буфер.
\end{itemize}

\subsubsection{Функция accept}
Функция \lstinline{accept} вызывается сервером TCP для возвращения следующего установленного соединения из начала очереди полностью установленных соединений. Если очередь полностью установленных соединений пуста, процесс переходит в состояние ожидания (по умолчанию предполагается блокируемый сокет).
\lstset{language=C,caption=}
\begin{lstlisting}
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
\end{lstlisting}

Аргументы \lstinline{addr} и \lstinline{addrlen} используется для возвращения адреса протокола подключившегося процесса (клиента). Если функция \lstinline{accept} завершилась успешно, она возвращает новый дескриптор, автоматически созданный ядром. Этот дескриптор используется для обращения к соединению TCP с конкретным клиентом. Функция \lstinline{accept} принимает \emph{прослушиваемый сокет} и возвращает \emph{присоединенный сокет}.

\section{Организация сетей и адресация}
\label{sec:network-setup}

Размер IPv4-адреса --- 32 бита. Адреса принято записывать в десятичной нотации, например, 17.52.86.120. Все IP-адреса подразделены на пять классов: A, B, C, D и E. Адреса класса D используются для группового вещания, а класс E зарезервирован для будущих расширений. Остальные классы предназначены для адресации конкретных сетей и узлов.

Первая часть любого адреса представляет собой идентификатор сети, вторая --- идентификатор узла внутри этой сети. Адрес узла из одних единиц, --- это широковещательный адрес. IP-дейтаграммы, посланные по этому адресу, доставляются всем узлам сети. Адрес 0 означает ``этот узел''. Например, в сети 192.168.1.0/24 адрес 192.168.1.255 --- широковещательный, а 192.168.1.0 --- ``этот узел''. Адрес сети 0 означает ``эта сеть''. Адрес сети 127 --- это адрес ``собственной'' сети узла. Дейтаграммы, адресованные сети 127, не должны покидать узел-отправитель.

\noindent
\begin{figure}[h!]
  \centering
  \begin{tikzpicture}
    \tikzstyle{host} = [draw, thick, fill=white, rectangle, minimum height=2.5em, minimum width=4em, node distance=3em, font={\bfseries}]
    \tikzstyle{router} = [host, rounded corners]
    \tikzstyle{hostConnect} = [draw, |-, very thick]

    \draw [very thick] (0,-1) -- node [right=5.1cm] {Сегмент 1} +(10,0);

    \node [host, name=H1] at (1,0) {H1};
    \node [host, name=H2, right=of H1] {H2};
    \node [router, name=R2, right=of H2] {R2};
    \draw [very thick,|->] (R2.north) -- node [above=0.5em] {Интернет} +(0,0.5);

    \draw [hostConnect] let \p1=(H1.south) in
      (H1.south) -- (\x1, -1);
    \draw [hostConnect] let \p1=(H2.south) in
      (H2.south) -- (\x1, -1);
    \draw [hostConnect] let \p1=(R2.south) in
      (R2.south) -- (\x1, -1);

    \draw [very thick] (0,-3) -- node [right=5.1cm] {Сегмент 2} +(10,0);

    \node [host, name=H3] at (1,-2) {H3};
    \node [host, name=H4, right=of H3] {H4};
    \node [host, name=H5, right=of H4] {H5};
    \node [router, name=R1, right=of H5] {R1};

    \draw [hostConnect] let \p1=(H3.south) in
      (H3.south) -- (\x1, -3);
    \draw [hostConnect] let \p1=(H4.south) in
      (H4.south) -- (\x1, -3);
    \draw [hostConnect] let \p1=(H5.south) in
      (H5.south) -- (\x1, -3);
    \draw [hostConnect] let \p1=(R1.south) in
      (R1.south) -- (\x1, -3);
    \draw [hostConnect] let \p1=(R1.north) in
      (R1.north) -- (\x1, -1);
  \end{tikzpicture}
  \caption{Сеть из двух сегментов}
\end{figure}

Если узлу H1 нужно обратиться к узлу H2, то он получает адрес, соответсвующий IP-адресу H2, и помещает дейтаграмму ``на провод''.

Если узлу H1 нужно обратиться к узлу H3, то H1 должен отправить дейтаграмму через маршрутизатор R1. Если у двух сегментов разные идентификаторы сетей, то H1 по своей маршрутной таблице определяет, что пакеты, адресованные сенменту 2, обрабатываются маршрутизатором R1, и отправляет ему дейтаграмму в предположении, что тот переправит ее узлу H3.

Из вышесказанного следует, что один из способов организовать сети с несколькими сегментами --- это назначить каждому сегменту свой идентификатор сети. Но у этого решения есть недостатки. Во-первых, при этом возможна потеря многих адресов в каждой сети. Во-вторых, маршрутная таблица любого узла, который направляет дейтаграммы напрямую в комбинированную сеть, должна содержать по одной записи для каждого сегмента.

\subsection{Подсети}
У механизма подсетей есть следующие достоинства:
\begin{itemize}
  \item Небольшие маршрутные таблицы и эффективное использование адресного пространства.
  \item Простая маршрутизация.
\end{itemize}

Так как внешние узлы, чтобы выбрать маршрут, используют только идентификатор сети, то можно распределять идентификаторы узлов по своему усмотрению. Разделение на подсети осуществляется по следующему принципу. Одна часть идентификатора узла служит для определения сегмента (то есть подсети), в состав которого входит узел, а другая --- для определения конкретного узла.

\noindent
\begin{figure}[h!]
  \centering
  \begin{tikzpicture}
    \tikzstyle{part} = [draw, thick, fill=white, rectangle, minimum height=2.5em, minimum width=6em, node distance=0]
    \tikzstyle{number} = [node distance=0]

    \node[part,name=net,minimum width=12em] {Идентификатор сети};
    \node[part,right=of net,xshift=-1,name=subnet] {Подсеть};
    \node[part,right=of subnet,xshift=-1,name=host] {Номер хоста};

    \node[number,above=of net,xshift=-6em] {0};
    \node[number,above=of net,xshift=5.1em] {15};
    \node[number,above=of subnet,xshift=-2.3em] {16};
    \node[number,above=of subnet,xshift=2.1em] {23};
    \node[number,above=of host,xshift=-2.3em] {24};
    \node[number,above=of host,xshift=2.1em] {31};
  \end{tikzpicture}
  \caption{Возможная интерпретация адреса}
\end{figure}

На подсети можно разбивать, конечно, же и не по границе байта. С каждой подсетью ассоциируется \emph{маска подсети}, которой определяется, какая часть адреса отведена под идентификаторы сети и подсети, а какая --- под номер узла.

\subsection{Вещание}
\begin{itemize}
  \item \emph{Ограниченное вещание}. Адрес для ограниченного вещания --- 255.255.255.255. Вещание называется ограниченным, так как дейтаграммы, посланные на этот адрес, не уходят дальше маршрутизатора.
  \item \emph{Вещание на сеть}. В адресе для вещания на сеть идентификатор сети определяет адрес этой сети, а идентификатор узла состоит из одних единиц.
  \item \emph{Вещание на подсеть}. В адресе для вещания на подсеть идентификаторы сети и подсети определяют соответствующие адреса, а идентификатор узла состоит из одних единиц. Необходимо знать маску подсети, чтобы опознать вещание на подсеть.
  \item \emph{Вещание на все подсети}. В адресе для вещания на все подсети задан идентификатор сети, а адреса подсети и узла состоят из одних единиц. Как и при вещании на подсеть, для опознания того адреса надо знать маску подсети.
\end{itemize}

\subsection{Бесклассовая междоменная маршрутизация}
Она же \emph{Classless Inter-Domain Routing} (\emph{CIDR}). CIDR --- это механизм подсетей ``наизнанку''. Вместо увеличения CIDR уменьшает длину идентификатора сети в IP-адресе.

Пусть некоторой организации нужно 1000 IP-адресов. Ей выделяют четыре соседних идентификатора сетей класса C с общим префиксом от 200.10.4.0 до 200.10.7.0. Первые 22 бита этих идентификаторов одинаковы и представляют номер агрегированной сети, в данном случае 200.10.4.0. Как и для подсетей, для идентификации сетевой части IP-адреса используется маска сети. В данном случае она равна 255.255.252.0.

\subsection{Частные сети и NAT}
В настоящее время для частных сетей не выбирается произвольный блок IP-адресов. В RFC 1918 определены три блока адресов, которые не будут выделяться:
\begin{itemize}
  \item 10.0.0.0--10.255.255.255 (префикс 10/8);
  \item 172.16.0.0--172.31.255.255 (префикс 172.16/12);
  \item 192.168.0.0--192.168.255.255 (префикс 192.168/16).
\end{itemize}

Если использовать для своей сети один из этих блоков, то любой узел сможет обратиться к другому узлу в этой же сети, не опасаясь кофликта с глобально выделенным IP-адресом. Если нужен выход во внешний мир, то следует использовать \emph{преобразование сетевых адресов} (\emph{NAT}, \emph{Network Address Translation}). Принцип работы заключается в преобразовании между частными сетевыми адресами и одним или несколькими гобально выделенными IP-адресами. Большинство устройств с поддержкой NAT можно сконфигурировать в трех режимах:
\begin{itemize}
  \item \emph{Статический}. Адреса всех или некоторых узлов в частной сети отображаются на один и тот же фиксированный, глобально выделенный адрес.
  \item \emph{Выбор из пула}. Устройство с поддержкой NAT имеет пул глобально выделенных IP-адресов и динамически назначает один из них узлу, которому нужно связаться с узлом во внешней сети.
  \item \emph{PAT (Port Address Translation, преобразование адресов портов)}. Этот метод применяется, когда есть единственный глобально выделенный адрес. При этом каждый частный адрес отображается на один и тот же внешний адрес, но номер порта исходящего пакета заменяется уникальными значением, которое в дальнейшем используется для направления входящих пакетов на частный сетевой адрес.
\end{itemize}

\subsection{DHCP}
Он же \emph{Dynamic Host Configuration Protocol} (\emph{протокол динамической настройки узла}). Сетевой протокол, позволяющий компьютерам автоматически получать IP-адрес. Помимо адреса, DHCP также может сообщить клиенту дополнительные параметры, необходимые для работы в сети. Вот некоторые из часто используемых опций:
\begin{itemize}
  \item IP-адрес сетевого шлюза по умолчанию;
  \item маска подсети;
  \item адреса серверов DNS;
  \item доменное имя.
\end{itemize}

Протокол DHCP является клиент-серверным, использует протокол UDP. При этом сервер принимает сообщения на порту 67 и отправляет сообщения клиентам на порт 68.

Изначально клиент выполняет широковещательный запрос по всей сети с целью обнаружить доступные DHCP-серверы, при этом в качестве адреса источника указывается 0.0.0.0, а в качестве адреса назначения --- широковещательный адрес 255.255.255.255.

\subsection{DNS}
Она же \emph{Domain Name System} (\emph{система доменных имён}). Компьютерная распределенная система для получения информации о доменных именах. Чаще всего используется для получения IP-адреса по имени узла. Но также может и использоваться и для получения имени по адресу.

Основой DNS является представление об иерархической структуре доменного имени и \emph{зонах}. Каждый сервер, отвечающий за имя, может переложить ответственность за дальнейшую часть домена другому серверу.

Имя и IP-адрес не соответствуют друг другу взаимооднозначно. Например, одному адресу может быть сопоставлено несколько имен, что позволяет организовывать виртуальный хостинг. И наоборот --- одному имени может быть сопоставлено множество адресов, что позволяет балансировать нагрузку.

\subsubsection{Записи DNS}
Единицы хранения и передачи информации в DNS. Каждая запись состоит из следующих полей:

\begin{center}
  \begin{tabular}{lp{9cm}}
    \toprule
    Имя поля & Объяснение \\
    \midrule
    NAME & доменное имя, к которому привязана данная запись \\
    TTL (Time To Live) & допустимое время хранения записи в неответственном DNS-сервере \\
    TYPE & формат и назначение записи \\
    CLASS & тип сети \\
    RDLEN & длина поля данных \\
    RDATA & поле данных, формат и содержание которого зависит от типа \\
    \bottomrule
  \end{tabular}
\end{center}

Некоторые типы записей:
\begin{itemize}
  \item \emph{A} (\emph{address record}). Запись адреса связывает имя узла с адресом IP.
  \item \emph{AAAA} (\emph{IPv6 address record}). Связывает имя узла с адресом IPv6.
  \item \emph{CNAME} (\emph{canonical name record}). Запись канонического имени. Используется для перенаправление на другое имя.
  \item \emph{MX} (\emph{mail exchange}). Указывает почтовые серверы для данного домена.
  \item \emph{NS} (\emph{name server}). DNS-сервер для данного домена.
  \item \emph{PTR} (\emph{pointer}). Связывает IP-адрес узла с его каноническим именем.
\end{itemize}

Всю эту информацию (и не только) можно узнать, использую утилиту \emph{nslookup}.

\section{Дополнительные вопросы}
\label{sec:network-addition}

\subsection{Организация тайм-аута}
Существует три способа установки тайм-аута для операции ввода-вывода через сокета:
\begin{enumerate}
  \item Вызов функции \lstinline{alarm}, которая генерирует сингал \lstinline{SIGALRM}, когда истекает заданное время.
  \item Блокирование при ожидании ввода-вывода в функции \lstinline{select}, имеющей встроенное ограничение времени, вместо блокирования в вызове функций \lstinline{read} или \lstinline{write}.
  \item Использование параметров сокетов \lstinline{SO_RCVTIMEO} и \lstinline{SO_SNDTIMEO}.
\end{enumerate}

Все три варианта можно использовать с функциями ввода/вывода, но также нужно возможность работы с функцией \lstinline{connect}, поскольку процесс соединения TCP может занять длительное время (обычно 75 с).

\subsection{Алгоритм Нейгла}
\label{sec:nagle-algorithm}
Алгоритм был разработан для более эффективного использования сетевого канала. Так как минимальный размер сегмента TCP без данных равен 40 байт, то накладные расходы при посылке одного байта в сегменте составляет $4000\%$.

Соединение считается простаивающем, если в нем нет неподтвержденных данных. Новые данные от приложения не посылаются, пока соединение не перейдет в состояние простоя. RFC 1122 ослабляет это требование, разрешая посылать данные, если их хватает для заполнения целого сегмента. Условие Нейгла при этом выполняется: в соединении находится не более одного небольшого неподтвержденного сегмента.

Алгоритм Нейгла может плохо взаимодейстовать с другой возможностью TCP --- отложенным подтверждением. Когда прибывает сегмент от удаленного узла, TCP задерживает отправку ACK в предположении, что приложение скоро ответит на только что полученные данные. Поэтому ACK можно будет объединить с данными.

Если через $T_P$ обозначить время, необходимое серверу для обработки запроса и отправки ответа, но на каждую пару запрос/ответ уйдет $RTT + T_P$ мс. Если клиент посылает свой запрос в виде двух последовательных операций записи, то алгоритмы взаимодействуют так, что число сегментов, необходимых для получения ответа от сервера, равно четырем. Поэтому время, необходимое для получения логического ответа, может быть значительным.
