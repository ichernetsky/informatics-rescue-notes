\chapter{Сетевое программирование}
\label{ch:network}

\section{Протокол TCP}
\label{sec:tcp}
Он же \emph{протокол управления передачей}; он же \emph{Transmission Control Protocol}. Является протоколом, ориентированным на установление соединения и предоставляющим надежный двусторонний байтовый поток использующим его приложениям. TCP обеспечивает отправку и прием подтверждений, обработку тайм-оутов, повторную передачу и т.п.

Прежде всего, TCP обеспечивает установление соединений. Клиент TCP устанавливает соединение с выбранным сервером, обменивается с ним данными по этому соединению и затем разрывает его.

TCP надежен, но не магичен. Все отправленные данные должны быть подтверждены. Если этого нет, то данные автоматически пересылаются. Время ожидания подтверждения при этом увеличивается.

TCP может оценивать \emph{время обращения} (\emph{round-trip-time}, \emph{RTT}) между двумя узлами и таким образом определять необходимое время для получения подтверждения. TCP постоянно обновляет RTT.

TCP упорядочивает данные, связывая некоторый порядковый номер с каждым отправляемым им байтом. Пусть приложение записывает 2048 байт в сокет TCP, что приводит к отправке двух сегментов TCP. Первый из них содержит данные с порядковыми номерами 1--1024, второй --- с номерами 1025--2048. Если какой-либо сегмент приходит вне очереди, принимающий TCP заново упорядочит сегменты, основываясь на их порядковых номерах, перед тем как отправить данные принимающему приложению. Если TCP получает дублированные данные, он может определить, что они были дублированы, и они будут проигнорированы.

TCP обеспечивает \emph{управление потоком} (\emph{flow control}). TCP сообщает своему собеседнику, сколько именно байтов он хочет получить от него. Это называется объявлением \emph{окна} (\emph{window}).

\subsection{Трехэтапное рукопожатие}
\begin{enumerate}
  \item Сервер должен быть подготовлен для принятия входящего соединения. Это называется \emph{пассивным открытием} (\emph{passive open}).
  \item Клиент выполняет \emph{активное открытие} (\emph{active open}), то есть посылает сегмент SYN, чтобы сообщить серверу начальный порядковый номер данных. Этот сегмент содержит заголовок IP, заголовок TCP и параметры TCP.
  \item Сервер подтверждает получение клиентского сегмента SYN и вслед посылает свой собственный сегмент SYN, содержащий порядковый номер своих данных. SYN и ACK отсылаются в одном сегменте.
  \item Клиент подтверждает получение SYN сервера.
\end{enumerate}

\noindent
\begin{figure}[h!]
  \centering
  \begin{tikzpicture}
    \tikzstyle{tcpStep} = [];
    \node at (0,0) (client) {Клиент};
    \node at (4,0) (server) {Сервер};

    \draw[thick,->,-stealth] (client.south)  -- +(0,-4)
      node (client socket) [tcpStep,left,pos=.1] {\lstinline{socket}}
      node (connect) [tcpStep,left,pos=.35,text width=3.3cm, text justified] {\lstinline{connect}, блокировка, активное открытие}
      node (close connect) [tcpStep,left,pos=.75] {Завершение \lstinline{connect}};
    \draw[thick,->,-stealth] (server.south)  -- +(0,-4)
      node (server socket) [tcpStep,right,pos=.2] {\lstinline{socket, bind, listen}}
      node (accept) [tcpStep,,right,pos=.5] {\lstinline{accept}, блокировка}
      node (close accept) [tcpStep,right,pos=.85] {Завершение \lstinline{accept}};

    \draw[thick,->,-stealth] (connect) edge node [above,sloped] {SYN J} (accept);
    \draw[thick,->,-stealth] (accept) edge node [above,sloped] {SYN K, ACK J+1} (close connect);
    \draw[thick,->,-stealth] (close connect) edge node [above,sloped] {ACK K+1} (close accept);
  \end{tikzpicture}
  \caption{Трехэтапное рукопожатие TCP}
  \label{fig:tcp-handshake}
\end{figure}

Для подобного обмена нужно как минимум три пакета (cм. рис. \vref{fig:tcp-handshake}), поэтому он называется \emph{трехэтапным рукопожатием TCP} (\emph{TCP three-way handshake}).

\subsection{Параметры TCP}
Каждый сегмент SYN может содержать параметры TCP. Следом наиболее общеупотребительные:
\begin{itemize}
  \item \emph{Параметр MSS}. Позволяет объявить свой максимальный размер сегмента (maximum segment size, MSS) --- максимальное количество данных, которое он будет принимать в каждом сегмента TCP на этом соединении.
  \item \emph{Параметр масштабирования окна (Window scale option)}. Максимальный размер окна, который может быть установлен в заголовке TCP, равен $65535$, поскольку соответствующее поле занимает 16 бит. Но высокоскоростные соединения или линии с большой задержкой требуют большего размера окна для получения максимально возможной пропускной способности. Этот параметр определяет, что объявленная в заголовке TCP величина окна должна быть отмасштабирована --- сдвинута влево на 0--14 разрядов, предоставляя максимально возможное окно размером почти гигабайт ($65535 \times 2^{14}$).
  \item \emph{Временная метка (Timestamp option)}. Этот параметр необходим для высокоскоростных соединений, чтобы предотвратить возможное повреждение данных, вызванное приходом устаревших, задержавшихся и дублированных сегментов.
\end{itemize}

\subsection{Завершение соединения TCP}
Для завершения соединения требуется четыре сегмента.

\begin{enumerate}
  \item Один из сетевых узлов выполняет \emph{активное закрытие} (\emph{active close}). TCP этого узла отправляет сегмент FIN.
  \item Другой узел, получающий сегмент FIN, выполняет \emph{пассивное закрытие} (\emph{passive close}). Полученный сегмент FIN подтверждается TCP. Получение сегмента FIN передается приложению как признак конца файла.
  \item Через некоторое время после того, как приложение получило признак конца файла, оно закрывает свой сокет. TCP отправляет сегмент FIN первому узлу.
  \item Первый узел подтверждает получение сегмента FIN.
\end{enumerate}

Иногда первый FIN отправляется в сегменте вместе с данными. Также сегменты, отправляемые на шагах 2 и 3, могут быть объединены. Возможно, что между шагами 2 и 3 какие-то данные будут переданы от узла, выполняющего пассивное закрытие, к узлу, выполняющему активное закрытие. Это состояние называется \emph{частичным закрытием} (\emph{half-close}).

\subsection{Диаграмма состояний TCP}
Смотрите рис.~\ref{fig:tcp-states} на стр.~\pageref{fig:tcp-states}.

\begin{table}[h!]
  \caption{Состояния}
  \begin{center}
    \begin{tabular}{p{3.5cm}p{9cm}}
      \toprule
      \textbf{Состояние} & \textbf{Описание} \\
      \midrule
      CLOSED         & Закрыт. Сокет не используется \\
      LISTEN         & Ожидает входящих соединений \\
      SYN\_SENT      & Активно пытается установить соединение \\
      SYN\_RECEIVED  & Идет начальная синхронизация соединения \\
      ESTABLISHED    & Соединение установлено \\
      CLOSE\_WAIT    & Удаленная сторона отключилась; ожидание закрытия сокета \\
      FIN\_WAIT\_1   & Сокет закрыт; отключение соединения \\
      CLOSING        & Сокет закрыт, затем удаленная сторона отключилась; ожидание подтверждения \\
      LAST\_ACK      & Удаленная сторона отключилась, затем сокет закрыт; ожидание подтверждения \\
      FIN\_WAIT\_2   & Сокет закрыт; ожидание отключения удаленной стороны \\
      TIME\_WAIT     & Сокет закрыт, но ожидает пакеты, еще находящиеся в сети для обработки \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

% взята с http://www.texample.net/tikz/examples/tcp-state-machine/
\noindent
\begin{figure}[t!]
  \centering
  \begin{tikzpicture}[>=latex]
    %
    % Styles for states, and state edges
    %
    \tikzstyle{state} = [draw, very thick, fill=white, rectangle, minimum height=3em, minimum width=6em, node distance=6.5em, font={\sffamily\bfseries\footnotesize}]
    \tikzstyle{stateEdgePortion} = [black,thick];
    \tikzstyle{stateEdge} = [stateEdgePortion,->];
    \tikzstyle{edgeLabel} = [pos=0.5, text centered, font={\sffamily\small}];

    %
    % Position States
    %
    \node[state, name=closedStart] {CLOSED};
    \node[state, name=listen, below of=closedStart] {LISTEN};
    \node[state, name=synSent, below of=listen, right of=listen, xshift=7em] {SYN\_SENT};
    \node[state, name=synRcvd, below of=listen, left of=listen, xshift=-7em] {SYN\_RCVD};
    \node[state, name=established, below of=listen, node distance=14em] {ESTABLISHED};
    \node[state, name=finWait1, below of=established, left of=established, node distance=6em, xshift=-7.5em] {FIN\_WAIT\_1};
    \node[state, name=finWait2, below of=finWait1] {FIN\_WAIT\_2};
    \node[state, name=closeWait, below of=established, right of=established, node distance=6em, xshift=6.5em] {CLOSE\_WAIT};
    \node[state, name=closing, below of=established, node distance=14em] {CLOSING};
    \node[state, name=lastAck, below of=closeWait] {LAST\_ACK};
    \node[state, name=timeWait, below of=closing] {TIME\_WAIT};

    %
    % Connect States via edges
    %
    \draw ($(closedStart.south) + (-.5em,0)$)
        edge[stateEdge] node[edgeLabel, xshift=-3em]{\emph{Passive open}}
        ($(listen.north) + (-.5em,0)$);
    \draw ($(listen.north) + (.5em,0)$)
        edge[stateEdge] node[edgeLabel, xshift=2em]{\emph{Close}}
        ($(closedStart.south) + (.5em,0)$);

    \draw ($(listen.south) + (-1em,0)$)
        edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-2em, yshift=1em]{SYN/SYN + ACK}
        ($(synRcvd.east) + (0,1em)$);
    \draw ($(listen.south) + (1em,0)$)
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=1em, yshift=1em]{\emph{Send}/SYN}
        ($(synSent.west) + (0,1em)$);

    \draw ($(synRcvd.north) + (.5em,0)$)
        edge[stateEdge, bend left=45] node[edgeLabel,xshift=-4em]{\emph{Timeout}/RST}
        ($(closedStart.west) + (0,-.5em)$);

    \draw ($(synSent.north) + (-.5em,0)$)
        edge[stateEdge, bend right=45] node[edgeLabel,xshift=-1em, yshift=-1em]{\emph{Close}}
        ($(closedStart.east) + (0,-.5em)$);
    \draw ($(closedStart.east) + (0,.5em)$)
        edge[stateEdge, bend left=45] node[edgeLabel,xshift=4em,sloped,above]{\emph{Active open}/SYN}
        ($(synSent.north) + (.5em,0)$);

    \draw (synSent.west)
        edge[stateEdge] node[edgeLabel, yshift=1em]{SYN/SYN + ACK}
        (synRcvd.east);
    \draw (synRcvd)
        edge[stateEdge] node[edgeLabel, xshift=-2.5em]{\emph{Close}/FIN}
        (finWait1);

    \draw ($(synRcvd.east) + (0,-1em)$)
        edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-1em, yshift=-1em]{ACK}
        ($(established.north) + (-1em,0)$);
    \draw ($(synSent.west) + (0,-1em)$)
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=3em, yshift=-1em]{SYN + ACK/ACK}
        ($(established.north) + (1em,0)$);

    \draw ($(established.south) + (-1em,0)$)
        edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-1em, yshift=1em]{\emph{Close}/FIN}
        ($(finWait1.east) + (0,.5em)$);
    \draw ($(established.south) + (1em,0)$)
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=1em, yshift=1em]{FIN/ACK}
        ($(closeWait.west) + (0,1em)$);

    \draw (finWait1.south)
        edge[stateEdge] node[edgeLabel, xshift=-2em]{ACK}
        (finWait2.north);
    \draw ($(finWait1.east) + (0,-.5em)$)
        edge[stateEdge, bend left=22.5] node[edgeLabel, yshift=1em]{ACK}
        (closing.north);
    \draw (finWait1.south east)
        edge[stateEdge] node[edgeLabel, xshift=1em, yshift=2em, text width=3em]{FIN + ACK/ACK}
        (timeWait.north west);

    \draw (finWait2.south)
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=-2em, yshift=-1em]{FIN/ACK}
        (timeWait.west);

    \draw (closing)
        edge[stateEdge] node[edgeLabel, xshift=-2em]{ACK}
        (timeWait);

    \draw (closeWait)
        edge[stateEdge] node[edgeLabel,xshift=2.5em]{\emph{Close}/FIN}
        (lastAck);

    %
    % Connect lastAck to closed is slightly more complicated
    % no direct line-of-sight, so we need to take the scenic route
    %
    \coordinate (lastAck2ClosedA) at ($(lastAck.east) + (2em,0)$);
    \coordinate (lastAck2ClosedB) at ($(closedStart.north -| lastAck.east) + (2em,1em)$);
    \coordinate (lastAck2ClosedC) at ($(closedStart.north) + (0.5em,1em)$);
    \draw (lastAck.east) edge[stateEdgePortion] (lastAck2ClosedA);
    \draw (lastAck2ClosedA) edge[stateEdgePortion] node[edgeLabel,xshift=-1.5em, yshift=-4em]{ACK} (lastAck2ClosedB);
    \draw (lastAck2ClosedB) edge[stateEdgePortion] (lastAck2ClosedC);
    \draw (lastAck2ClosedC) edge[stateEdge] ($(closedStart.north) + (0.5em,0)$);

    %
    % likewise for timeWait to closed
    %
    \coordinate (timeWait2ClosedA) at ($(timeWait.south) + (0,-1em)$);
    \coordinate (timeWait2ClosedB) at ($(timeWait.south -| finWait2.west) + (-2em,-1em)$);
    \coordinate (timeWait2ClosedC) at ($(closedStart.north -| finWait2.west) + (-2em,1em)$);
    \coordinate (timeWait2ClosedD) at ($(closedStart.north) + (-0.5em,1em)$);
    \draw (timeWait.south) edge[stateEdgePortion] (timeWait2ClosedA);
    \draw (timeWait2ClosedA) edge[stateEdgePortion] (timeWait2ClosedB);
    \draw (timeWait2ClosedB) edge[stateEdgePortion] (timeWait2ClosedC);
    \draw (timeWait2ClosedC) edge[stateEdgePortion]
      node[edgeLabel, text width=12.25em, yshift=1.5em]{\emph{Timeout after two maximum segment lifetimes (2*MSL)}}
        (timeWait2ClosedD);
    \draw (timeWait2ClosedD) edge[stateEdge] ($(closedStart.north) + (-0.5em,0)$);

    % draw dotted lines around passive and active closes
    \begin{pgfonlayer}{background}
      \draw [join=round,black,dotted] ($(closeWait.north west) + (-1em, -1em)$) rectangle ($(lastAck.south east) + (1em, 1em)$);
      \draw [join=round,black,dotted] ($(finWait1.north west) + (-1em, -1em)$) rectangle ($(timeWait.south east) + (1em, 1em)$);
    \end{pgfonlayer}
  \end{tikzpicture}
  \caption{Диаграмма состояний TCP}
  \label{fig:tcp-states}
\end{figure}

\subsection{Состояние TIME\_WAIT}
Оно же --- время ожидания. Узел, выполняющий активное закрытие, проходит это состояние. Его продолжительность равно двум \emph{MSL} (\emph{maximum segment lifetime --- максимальное время жизни сегмента}). MSL --- это максимальное время, в течение которого дейтаграмма IP может оставаться в сети. Каждая дейтаграмма содержит 8-разрядное поле \emph{предельного количества прыжков} (\emph{hop limit}), максимальное значение которого равно 255. Считается, что пакет с максимальным значением этого пределеа не может существовать в сети более MSL секунд.

Причины существования состояния TIME\_WAIT:
\begin{itemize}
  \item необходимо обеспечить надежность разрыва двустороннего соединения TCP;
  \item необходимо подождать, когда истечет время жизни в сети старых дублированных сегментов.
\end{itemize}

Предположим, что последний сегмент ACK потерян. Сервер еще раз отправит свой последний сегмент FIN, поэтому клиент должен сохранять информацию о своем состоянии, что отправить завершающее подтверждение ACK повторно. Если бы клиент не сохранял информацию о состоянии, он ответил бы серверу сегментом RST, что сервер интерпретировал бы как ошибку.

Предположим, что только что завершилось соединение между двумя узлами, и через некоторое время снова создается соединение с теми же оконечными точками. TCP должен предотвратить появление старых дубликатов в новом соединении. Чтобы гарантировать это, TCP запрещает установление нового соединения, если старое соединение находится в состоянии TIME\_WAIT.

\section{Протокол UDP}
\label{sec:udp}
Он же \emph{протокол пользовательских дейтаграмм}; он же \emph{User Datagram Protocol}. Является протоколом, не ориентированным на установление соединения. Не гарантирует доставку дейтаграмм.

Приложение записывает в сокет UDP дейтаграмму, которая упаковывается в дейтаграмму IP и затем посылается в пункт назначения. Ее доставка не гарантируется. Если требуются какие-либо гарантии, вы сами должны реализовать их в своем приложении. Каждая дейтаграмма имеет длину, поэтому ее можно рассматривать как \emph{запись} (\emph{record}). В отличии от TCP, который является потоковым протоколом, без каких бы то ни было границ записей.

Если дейтаграмма UDP дублируется в сети, на принимающий узел могут быть доставлены два экземпляра. Также, если клиент UDP отправляет две дейтаграммы в одно и то же место назначения, их порядок может быть изменен сетью.

UDP не обеспечивает управления потоком. Быстрый отправитель UDP может передавать дейтаграммы с такой скоростью, с которой не может работать получатель UDP.

\subsection{Когда UDP предпочтительней TCP}
Преимущества UDP:

\begin{itemize}
  \item UDP поддерживает широковещательную и многоадресную передачу, поэтому использование UDP обязательно, если эти возможности необходимы приложению.
  \item UDP не требует установки и разрыва соединения. Он позволяет осуществить обмен запросом и ответом в двух пакетах. В случае TCP требуется около 10 пакетов, если для каждого обмена устанавливается новое соединение.
\end{itemize}

\section{POSIX API и не только}
\label{sec:network-api}

\subsection{Простейший DAYTIME клиент}
Ниже приведен простейший DAYTIME клиент. В качестве аргументов командной строки должены быть указаны IPv4-адрес и номер порта.

\begin{clst}{}{}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <error.h>
#include <errno.h>

#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define BUFFER_SIZE    1024

int main(int argc, char *argv[])
{
    char *server_ip;
    int server_port;
    int server_socket;
    struct sockaddr_in server_addr;
    char buffer[BUFFER_SIZE + 1];     /* extra byte for '\0' */
    int n, result;

    if (argc != 3)
        error(1, 0, "usage: date-client-basic <server-ip> <port>");

    server_ip = argv[1];
    server_port = atoi(argv[2]);
    if (server_port <= 0)
        error(1, 0, "port number must be a number > 0");

    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        (error(1, errno, "socket"));

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(server_port);

    if ((result = inet_pton(AF_INET, server_ip, &server_addr.sin_addr)) < 0)
        error(1, errno, "inet_pton");
    else if (result == 0)
        error(1, 0, "IPv4 address must be specified");

    if (connect(server_socket, (struct sockaddr *) &server_addr,
                sizeof(server_addr)) < 0)
        error(1, errno, "connect");

    while ((n = read(server_socket, buffer, BUFFER_SIZE)) > 0) {
        buffer[n] = '\0';
        if (printf("%s", buffer) < 0)
            error(1, 0, "error of printing to stdout");
    }

    if (n < 0)
        error(1, errno, "read");

    if (close(server_socket) < 0)
        error(1, errno, "close");

    return 0;
}
\end{clst}

Протестируем наш клиент. Для этого запустим локально простейший DAYTIME сервер, сколоченный из подручных средств\footnote{За значениями аргументов обращайтесь к соответствующей странице man.}:
\begin{plainlst}{}{}
% nc6 -l --half-close --continuous --exec date -p 45678
\end{plainlst}

Теперь запустим наш клиент:
\begin{plainlst}{}{}
% date-client-basic 127.0.0.1 45678
Fri Feb  3 01:22:43 FET 2012
\end{plainlst}

Voilà! работает! Рассмотрим пристальнее функции, использованные для построения клиента.

\subsubsection{Функция socket}
Сетевой ввод/вывод начинается с вызовы функции \lstinline{socket}, передавая ей тип желаемого протокола.
\begin{clst}{}{}
#include <sys/socket.h>
int socket(int family, int type, int protocol);
\end{clst}

Она возвращает неотрицательный дескриптор в случае успеха, \lstinline{-1} в случае ошибки. \lstinline{family} задает семейство протоколов.
\begin{table}[h!]
  \caption{Аргумент \lstinline{family} для функции \lstinline{connect}}
  \begin{center}
    \begin{tabular}{p{2.5cm}l}
      \toprule
      & \textbf{Описание} \\
      \midrule
      AF\_INET & Протоколы IPv4 \\
      AF\_INET6 & Протоколы IPv6 \\
      AF\_LOCAL & Протоколы доменных сокетов Unix \\
      AF\_ROUTE & Маршрутизирующие сокеты \\
      AF\_KEY & Сокет управления ключами \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

\begin{table}[h!]
  \caption{Тип сокета}
  \begin{center}
    \begin{tabular}{p{3.5cm}l}
      \toprule
      & \textbf{Описание} \\
      \midrule
      SOCK\_STREAM & Потоковый сокет \\
      SOCK\_DGRAM & Сокет дейтаграмм \\
      SOCK\_SEQPACKET & Сокет последовательных пакетов \\
      SOCK\_RAW & Символьный (неструктурированный) сокет \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

 Аргумент \lstinline{protocol} должен быть установлен в соответствии с используемым протоколом или равен нулю для выбора протокола, по умолчанию соответствующему заданному семейству и типу.
\begin{table}[h!]
  \caption{Возможные значения параметра \lstinline{protocol}}
  \begin{center}
    \begin{tabular}{p{3cm}l}
      \toprule
      & \textbf{Описание} \\
      \midrule
      IPPROTO\_TCP & Транспортный протокол TCP \\
      IPPROTO\_UDP & Транспортный протокол UDP \\
      IPPROTO\_SCTP & Транспортный протокол SCTP \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

Не все сочетания \lstinline{family} и \lstinline{type} допустимы. При успешном выполнении функция \lstinline{socket} возвращает неотрицательное число, аналогичное дескриптору файла. Чтобы получить дескриптор сокета, достаточно указать лишь семейство протоколов и тип сокета. Ни локальный адрес протокола, ни удаленный адрес протокола еще не заданы.

\subsubsection{Функция connect}
Функция \lstinline{connect} используется для установления соединения.
\begin{clst}{}{}
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);
\end{clst}

Аргумент \lstinline{sockfd} --- это дескриптор сокета, возвращенный функцией \lstinline{socket}. Структура адреса сокета должна содержать IP-адрес и номер порта сервера.

Клиенту не надо вызывать функцию \lstinline{bind} до вызова функции \lstinline{connect}, так как ядро само выберет и динамически назначаемый порт, и IP-адрес отправителя.

В случае сокета TCP функция \lstinline{connect} инициирует трехэтапное рукопожатие. Функция возвращает значение, только если установлено соединение или произошла ошибка. Возможны следующие ошибки:
\begin{enumerate}
  \item Если клиент не получает ответа на свой сегмент SYN, возвращается \lstinline{ETIMEDOUT}.
  \item Если на сегмент SYN сервер отвечает сегментом RST, это означает, что ни один процесс на узле сервера не находится в ожидании подключения к указанному порту. Клиенту возвращается \lstinline{ECONNREFUSED} при получении им сегмента RST.
  \item Если сегмент SYN клиента приводит к получению сообщения ICMP о недоступности получателя от какого-либо промежуточного маршрутизатора. Ядро сохраняет сообщение об ошибке, но продолжает отправлять сегменты SYN с определенными интервалами. Если же по истечении определенного фиксированного времени ответ не получен, то сохраненная ошибка ICMP возвращается процессу либо как \lstinline{EHOSTUNREACH}, либо как \lstinline{ENETUNREACH}.
\end{enumerate}

\subsubsection{Функции inet\_pton и inet\_ntop}
Преобразуют IP-адрес, заданный как строка, в двоичный формат представления с сетевым порядком байт, и наоборот. Симфолы p и n обозначают соответсвенно формат \emph{представления} и \emph{численный} формат.
\begin{clst}{}{}
#include <arpa/inet.h>
int inet_pton(int family, const char *str, void *addr);

#include <arpa/inet.h>
const char *inet_ntop(int family, const void *addr, char *str,
                      socklen_t len);
\end{clst}

Значение аргумента \lstinline{family} может быть либо \lstinline{AF_INET}, либо \lstinline{AF_INET6}. Если \lstinline{family} не поддерживается, функции возвращают ошибку со значением переменной \lstinline{errno}, равным \lstinline{EAFNOSUPPORT}. В качестве \lstinline{len} рекомендуется использовать макросы, определенные в \lstinline{<netinet/in.h>}:
\begin{clst}{}{}
#define  INET_ADDRSTRLEN    16
#define  INET6_ADDRSTRLEN   46
\end{clst}

\subsection{DAYTIME клиент, независящий от протокола}
В качестве адреса могут быть указаны IPv4-адрес, IPv6-адрес или же доменное имя; в качестве же порта можно указывать как численное значение, так и имя службы из файла \lstinline{/etc/services}.

\begin{clst}{}{}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <error.h>
#include <errno.h>

#include <netdb.h>
#include <unistd.h>
#include <sys/socket.h>

#define BUFFER_SIZE    1024

int main(int argc, char *argv[])
{
    char *server_host;
    char *service;
    int server_socket;
    struct addrinfo hints, *addr, *addrs;
    char buffer[BUFFER_SIZE + 1];     /* extra byte for '\0' */
    int n, result;

    if (argc != 3)
        error(1, 0, "usage: date-client <server-ip> <port>");

    server_host = argv[1];
    service = argv[2];

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(server_host, service, &hints, &addrs)) != 0)
        error(1, 0, "getaddrinfo: %s", gai_strerror(result));
    addr = addrs;

    do {
        if ((server_socket = socket(addr->ai_family, addr->ai_socktype,
                                    addr->ai_protocol)) < 0)
            continue;

        if (connect(server_socket, addr->ai_addr, addr->ai_addrlen) == 0)
            break;

        if (close(server_socket) != 0)
            error(1, errno, "close");
    } while ((addr = addr->ai_next) != NULL);

    if (addr == NULL)
        error(1, 0, "was not able to connect to specified network address and service");
    freeaddrinfo(addrs);

    while ((n = read(server_socket, buffer, BUFFER_SIZE)) > 0) {
        buffer[n] = '\0';
        if (printf("%s", buffer) < 0)
            error(1, 0, "error of printing to stdout");
    }

    if (n < 0)
        error(1, errno, "read");

    if (close(server_socket) < 0)
        error(1, errno, "close");

    return 0;
}
\end{clst}

Ниже приведен пример запуска клиента для локального DAYTIME сервера:
\begin{plainlst}{}{}
% date-client localhost 45678
Fri Feb  3 02:06:13 FET 201
\end{plainlst}

\subsubsection{Функция getaddrinfo}
Осущетсвляет трансляцию имен в адреса и служб в порты. Возвращает список структур \lstinline{sockaddr}. Функция \lstinline{getaddrinfo} скрывает все различия между протоколами в библиотеке функций.

\begin{clst}{}{}
#include <netdb.h>
int getaddrinfo(const char *node, const char *service,
                const struct addrinfo *hints,
                struct addrinfo **res);
\end{clst}

Через указатель \lstinline{res} функция возвращает указатель на связный список структур \lstinline{addrinfo}.
\begin{clst}{}{}
struct addrinfo {
    int              ai_flags;      /* AI_PASSIVE, AI_CANONNAME */
    int              ai_family;     /* AF_xxx */
    int              ai_socktype;   /* SOCK_xxx */
    int              ai_protocol;   /* 0 or IPPROTO_xxx for IPv4 or IPv6 */
    size_t           ai_addrlen;    /* ai_addr length */
    struct sockaddr *ai_addr;       /* pointer to canonical name */
    char            *ai_canonname;  /* pointer to socket address structure */
    struct addrinfo *ai_next;       /* pointer to next structure in list */
};
\end{clst}

Переменная \lstinline{node} --- это либо имя узла, либо строка адреса (точечно-десятичная запись для IPv4 или шестнадцатеричная строка для IPv6). Переменная \lstinline{service} --- это либо имя службы, либо строка, содержащая десятичный номер порта.

Аргумент \lstinline{hints} --- это либо пустой указатель, либо указатель на структуру \lstinline{addrinfo}, заполненную рекомендациями вызывающего процесса о типах информации, которую он хочет получить.
\begin{itemize}
  \item \lstinline{ai_flags} (несколько констант \lstinline{AI_xxx}, объединенных операцией ИЛИ);
  \item \lstinline{ai_family} (значение \lstinline{AF_xxx});
  \item \lstinline{ai_socktype} (значение \lstinline{SOCK_xxx});
  \item \lstinline{ai_protocol}.
\end{itemize}

Наиболее важные возможные значения поля \lstinline{ai_flags}:
\begin{itemize}
  \item \lstinline{AI_PASSIVE} указывает, что сокет будет использоваться для пассивного открытия;
  \item \lstinline{AI_CANONNAME} указывает функции на необходимость возвратить каноническое имя узла;
\end{itemize}

\subsection{Последовательный DAYTIME сервер}
В качестве аргументов командной строки может быть указан номер порта для прослушивания.

\begin{clst}{}{}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <error.h>
#include <errno.h>

#include <netdb.h>
#include <unistd.h>
#include <sys/socket.h>

#include <time.h>

#define BUFFER_SIZE    1024
#define BACKLOG        5

int main(int argc, char *argv[])
{
    int listen_socket, client_socket;
    socklen_t socket_length;
    char *service;
    struct addrinfo hints, *addr, *addrs;
    struct sockaddr_storage client_addr;
    char buffer[BUFFER_SIZE + 1];     /* extra byte for '\0' */
    time_t ticks;
    int result;
    const int on = 1;

    if (argc != 2)
        error(1, 0, "usage: echo-client-basic <port>");

    service = argv[1];

    memset(&hints, 0, sizeof(hints));
    hints.ai_flags = AI_PASSIVE;
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(NULL, service, &hints, &addrs)) != 0)
        error(1, 0, "getaddrinfo: %s", gai_strerror(result));
    addr = addrs;

    do {
        if ((listen_socket = socket(addr->ai_family, addr->ai_socktype,
                                    addr->ai_protocol)) < 0)
            continue;

        if (setsockopt(listen_socket, SOL_SOCKET, SO_REUSEADDR,
                       &on, sizeof(on)) != 0)
            error(1, errno, "setsockopt");

        if (bind(listen_socket, addr->ai_addr, addr->ai_addrlen) == 0)
            break;

        if (close(listen_socket) != 0)
            error(1, errno, "close");
    } while ((addr = addr->ai_next) != NULL);

    if (addr == NULL)
        error(1, 0, "was not able to bind to specified network address and service");
    freeaddrinfo(addrs);

    if (listen(listen_socket, BACKLOG) != 0)
        error(1, errno, "listen");

    for (;;) {
        socket_length = sizeof(client_addr);
        if ((client_socket = accept(listen_socket,
                                    (struct sockaddr *) &client_socket,
                                    &socket_length)) < 0)
            error(1, errno, "accept");

        ticks = time(NULL);
        snprintf(buffer, sizeof(buffer), "%.24s\r\n", ctime(&ticks));
        if (write(client_socket, buffer, strlen(buffer)) < 0)
            error(1, errno, "write");
        /*
         *   ignoring the fact that write can write less bytes
         *   than specified
         */

        if (close(client_socket) < 0)
            error(1, errno, "close");
    }

    if (close(listen_socket) < 0)
        error(1, errno, "close");

    return 0;
}
\end{clst}

По умолчанию нельзя связывать сокет с портом, который только что использовался, так как сетевая подсистема ядра ожидает ещё пакеты предыдущего соединения, которые могли задержаться в сети. Время ожидания равно TIME\_WAIT. С помощью вызова \lstinline{setsockopt} мы преодолеваем это поведение.

Проверим наш сервер:
\begin{plainlst}{}{}
% date-server 45678
# in another shell
% nc6 localhost 45678
Fri Feb  3 07:37:05 2012
\end{plainlst}

Как и ожидалось: работает!

\subsubsection{Функция bind}
Функция \lstinline{bind} связывает сокет с локальным адресом протокола, комбинацией адреса IP с номером порта.
\begin{clst}{}{}
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
\end{clst}

Вторым аргументом является указатель на специфичный для протокола адрес, а третий аргумент --- это размер структуры адреса.

С помощью функции \lstinline{bind} процесс может связать конкретный IP-адрес с сокетом. IP-адрес должен соответствовать одному из интерфейсов узла. Так определяется IP-адрес, который будет использоваться для отправляемых через сокет IP-дейтаграмм. При этом на сокет накладывается ограничение: он может принимать только такие входящие соединения, которые предназначены именно для этого IP-адреса.

Если зададать нулевой номер порта, то при вызове функции \lstinline{bind} ядро выберет динамически назначаемый порт. Но если задать IP-адрес с помощью символов подстановки, ядро не выберет локальный IP-адрес, пока к сокету не присоединиться клиент либо на сокет не будет отправлена дейтаграмма.

В случае IPv4 универсальный адрес состоящий из символов подстановки, задается константой \lstinline{INADDR_ANY}.
\begin{clst}{}{}
struct sockaddr_in addr;
servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
\end{clst}

\subsubsection{Функция listen}
Функция \lstinline{listen} вызывается только сервером TCP и выполняет два действия.
\begin{enumerate}
  \item Когда сокет создается с помощью функции \lstinline{socket}, считается, что это активный сокет, то есть клиентский сокет, который запустит функцию \lstinline{connect}. Функция \lstinline{listen} преобразует неприсоединенный сокет в пассивный сокет, запросы на подключение к которому начинают приниматься ядром.
  \item Второй аргумент этой функции задает максимальное число соединений, которые ядро может помещать в очередь этого сокета.
\end{enumerate}

\begin{clst}{}{}
#include <sys/socket.h>
int listen(int sockfd, int backlog);
\end{clst}{}{}

Чтобы уяснить смысл аргумента \lstinline{backlog}, необходимо понять, что для данного прослушиваемого сокета ядро поддерживает две очереди:
\begin{enumerate}
  \item \emph{Очередь не польностью установленных соединений} (\emph{incomplete connection queue}), содержащую запись для каждого сегмента SYN, пришедшег от клиента, для которого сервер ждет завершения трехэтапного рукопожатия TCP.
  \item \emph{Очередь польностью установленных соединений} (\emph{complete connection queue}), содержащую запись для каждого клиента, с которым завершилось трехэтапное рукопожатие TCP.
\end{enumerate}

Когда в очередь не польностью установленных соединений добавляется новая запись, параметры прослушиваемого сокета копируются на создаваемое соединение. Если трехэтапное рукопожатие завершается нормально, запись переходит из очереди не полностью установленных соединений в конец очереди полностью установленных соединений. Когда процесс вызывает функцию \lstinline{accept}, ему возвращается первая запись из очереди полностью установленных соединений, а если очередь пуста процесс переходит в состояние ожидания.

Некоторые заметки:
\begin{itemize}
  \item Если трехэтапное рукопожатие завершается нормально, запись остается в очереди не полностью установленных соединений на время одного периода обращения.
  \item Если очереди заполнены, когда приходит клиентский сегмент SYN, то TCP игнорирует приходящий сегмент SYN и не посылает RST. Это происходит потому, что состояние считается временным, и TCP клиента должен еще раз передать свой сегмент SYN, для которого в ближайшее время вероятно, найдется место в очереди.
  \item Данные, которые приходят после завершения трехэтапного рукопожатия, но до того, как сервер вызывает функцию \lstinline{accept}, должны помещаться в очередь TCP-сервера, пока не будет заполнен приемный буфер.
\end{itemize}

\subsubsection{Функция accept}
Функция \lstinline{accept} вызывается сервером TCP для возвращения следующего установленного соединения из начала очереди полностью установленных соединений. Если очередь полностью установленных соединений пуста, процесс переходит в состояние ожидания (по умолчанию предполагается блокируемый сокет).
\begin{clst}{}{}
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
\end{clst}

Аргументы \lstinline{addr} и \lstinline{addrlen} используется для возвращения адреса протокола подключившегося процесса (клиента). Если функция \lstinline{accept} завершилась успешно, она возвращает новый дескриптор, автоматически созданный ядром. Этот дескриптор используется для обращения к соединению TCP с конкретным клиентом. Функция \lstinline{accept} принимает \emph{прослушиваемый сокет} и возвращает \emph{присоединенный сокет}.

\subsection{Мультиплексирование ввода/вывода}
Существует возможность получать уведомления о том, что выполняется одно или несколько условий для ввода-вывода (например, присутствуют данные для считывания или дескриптор готов к записи новых данных). Эта возможность называется \emph{мультиплексированием} ввода-вывода.

Мультиплексирование ввода-вывода обычно используется сетевыми приложениями в следующих случаях:
\begin{itemize}
  \item Когда клиент обрабатывает множество дескрипторов (обычно интерактивный ввод и сетевой сокет), должно использоватся мультиплексирование ввода-вывода.
  \item Клиент обрабатывает множество сокетов.
  \item Если сервер TCP обрабатывает и прослушиваемый сокет, и присоединенные сокеты, обычно используется мультиплексирование ввода-вывода.
  \item Если сервер работает и с TCP, и с UDP, обычно также используется мультиплексирование ввода-вывода.
\end{itemize}

\subsubsection{Функция select}
Эта функция позволяет процессу сообщить ядру, что необходимо подождать, пока не произойдет одно из некоторого множества событий, и вывести процесс из состояния ожидания, только когда произойдет одно или несколько таких событий или когда пройдет заданное количество времени.

\begin{clst}{}{}
#include <sys/select.h>
int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);
\end{clst}

Последний аргумент, который сообщает ядру, сколько следует ждать, пока один из заданных дескрипторов не будет готов. Структура \lstinline{timeval} задает число секунд и микросекунд:
\begin{clst}{}{}
struct timeval {
    long tv_sec;   /* seconds */
    long tv_usec;  /* microseconds */
};
\end{clst}

С помощью этого аргумента можно реализовать три сценария:
\begin{enumerate}
  \item Завершать работу, только когда один из заданных дескрипторов готов для ввода-вывода. Для этого нужно определить \lstinline{timeout} как \lstinline{NULL}.
  \item Завершение происходит, когда один из заданных дескрипторов готов для ввода-вывода или же тайм-аут истекает.
  \item Завершение происходит сразу же после проверки дескрипторов. Аргумент \lstinline{timeout} должен указывать на структуру \lstinline{timeval}, а значение таймера должно быть нулевым.
\end{enumerate}

Три аргумента \lstinline{readfds}, \lstinline{writefds} и \lstinline{exceptfds} определяют наборы дескрипторов, которые ядро должно проверить на возможность чтения и записи и на наличие исключений. Манипулировать ими нужно с помощью предопределенных макросов:
\begin{clst}{}{}
void FD_ZERO(fd_set *fds);           /* clears a set*/
void FD_SET(int fd, fd_set *fds);    /* add a descriptor to a set */
void FD_CLR(int fd, fd_set *fds);    /* remove a descriptor from a set */
int  FD_ISSET(int fd, fd_set *fds);  /* tests whether a descriptor is
                                        part of a set */
\end{clst}

Константа \lstinline{FD_SETSIZE} является максимальным числом дескрипторов для типа данных \lstinline{fd_set}.

Сокет готов для чтения, если выполнено хотя бы одно из следующих условий:
\begin{enumerate}
  \item Число байтов данных в буфере приёма сокета больше или равно текущему значению минимального количества данных (low water-mark).
  \item На противоположном конце соединение закрывается. Функция считывания данных возвратит признак конца файла.
  \item Сокет является прослушиваемым, и число установленных соединений ненулевое.
  \item Ошибка сокета, ожидающая обработки.
\end{enumerate}

Сокет готов для записи, если выполнено одно из следующих условий:
\begin{enumerate}
  \item Количество байтов в буфере отправки сокета больше или равно текущему значению минимального количества данных для буфера отправки сокета и либо сокет, является присоединенным, либо сокету не трубуется соединение.
  \item Получатель, которому отправляеются данные, закрывает соединение. Операция записи в сокет сгенерирует сигнал \lstinline{SIGPIPE}.
  \item Ошибка сокета, ожидающая обработки.
\end{enumerate}

Исключительная ситуация, требующая обработки, может возникнуть на сокете в том случае, если на сокет приходят внеполосные данные.

\begin{table}[h!]
  \begin{center}
    \begin{tabular}{p{5cm}p{2.5cm}p{2.5cm}p{3cm}}
      \toprule
      \textbf{Условие} & \textbf{Сокет готов для чтения} & \textbf{Сокет готов для записи} & \textbf{Исключительная ситуация} \\
      \midrule
      Данные для чтения & \circle*{5} & & \\
      Считывающая половина соединения закрыта & \circle*{5} & & \\
      Для прослушиваемого сокета готово новое соединение & \circle*{5} & & \\
      Пространство, доступное для записи & & \circle*{5} & \\
      Записывающая половина соединения закрыта & & \circle*{5} & \\
      Ошибка, ожидающая обработки & \circle*{5} & \circle*{5} & \\
      Внеполосные данные TCP & & & \circle*{5} \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

\subsubsection{Функция poll}
Функция \lstinline{poll} аналогична функции \lstinline{select}.
\begin{clst}{}{}
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
\end{clst}

Первый аргумент --- это указатель на первый элемент массива структур. Каждый элемент массива --- это структура \lstinline{pollfd}, задающая условия, проверяемые для данного дескриптора \lstinline{fd}.
\begin{clst}{}{}
struct pollfd {
    int   fd;         /* file descriptor */
    short events;     /* requested events */
    short revents;    /* returned events */
};
\end{clst}

\begin{table}[h!]
  \caption{Различные значения флагов \lstinline{events} и \lstinline{revents}}
  \begin{center}
    \begin{tabular}{p{2cm}ccp{6cm}}
      \toprule
      \textbf{Константа} & \textbf{events} & \textbf{revents} & \textbf{Описание} \\
      \midrule
      POLLIN & \circle*{3} & \circle*{3} & Можно считывать данные \\
      POLLPRI & \circle*{3} & \circle*{3} & Можно считывать данные с высоким приоритетом \\
      \midrule
      POLLOUT & \circle*{3} & \circle*{3} & Можно записывать данные\\
      \midrule
      POLLERR & & \circle*{3} & Произошла ошибка \\
      POLLHUP & & \circle*{3} & Произошёл разрыв соединения \\
      POLLNVAL & & \circle*{3} & Дескриптор не соответствует открытому файлу \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

Аргумент \lstinline{timeout} определяет, как долго функция находится в ожидании перед завершением.
\begin{table}[h!]
  \begin{center}
    \begin{tabular}{lp{8cm}}
      \toprule
      \textbf{Значение} & \textbf{Описание} \\
      \midrule
      $< 0$ & Ждать вечно \\
      $0$ & Возвращать управление немедленно, без блокирование \\
      $> 0$ & Ждать в течение указанного числа миллисекунд \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

\subsubsection{epoll}
\emph{epoll} — масштабируемая система уведомлений о произошедших событиях, которая появилась в Linux 2.5.44. Более эффективна, чем системные вызовы \lstinline{select} и \lstinline{poll}. Аналог \emph{kqueue} в FreeBSD.

\begin{clst}{}{}
#include <sys/epoll.h>
int epoll_create(int size);
\end{clst}

Функция \lstinline{epoll_create} создает epoll-экземпляр и возвращает файловый дескриптор, соответствующий этому экземпляру. Аргумент \lstinline{size} в текущей реализации не используется, достаточно чтобы он был не меньше нуля. Когда дескриптор больше не нужен, его следует закрыть вызовом функции \lstinline{close}.

\begin{clst}{}{}
#include <sys/epoll.h>
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
\end{clst}

Этот системный вызов выполняет операции над epoll-экземпляром, на который ссылается файловый дескриптор \lstinline{epfd}. Допустимые значения \lstinline{op}:
\begin{itemize}
  \item \lstinline{EPOLL_CTL_ADD}. Регистрирует \lstinline{fd} для уведомления о событиях, указанных в \lstinline{event}.
  \item \lstinline{EPOLL_CTL_MOD}. Изменяет множество событий, подлежащих уведомлению, для дескриптора \lstinline{fd}.
  \item \lstinline{EPOLL_CTL_DEL}. Удаляет дескриптор \lstinline{fd} из epoll-экземпляра.
\end{itemize}

Структура \lstinline{epoll_event} выглядит следующим образом:
\begin{clst}{}{}
typedef union epoll_data {
    void        *ptr;
    int          fd;
    __uint32_t   u32;
    __uint64_t   u64;
} epoll_data_t;

struct epoll_event {
    __uint32_t   events;      /* epoll events */
    epoll_data_t data;        /* user data variable */
};
\end{clst}

\lstinline{events} — битовая карта, состоящая из следующих значений:
\begin{itemize}
  \item \lstinline{EPOLLIN}. Можно читать данные.
  \item \lstinline{EPOLLOUT}. Можно записывать данные.
  \item \lstinline{EPOLLRDHUP}. Узел на другом конце соединения потокового сокета закрыл соединение или только половину соединения для записи.
  \item \lstinline{EPOLLPRI}. Доступны приоритетные данные для чтения.
  \item \lstinline{EPOLLERR}. Произошла ошибка. \lstinline{epoll_wait} всегда ожидает это, поэтому нет необходимости устанавливать это значение в \lstinline{events}.
  \item \lstinline{EPOLLHUP}. Произошел разрыв соединения. \lstinline{epoll_wait} всегда ожидает это, поэтому нет необходимости устанавливать это значение в \lstinline{events}.
  \item \lstinline{EPOLLET}. Устанавливает \emph{edge-triggered} поведение для данного дескриптора. \emph{Level-triggered} поведение устанавливается по умолчанию.
  \item \lstinline{EPOLLONESHOT}. Если установлено, то после чтения события с помощью \lstinline{epoll_wait}, события больше не доставляются для данного дескриптора до тех пор, пока они вновь не включены с помощью \lstinline{epoll_ctl} и \lstinline{EPOLL_CTL_MOD}.
\end{itemize}

Допустим есть следующая последовательность событий:
\begin{enumerate}
  \item Дескриптор \lstinline{rfd}, который используется для чтения из канала, зарегистрирован в epoll.
  \item В канал записаны 2kB данных.
  \item Вызов \lstinline{epoll_wait}, в следствие чего будет извествно, что из \lstinline{rfd} можно читать данные.
  \item Происходит чтение из канала 1kB данных.
  \item Вызов \lstinline{epoll_wait}.
\end{enumerate}

В level-triggered режиме второй вызов \lstinline{epoll_wait} не заблокируется, в edge-triggered режиме --- наоборот.

\begin{clst}{}{}
#include <sys/epoll.h>
int epoll_wait(int epfd, struct epoll_event *events,
               int maxevents, int timeout);
\end{clst}

Ожидает событий, зарегистрированные в epoll-экземпляре, на который указывает \lstinline{epfd}. \lstinline{events} указывает на массив структ \lstinline{epoll_event}, в котором будет информация о событиях, количество которых меньше или равно \lstinline{maxevents}. \lstinline{timeout} аналогичен аргументу \lstinline{timeout} функции \lstinline{poll}.

\subsection{Варианты реализации параллельного сервера}

\subsubsection{По процессу на клиента}
Сервер порождает процесс для каждого клиента.
\begin{itemize}
  \item[\Checkmark] Простейшая и наиболее быстрая реализация среди всех здесь описываемых, особенно если использовать inetd.
  \item[\Checkmark] Масштабируется с ростом числа процессоров.
  \item[\Checkmark] Ошибки в одном процессе не приводят к отказу в обслуживании остальных клиентов.
  \item[\XSolidBrush] Создание процесса -- довольно ресурсоёмкая операция, поэтому метод неприменим при большом количестве одновременно работающих клиентов.
  \item[\XSolidBrush] Несмотря на масштабируемость, модель тяжела и в среднем гораздо менее эффективна, чем другие.
\end{itemize}

Запрограммируем эту модель обработки на \emph{Python}. Здесь и далее мы будем использовать низкоуровневые функции для лучшего понимания происходящего, в практике же, как правило, следует использовать стандартную и иные библиотеки для сетевого ввода/вывода.

Реализовывать мы будет простой \emph{echo}-сервер, который отправляет клиенту все полученные данные от него. Сперва-наперво напишем функцию разбора аргументов:
\begin{pylst}{}{}
import argparse

def parse_args(description):
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('port', type=int, help='port to bind')
    return parser.parse_args()
\end{pylst}

Следом — функция, которая создаёт пассивный сокет, на который будут приниматся соединения клиентов:
\begin{pylst}{}{}
import socket
import sys

def listening_socket(port):
    host = None
    family = socket.AF_UNSPEC
    socket_type = socket.SOCK_STREAM
    protocol = 0
    flags = socket.AI_PASSIVE

    server_socket = None
    for addrinfo in socket.getaddrinfo(host, port, family, socket_type,
                                       protocol, flags):
        family, socket_type, protocol, canonical_name, addr = addrinfo

        try:
            server_socket = socket.socket(family, socket_type, protocol)
        except socket.error, msg:
            server_socket = None
            continue

        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        try:
            server_socket.bind(addr)
            server_socket.listen(1)
        except socket.error, msg:
            server_socket.close()
            server_socket = None
            continue

        break

    if server_socket is None:
        print 'could not open socket'
        sys.exit(1)

    return server_socket
\end{pylst}

И напоследок: функция, которая считывает по порциям данные из сокета и вновь их отправляет обратно по этому же сокету клиенту.
\begin{pylst}{}{}
def communicate(client_socket):
    while True:
        data = client_socket.recv(1024)
        if not data:
            break
        client_socket.sendall(data)
\end{pylst}

Поместим все три функции в отдельный модуль \lstinline{aux}. Тогда наш сервер будет выглядеть так:
\begin{pylst}{}{}
import os
import signal

import aux

def main():
    args = aux.parse_args('Echo server with fork processing model.')
    server_socket = aux.listening_socket(args.port)

    signal.signal(signal.SIGCHLD, signal.SIG_IGN)

    while True:
        client_socket, client_addr = server_socket.accept()

        if os.fork() == 0:
            server_socket.close()
            aux.communicate(client_socket)
            client_socket.close()
            return
        else:
            client_socket.close()

if __name__ == '__main__':
    main()
\end{pylst}

При реализации \emph{fork}-модели следует помнить, что нужно корректно обрабатывать завершение потомков, чтобы они не переходили в состояние зомби по окончании работы с сокетом. Это достигается двумя способами:
\begin{enumerate}
  \item явное игнорирование сигнала \lstinline{SIGCHLD}, который посылается родителю при завершении каждого потомка (имеено так мы и сделали в вышеприведённой реализации);
  \item установка обработчика для сигнала \lstinline{SIGCHLD}, который выполняет, например, \lstinline{os.waitpid(-1, os.WNOHANG)}.
\end{enumerate}

\subsubsection{FSM с использованием информации о состоянии сокета}
Сервер может использовать однопроцессную \textbf{FSM} (Finite State Machine) архитектуру, используя те или иные методы получения данных о состоянии сокетов (\lstinline{select}, \lstinline{poll} и т.п.).
\begin{itemize}
  \item[\Checkmark] Эффективный метод с точки зрения CPU.
  \item[\XSolidBrush] Не масштабируется с ростом числа процессоров.
  \item[\XSolidBrush] Серверные FSM, как правило, достаточно сложны и требуют тщательного подхода при проектировании.
  \item[\Checkmark] Имея готовую реализацию, написание сервера на FSM значительно упрощается.
  \item[\XSolidBrush] Блокирующие либо иначе продолжительные по времени операции недопустимы.
\end{itemize}

Проблему с длительными операциями можно решить, используя для их выполнения вспомогательные процессы или потоки.

\begin{pylst}{Реализация с использованием \lstinline{select}}{}
import select

import aux

def main():
    args = aux.parse_args('Echo server with select-processing model.')
    server_socket = aux.listening_socket(args.port)

    socket_to_data = {}
    client_sockets = []
    all_sockets = [server_socket]

    while True:
        readable, _, _ = select.select(all_sockets, [], [], 0.05)

        if server_socket in readable:
            client_socket, _ = server_socket.accept()

            socket_to_data[client_socket] = ''
            client_sockets.append(client_socket)
            all_sockets.append(client_socket)

            readable.remove(server_socket)

        for client_socket in readable:
            data = client_socket.recv(1024)
            if not data:
                del socket_to_data[client_socket]
                client_sockets.remove(client_socket)
                all_sockets.remove(client_socket)
                client_socket.close()
            else:
                socket_to_data[client_socket] += data

        check_writability = [cs for cs in client_sockets
                             if socket_to_data[cs]]

        _, writable, _ = select.select([], check_writability, [], 0.05)

        for client_socket in writable:
            data = socket_to_data[client_socket]
            n = client_socket.send(data)
            if n > 0:
                socket_to_data[client_socket] = data[n:]

if __name__ == '__main__':
    main()
\end{pylst}

\begin{pylst}{Реализация с использованием \lstinline{poll}}{}
import select

import aux

def main():
    args = aux.parse_args('Echo server with poll-processing model.')
    server_socket = aux.listening_socket(args.port)
    server_fileno = server_socket.fileno()

    fileno_to_data = {}
    fileno_to_socket = {}

    read_poll = select.poll()
    read_poll.register(server_fileno, select.POLLIN)

    while True:
        for fileno, eventmask in read_poll.poll(50):
            if fileno == server_fileno:
                client_socket, _ = server_socket.accept()
                client_fileno = client_socket.fileno()

                fileno_to_data[client_fileno] = ''
                fileno_to_socket[client_fileno] = client_socket

                read_poll.register(client_fileno, select.POLLIN)
            else:
                client_socket = fileno_to_socket[fileno]

                data = client_socket.recv(1024)
                if not data:
                    read_poll.unregister(fileno)
                    del fileno_to_data[fileno]
                    del fileno_to_socket[fileno]
                    client_socket.close()
                else:
                    fileno_to_data[fileno] += data

        check_writability = [f for f, d in fileno_to_data.iteritems() if d]
        if not check_writability:
            continue

        write_poll = select.poll()
        for fileno in check_writability:
            write_poll.register(fileno, select.POLLOUT)

        for fileno, eventmask in write_poll.poll(50):
            if eventmask & (select.POLLERR | select.POLLHUP):
                read_poll.unregister(fileno)
                fileno_to_socket[fileno].close()
                del fileno_to_data[fileno]
                del fileno_to_socket[fileno]
                continue

            client_socket = fileno_to_socket[fileno]
            data = fileno_to_data[fileno]

            n = client_socket.send(data)
            if n > 0:
                fileno_to_data[fileno] = data[n:]

if __name__ == '__main__':
    main()
\end{pylst}

С помощью таймаутов при вызове \lstinline{select} и \lstinline{poll} нагрузка на CPU существенно снижается.

\subsubsection{По потоку на клиента}
Сервер — процесс, использующий потоки для взаимодействия с клиентами.
\begin{itemize}
  \item[\Checkmark] Небольшая сложность разработки.
  \item[\Checkmark] Масштабируется с ростом числа процессоров.
  \item[\XSolidBrush] Требуется проработка механизмов защиты общих данных.
  \item[\XSolidBrush] Трудная отладка в сравнении с процессами.
\end{itemize}

Естественно, следом идёт наша реализация этой модели. Как видно, отличий от реализации \emph{fork}-модели не так уж и много.
\begin{pylst}{}{}
import threading

import aux

class Worker(threading.Thread):
    def __init__(self, client_socket):
        super(Worker, self).__init__()

        self.client_socket = client_socket
        self.daemon = True

    def run(self):
        aux.communicate(self.client_socket)
        self.client_socket.close()

def main():
    args = aux.parse_args('Echo server with threaded-processing model.')
    server_socket = aux.listening_socket(args.port)

    while True:
        client_socket, client_addr = server_socket.accept()

        worker = Worker(client_socket)
        worker.start()

if __name__ == '__main__':
    main()
\end{pylst}

\subsubsection{FSM c использованием событий}
\begin{itemize}
  \item[\Checkmark] Из-за модели передачи событий вместо передачи состояний очень эффективен при обслуживании очень большого количества клиентов, только часть из которых активна. Состояния неактивных сокетов не вызывают расхода ресурсов.
  \item[\Checkmark] Не имеет ограничений на максимальное количество обслуживаемых сокетов.
  \item[\XSolidBrush] Все еще FSM.
\end{itemize}

На Linux для этой модели следует использовать \emph{epoll}.

\begin{pylst}{Реализация с использованием \lstinline{epoll}}{}
import select

import aux

def main():
    args = aux.parse_args('Echo server with epoll-processing model.')
    server_socket = aux.listening_socket(args.port)
    server_fileno = server_socket.fileno()

    fileno_to_data = {}
    fileno_to_socket = {}

    read_epoll = select.epoll()
    read_epoll.register(server_fileno, select.EPOLLIN)

    while True:
        for fileno, eventmask in read_epoll.poll(0.05):
            if fileno == server_fileno:
                client_socket, _ = server_socket.accept()
                client_fileno = client_socket.fileno()

                fileno_to_data[client_fileno] = ''
                fileno_to_socket[client_fileno] = client_socket

                read_epoll.register(client_fileno, select.EPOLLIN)
            else:
                client_socket = fileno_to_socket[fileno]

                data = client_socket.recv(1024)
                if not data:
                    read_epoll.unregister(fileno)
                    del fileno_to_data[fileno]
                    del fileno_to_socket[fileno]
                    client_socket.close()
                else:
                    fileno_to_data[fileno] += data

        check_writability = [f for f, d in fileno_to_data.iteritems() if d]
        if not check_writability:
            continue

        write_epoll = select.epoll()
        for fileno in check_writability:
            write_epoll.register(fileno, select.EPOLLOUT)

        for fileno, eventmask in write_epoll.poll(0.05):
            if eventmask & (select.EPOLLERR | select.EPOLLHUP):
                read_epoll.unregister(fileno)
                fileno_to_socket[fileno].close()
                del fileno_to_data[fileno]
                del fileno_to_socket[fileno]
                continue

            client_socket = fileno_to_socket[fileno]
            data = fileno_to_data[fileno]

            n = client_socket.send(data)
            if n > 0:
                fileno_to_data[fileno] = data[n:]

        write_epoll.close()

if __name__ == '__main__':
    main()
\end{pylst}

\section{Организация сетей и адресация}
\label{sec:network-setup}

Стек \emph{TCP/IP} условно делится на четыре уровня:
\begin{itemize}
  \item \emph{прикладной (application)}: \emph{HTTP}, \emph{FTP} и т. д.;
  \item \emph{транспортный (transport)}: \emph{TCP}, \emph{UDP} и т. д.;
  \item \emph{сетевой (network)}: \emph{IP}, \emph{ICMP}, \emph{IGMP} и т. д.;
  \item \emph{канальный (data link)}: \emph{Ethernet}, \emph{Token Ring} и т. д.
\end{itemize}

Как мы видели, в протоколах TCP и UDP для адресации используются IP-адрес и номер порта. Соответственно, в протоколе IP используетя для только IP-адрес. В протоколе канального уровня Ethernet используется MAC-адрес.

Размер IPv4-адреса — 32 бита. Адреса принято записывать в десятичной нотации, например, 17.52.86.120. Все IP-адреса подразделены на пять классов:
\begin{itemize}
  \item \emph{A}. Начальные биты адреса: $0$. Размер маски сети: $8$.
  \item \emph{B}. Начальные биты адреса: $10$. Размер маски сети: $16$.
  \item \emph{C}. Начальные биты адреса: $110$. Размер маски сети: $24$.
  \item \emph{D}. Начальные биты адреса: $1110$. Размер маски сети: не определено.
  \item \emph{E}. Начальные биты адреса: $1111$. Размер маски сети: не определено.
\end{itemize}
Адреса класса \emph{D} используются для группового вещания, а класс \emph{E} зарезервирован для будущих расширений. Остальные классы предназначены для адресации конкретных сетей и узлов.

Первая часть любого адреса представляет собой идентификатор сети, вторая — идентификатор узла внутри этой сети. Так в адресе 192.168.1.23 класса \emph{C} идентификатором сети является 192.168.1 (первые 24 бита), а идентификатором узла в данной сети — 23.

Для сетей \emph{A-C} определены некоторые специальные адреса, перечисленные в таблице:\
\begin{figure}[h!]
  \centering
  \begin{tabular}{c|c|c|c|p{5cm}}
    \toprule
    \multicolumn{2}{c|}{IP-адрес} & \multicolumn{2}{|c|}{Может быть} & \multicolumn{1}{|c}{\multirow{2}{*}{Описание}} \\
    ID сети & ID узла & отпр.? & получ.? & \\
    \midrule
    0     & 0      & да  & нет & этот узел в данной сети \\
    \midrule
    0     & hostid & да  & нет & указанный узел в данной сети \\
    \midrule
    127   & любой  & да  & да  & loopback интерфейс \\
    \midrule
    -1    & -1     & нет & да  & ограниченное широковещание (без форвардинга) \\
    \midrule
    netid & -1     & нет & да  & широковещание в сети netid \\
    \bottomrule
  \end{tabular}
\end{figure}

Адрес узла из одних единиц — это широковещательный адрес. IP-дейтаграммы, посланные по этому адресу, доставляются всем узлам сети. Адрес 0 означает «этот узел». Например, в сети 192.168.1.0/24 адрес 192.168.1.255 — широковещательный на сеть, а 0.0.0.0 — «этот узел». Адрес сети 0 означает «эта сеть». Адрес сети 127 — это адрес «собственной» сети узла. Дейтаграммы, адресованные сети 127, не должны покидать узел-отправитель.

\subsection{Маршрутизация}

Если узлу H1 нужно обратиться к узлу H2, то он получает адрес, соответсвующий IP-адресу H2, и помещает дейтаграмму «на провод».

Если узлу H1 нужно обратиться к узлу H3, то H1 должен отправить дейтаграмму через маршрутизатор R1. Если у двух сегментов разные идентификаторы сетей, то H1 по своей маршрутной таблице определяет, что пакеты, адресованные сенменту 2, обрабатываются маршрутизатором R1, и отправляет ему дейтаграмму в предположении, что тот переправит ее узлу H3.

\noindent
\begin{figure}[h!]
  \centering
  \begin{tikzpicture}
    \tikzstyle{host} = [draw, thick, fill=white, rectangle, minimum height=2.5em, minimum width=4em, node distance=3em, font={\bfseries}]
    \tikzstyle{router} = [host, rounded corners]
    \tikzstyle{hostConnect} = [draw, |-, very thick]

    \draw [very thick] (0,-1) -- node [right=5.1cm] {Сегмент 1} +(10,0);

    \node [host, name=H1] at (1,0) {H1};
    \node [host, name=H2, right=of H1] {H2};
    \node [router, name=R2, right=of H2] {R2};
    \draw [very thick,|->] (R2.north) -- node [above=0.5em] {Интернет} +(0,0.5);

    \draw [hostConnect] let \p1=(H1.south) in
      (H1.south) -- (\x1, -1);
    \draw [hostConnect] let \p1=(H2.south) in
      (H2.south) -- (\x1, -1);
    \draw [hostConnect] let \p1=(R2.south) in
      (R2.south) -- (\x1, -1);

    \draw [very thick] (0,-3) -- node [right=5.1cm] {Сегмент 2} +(10,0);

    \node [host, name=H3] at (1,-2) {H3};
    \node [host, name=H4, right=of H3] {H4};
    \node [host, name=H5, right=of H4] {H5};
    \node [router, name=R1, right=of H5] {R1};

    \draw [hostConnect] let \p1=(H3.south) in
      (H3.south) -- (\x1, -3);
    \draw [hostConnect] let \p1=(H4.south) in
      (H4.south) -- (\x1, -3);
    \draw [hostConnect] let \p1=(H5.south) in
      (H5.south) -- (\x1, -3);
    \draw [hostConnect] let \p1=(R1.south) in
      (R1.south) -- (\x1, -3);
    \draw [hostConnect] let \p1=(R1.north) in
      (R1.north) -- (\x1, -1);
  \end{tikzpicture}
  \caption{Сеть из двух сегментов}
\end{figure}

Из вышесказанного следует, что один из способов организовать сети с несколькими сегментами --- это назначить каждому сегменту свой идентификатор сети. Но у этого решения есть недостатки. Во-первых, при этом возможна потеря многих адресов в каждой сети. Во-вторых, маршрутная таблица любого узла, который направляет дейтаграммы напрямую в комбинированную сеть, должна содержать по одной записи для каждого сегмента.

Для примера рассмотрим узел со следующими интерфейсами и таблицей маршрутизации:
\begin{plainlst}{}{}
% netstat -i
Kernel Interface table
Iface   MTU ... Flg
eth1   1500 ... BMRU
lo    16436 ... LRU
ppp0   1400 ... MOPRU

% route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         0.0.0.0         0.0.0.0         U     0      0        0 ppp0
81.25.32.68     192.168.1.1     255.255.255.255 UGH   0      0        0 eth1
91.187.0.1      0.0.0.0         255.255.255.255 UH    0      0        0 ppp0
127.0.0.0       127.0.0.1       255.0.0.0       UG    0      0        0 lo
\end{plainlst}

Первая строка таблицы маршрутизации говорит о том, что если ни одно из других правил маршрутизации не подходит, следует использовать его, то есть в данном случае пересылать данные через интерфейс ppp0. Вторая строка говорит о том, что данные для узла 81.25.32.68 (флаг H) пересылаются через шлюз 192.168.1.1 (флаг G). Третья строка — данные для узла 91.187.0.1 (флаг H) пересылаются по стандартному маршруту, то есть через интерфейс ppp0. Четвёртая строка — данные в сеть 127 отправляются на узел 127.0.0.1.

\subsection{Подсети}
У механизма подсетей есть следующие достоинства:
\begin{itemize}
  \item Небольшие маршрутные таблицы и эффективное использование адресного пространства.
  \item Простая маршрутизация.
\end{itemize}

Так как внешние узлы, чтобы выбрать маршрут, используют только идентификатор сети, то можно распределять идентификаторы узлов по своему усмотрению. Разделение на подсети осуществляется по следующему принципу. Одна часть идентификатора узла служит для определения сегмента (то есть подсети), в состав которого входит узел, а другая --- для определения конкретного узла.

\noindent
\begin{figure}[h!]
  \centering
  \begin{tikzpicture}
    \tikzstyle{part} = [draw, thick, fill=white, rectangle, minimum height=2.5em, minimum width=6em, node distance=0]
    \tikzstyle{number} = [node distance=0]

    \node[part,name=net,minimum width=12em] {Идентификатор сети};
    \node[part,right=of net,xshift=-1,name=subnet] {Подсеть};
    \node[part,right=of subnet,xshift=-1,name=host] {Номер хоста};

    \node[number,above=of net,xshift=-6em] {0};
    \node[number,above=of net,xshift=5.1em] {15};
    \node[number,above=of subnet,xshift=-2.3em] {16};
    \node[number,above=of subnet,xshift=2.1em] {23};
    \node[number,above=of host,xshift=-2.3em] {24};
    \node[number,above=of host,xshift=2.1em] {31};
  \end{tikzpicture}
  \caption{Возможная интерпретация адреса}
\end{figure}

На подсети можно разбивать, конечно, же и не по границе байта. С каждой подсетью ассоциируется \emph{маска подсети}, которой определяется, какая часть адреса отведена под идентификаторы сети и подсети, а какая --- под номер узла.

\subsection{Вещание}
\begin{itemize}
  \item \emph{Ограниченное вещание}. Адрес для ограниченного вещания --- 255.255.255.255. Вещание называется ограниченным, так как дейтаграммы, посланные на этот адрес, не уходят дальше маршрутизатора.
  \item \emph{Вещание на сеть}. В адресе для вещания на сеть идентификатор сети определяет адрес этой сети, а идентификатор узла состоит из одних единиц.
  \item \emph{Вещание на подсеть}. В адресе для вещания на подсеть идентификаторы сети и подсети определяют соответствующие адреса, а идентификатор узла состоит из одних единиц. Необходимо знать маску подсети, чтобы опознать вещание на подсеть.
  \item \emph{Вещание на все подсети}. В адресе для вещания на все подсети задан идентификатор сети, а адреса подсети и узла состоят из одних единиц. Как и при вещании на подсеть, для опознания того адреса надо знать маску подсети.
\end{itemize}

\subsection{Бесклассовая междоменная маршрутизация}
Она же \emph{Classless Inter-Domain Routing} (\emph{CIDR}). CIDR --- это механизм подсетей ``наизнанку''. Вместо увеличения CIDR уменьшает длину идентификатора сети в IP-адресе.

Пусть некоторой организации нужно 1000 IP-адресов. Ей выделяют четыре соседних идентификатора сетей класса C с общим префиксом от 200.10.4.0 до 200.10.7.0. Первые 22 бита этих идентификаторов одинаковы и представляют номер агрегированной сети, в данном случае 200.10.4.0. Как и для подсетей, для идентификации сетевой части IP-адреса используется маска сети. В данном случае она равна 255.255.252.0.

\subsection{Частные сети и NAT}
В настоящее время для частных сетей не выбирается произвольный блок IP-адресов. В RFC 1918 определены три блока адресов, которые не будут выделяться:
\begin{itemize}
  \item 10.0.0.0--10.255.255.255 (префикс 10/8);
  \item 172.16.0.0--172.31.255.255 (префикс 172.16/12);
  \item 192.168.0.0--192.168.255.255 (префикс 192.168/16).
\end{itemize}

Если использовать для своей сети один из этих блоков, то любой узел сможет обратиться к другому узлу в этой же сети, не опасаясь кофликта с глобально выделенным IP-адресом. Если нужен выход во внешний мир, то следует использовать \emph{преобразование сетевых адресов} (\emph{NAT}, \emph{Network Address Translation}). Принцип работы заключается в преобразовании между частными сетевыми адресами и одним или несколькими гобально выделенными IP-адресами. Большинство устройств с поддержкой NAT можно сконфигурировать в трех режимах:
\begin{itemize}
  \item \emph{Статический}. Адреса всех или некоторых узлов в частной сети отображаются на один и тот же фиксированный, глобально выделенный адрес.
  \item \emph{Выбор из пула}. Устройство с поддержкой NAT имеет пул глобально выделенных IP-адресов и динамически назначает один из них узлу, которому нужно связаться с узлом во внешней сети.
  \item \emph{PAT (Port Address Translation, преобразование адресов портов)}. Этот метод применяется, когда есть единственный глобально выделенный адрес. При этом каждый частный адрес отображается на один и тот же внешний адрес, но номер порта исходящего пакета заменяется уникальными значением, которое в дальнейшем используется для направления входящих пакетов на частный сетевой адрес.
\end{itemize}

\subsection{ARP}
Протокол \emph{ARP (Address Resolution Protocol)} служит для преобразования IP-адреса в соответствующий ему MAC-адрес в случае использования Ethernet. Делает он это динамически и при нормальной работе без вмешательства пользователя сети.

Как пример рассмотрим следующую ситуацию:
\begin{enumerate}
  \item Приложению необходимо послать данные по TCP узлу \lstinline{gateway}.
  \item В файле \lstinline{/etc/hosts/} имеется запись \lstinline{192.168.1.1 gateway}.
  \item Приложение вызывает функцию \lstinline{gethostbyname("gateway")}. Функция, соответственно, возвращает 32-битный IP-адрес.
  \item Приложение пытается установить TCP-соединение с указанным IP-адресом. Для этого оно формирует пакет-запрос на соединение к удалённому узлу, используя для этого IP-пакет.
  \item Если удалённый узел находится в той же сети, что и узел-отправитель, то необходимо выяснить MAC-адрес удалённого узла. Если же он находится в другой сети, то необходимо послать IP-пакет на шлюз в согласии с правилами маршрутизации на узле отправителе. Соответственно, в этом случае надо узнать MAC-адрес шлюза.
  \item ARP узла-отправителя делает широковещательный запрос, в котором указывается IP-адрес удалённого узла или шлюза. Удалённый узел или шлюз отвечает пакетом, в котором содержится его MAC-адрес.
  \item Получив физический адрес удалённого узла или шлюза, остальное — дело техники.
\end{enumerate}

Обмен подобным ARP-запросами и ответами можно просмотреть утилитой \lstinline{tcpdump}:
\begin{plainlst}{}{}
% tcpdump -enqti eth1 arp
listening on eth1, link-type EN10MB (Ethernet), capture size 65535 bytes
00:25:22:b2:46:86 > ff:ff:ff:ff:ff:ff, ARP, length 42: Request who-has 192.168.1.1 tell 192.168.1.234, length 28
00:26:5a:e0:17:d9 > 00:25:22:b2:46:86, ARP, length 60: Reply 192.168.1.1 is-at 00:26:5a:e0:17:d9, length 46
00:26:5a:e0:17:d9 > 00:25:22:b2:46:86, ARP, length 60: Request who-has 192.168.1.234 tell 192.168.1.1, length 46
00:25:22:b2:46:86 > 00:26:5a:e0:17:d9, ARP, length 42: Reply 192.168.1.234 is-at 00:25:22:b2:46:86, length 28
\end{plainlst}

\subsubsection{Кэш ARP}
Для высокой производительности \emph{ARP} в реализациях этого протокола поддерживается кеш соответствий логических адресов физическим. Так после продемонстрированного обмена пакетами кеш будет содержать всего лишь одну запись:
\begin{plainlst}{}{}
% arp -a
? (192.168.1.1) at 00:26:5a:e0:17:d9 [ether] on eth1
\end{plainlst}

\subsection{ICMP}
\emph{ICMP (Internet Control Message Protocol)} — сетевой протокол, среди назначений которого, например, передача сообщений об ошибках при передаче данных, о недоступности узла, порта, маршрутизатора, передача эхо-запросов и эхо-ответов, запрос и ответ сетевых масок удалённого узла и т. д. Очевидно, одни сообщения являются причиной возрата ошибки пользовательскому процессу, другие же нет.

Формально \emph{ICMP} принадлежит сетевому уровню в стеке \emph{TCP/IP}, однако все сообщения этого протокола инкапсулируются в IP-пакеты. \emph{ICMP} является неотъемлемой частью стека \emph{TCP/IP}.

\emph{ICMP}-сообщения об ошибке никогда не порождаются в ответ на:
\begin{itemize}
  \item потерю \emph{ICMP}-пакета;
  \item \emph{IP}-пакеты с широковещательным или групповым адресом, чтобы не вызывать перегрузку в сети (так называемый «широковещательный шторм»);
  \item фрагменты повреждённого пакета, кроме первого фрагмента;
  \item \emph{ICMP}-сообщение об ошибке;
  \item широковещательную дейтаграмму канального уровня;
  \item \emph{IP}-пакет, в котором в качестве отправителя указан не узел, а, например, сеть или loopback-интерфейс.
\end{itemize}

С использованием \emph{ICMP} реализуются такие утилиты, как \lstinline{ping} и \lstinline{traceroute}.

\subsection{DHCP}
Он же \emph{Dynamic Host Configuration Protocol} (\emph{протокол динамической настройки узла}). Сетевой протокол, позволяющий компьютерам автоматически получать IP-адрес. Помимо адреса, DHCP также может сообщить клиенту дополнительные параметры, необходимые для работы в сети. Вот некоторые из часто используемых опций:
\begin{itemize}
  \item IP-адрес сетевого шлюза по умолчанию;
  \item маска подсети;
  \item адреса серверов DNS;
  \item доменное имя.
\end{itemize}

Протокол DHCP является клиент-серверным, использует протокол UDP. При этом сервер принимает сообщения на порту 67 и отправляет сообщения клиентам на порт 68.

Изначально клиент выполняет широковещательный запрос по всей сети с целью обнаружить доступные DHCP-серверы, при этом в качестве адреса источника указывается 0.0.0.0, а в качестве адреса назначения --- широковещательный адрес 255.255.255.255.

\subsection{DNS}
Она же \emph{Domain Name System} (\emph{система доменных имён}). Компьютерная распределенная система для получения информации о доменных именах. Чаще всего используется для получения IP-адреса по имени узла. Но также может и использоваться и для получения имени по адресу.

DNS — иерархична. Часть реального дерева доменов:
\begin{center}
  \begin{tikzpicture}[level/.style={sibling distance=60mm/#1,level distance=0.8cm}]
    \node [circle,draw] {}
    child { node {arpa}
      child { node {in-addr}
        child { node {81}
          child { node {25}
            child { node {32}
              child { node {34} }}}}}}
    child { node {org}
      child { node {wikipedia}
        child { node {en} }
        child { node {www} }}
      child { node {example}
        child { node {www} }}};
  \end{tikzpicture}
\end{center}

В данном дереве каждое ребро соответствует точке в записи домена строкой. Корневым доменом является безымянный домен. Домены бывают простыми и полностью определёнными, \emph{FQDN (Fully Qualified Domain Name)}. Полностью определённое имя должно содержать точку в конце своего строкового представления. Так, \emph{www.example.com} — простой домен (относительный), а \emph{www.example.com.} — полностью определённый (абсолютный).

Корневой домен является безымянным. Его непосредственные потомки называются доменами первого (верхнего) уровня; в свою очередь, непосредственные потомки доменов первого уровня являются доменами второго уровня и т. д. Подавляющее большинство доменов верхнего уровня попадает в одну из следующих категорий:
\begin{itemize}
  \item Общие домены верхнего уровня. Например: \emph{.com, .org, .net, .biz}.
  \item Национальные домены верхнего уровня. Представляют собой двухбуквенный код страны, за которой он закреплён.
  \item \emph{.arpa}. Особый домен, используемый для отображения адресов в имена.
\end{itemize}

Основой DNS является представление об иерархической структуре доменного имени и \emph{зонах}. \emph{Зона} — это поддерево доменов. Очевидно, что нет единственного сервера или кластера серверов, который обслуживает абсолютно все доменные имена. Есть сервера, который обслуживают корневой домен, а обслуживание дочерних доменов делегируется каким-либо другим организациям. Каждый сервер, отвечающий за имя, может переложить ответственность за дальнейшую часть домена другому серверу.

Соответственно, нет такого сервера DNS, который владеет информацией обо всех доменах. Поэтому возникает ситуация, в которой опрашиваемый DNS-сервер не обладает необходимой информацией, поэтому следует обращаться к одному из других серверов. То есть опрашиваемый DNS-сервер возвращает либо ответ, либо список серверов, которые обладают более полной информацией о домене. Именно к этим серверам и следует обращаться далее. Такой запрос называется \emph{итеративным}, то есть клиент сам опрашивает сервера до тех пор, пока не получит необходимую информацию. Запрос может быть и \emph{рекурсивным}. В таком случае DNS-сервер сам опрашивает необходимые сервера для получения информации о домене. Стоит отметить, что DNS-сервер может отказатся выполнять рекурсивный запрос.

При выполнении рекурсивного запроса DNS-сервер может сохранить ответ других серверов в своём кэше, чтобы при последующих запросах не опрашивать другие сервера, а выдать ответ клиенту сразу же, взяв необходимые данные из кэша.

Ответы могут быть \emph{авторитетными} и \emph{неавторитетными}. Авторитетными ответы являются, когда сервер выдаёт информацию о домене в зоне, за которую он отвечает. Неавторитетными — все остальные ответы.

DNS-сервера, используемые по умолчанию, перечисляются в файле \lstinline{/etc/resolv.conf}. Пример такого файла:
\begin{plainlst}{}{}
nameserver 81.25.32.34
nameserver 81.25.32.9
\end{plainlst}

Имя и IP-адрес не соответствуют друг другу взаимооднозначно. Например, одному адресу может быть сопоставлено несколько имен, что позволяет организовывать виртуальный хостинг. И наоборот --- одному имени может быть сопоставлено множество адресов, что позволяет балансировать нагрузку.

\subsubsection{Записи DNS}
Единицы хранения и передачи информации в DNS. Каждая запись состоит из следующих полей:

\begin{center}
  \begin{tabular}{lp{9cm}}
    \toprule
    Имя поля & Объяснение \\
    \midrule
    NAME & доменное имя, к которому привязана данная запись \\
    TTL (Time To Live) & допустимое время хранения записи в неответственном DNS-сервере \\
    TYPE & формат и назначение записи \\
    CLASS & тип сети \\
    RDLEN & длина поля данных \\
    RDATA & поле данных, формат и содержание которого зависит от типа \\
    \bottomrule
  \end{tabular}
\end{center}

Некоторые типы записей:
\begin{itemize}
  \item \emph{A} (\emph{address record}). Запись адреса связывает имя узла с адресом IP.
  \item \emph{AAAA} (\emph{IPv6 address record}). Связывает имя узла с адресом IPv6.
  \item \emph{CNAME} (\emph{canonical name record}). Запись канонического имени. Используется для перенаправление на другое имя.
  \item \emph{MX} (\emph{mail exchange}). Указывает почтовые серверы для данного домена.
  \item \emph{NS} (\emph{name server}). DNS-сервер для данного домена.
  \item \emph{PTR} (\emph{pointer}). Связывает IP-адрес узла с его каноническим именем.
\end{itemize}

\subsubsection{Примеры запросов}

Запросы из командной строки к DNS-серверу можно делать при помощи утилит \lstinline{host} и \lstinline{nslookup}.
\begin{plainlst}{}{}
% host 81.25.32.34
34.32.25.81.in-addr.arpa domain name pointer ns1.infonet.by.
% host -t mx adsl.by
adsl.by mail is handled by 10 mail.adsl.by.
% nslookup -type=ptr 34.32.25.81.in-addr.arpa
Server:      81.25.32.34
Address:     81.25.32.34#53

34.32.25.81.in-addr.arpa         name = ns1.infonet.by
% nslookup -type=mx adsl.by
Server:      81.25.32.34
Address:     81.25.32.34#53

adsl.by mail exchanger = 10 mail.adsl.by
\end{plainlst}

\section{Дополнительные вопросы}
\label{sec:network-addition}

\subsection{Организация тайм-аута}
Существует три способа установки тайм-аута для операции ввода-вывода через сокета:
\begin{enumerate}
  \item Вызов функции \lstinline{alarm}, которая генерирует сингал \lstinline{SIGALRM}, когда истекает заданное время.
  \item Блокирование при ожидании ввода-вывода в функции \lstinline{select}, имеющей встроенное ограничение времени, вместо блокирования в вызове функций \lstinline{read} или \lstinline{write}.
  \item Использование параметров сокетов \lstinline{SO_RCVTIMEO} и \lstinline{SO_SNDTIMEO}.
\end{enumerate}

Все три варианта можно использовать с функциями ввода/вывода, но также нужно возможность работы с функцией \lstinline{connect}, поскольку процесс соединения TCP может занять длительное время (обычно 75 с).

\subsection{Алгоритм Нейгла}
\label{sec:nagle-algorithm}
Алгоритм был разработан для более эффективного использования сетевого канала. Так как минимальный размер сегмента TCP без данных равен 40 байт, то накладные расходы при посылке одного байта в сегменте составляет $4000\%$.

Соединение считается простаивающем, если в нем нет неподтвержденных данных. Новые данные от приложения не посылаются, пока соединение не перейдет в состояние простоя. RFC 1122 ослабляет это требование, разрешая посылать данные, если их хватает для заполнения целого сегмента. Условие Нейгла при этом выполняется: в соединении находится не более одного небольшого неподтвержденного сегмента.

Алгоритм Нейгла может плохо взаимодейстовать с другой возможностью TCP --- отложенным подтверждением. Когда прибывает сегмент от удаленного узла, TCP задерживает отправку ACK в предположении, что приложение скоро ответит на только что полученные данные. Поэтому ACK можно будет объединить с данными.

Если через $T_P$ обозначить время, необходимое серверу для обработки запроса и отправки ответа, но на каждую пару запрос/ответ уйдет $RTT + T_P$ мс. Если клиент посылает свой запрос в виде двух последовательных операций записи, то алгоритмы взаимодействуют так, что число сегментов, необходимых для получения ответа от сервера, равно четырем. Поэтому время, необходимое для получения логического ответа, может быть значительным.

\subsection{Номера портов}
IANA (Internet Assigned Numbers Authority --- агенство по выделению имен и уникальных параметров протоколов Интернета) ведет список назначенных номеров портов.
\begin{enumerate}
  \item \emph{Заранее известные порты}: от 0 до 1023. Эти номера управляются и присваиваются IANA.
  \item \emph{Зарегистрированные порты}: от 1024 до 49151. Они не управляются IANA, но IANA регистрирует и составляет списки использования этих портов.
  \item \emph{Динамические}, или \emph{частные} порты: от 49152 до 65535.
\end{enumerate}

\section{Приложения для отладки}
\subsubsection{ps}
Отображают информацию о выбранных активных процессах. Ниже перечислены некоторые ключи, представлющие особенный интерес по теме:
\begin{itemize}
  \item \textbf{wchan} --- имя функции ядра, в которой процесс блокирован. ``-'', если процесс выполняется. ``*'', если в процессе несколько потоков, а ps не выводит информацию о потоках.
\end{itemize}

\subsubsection{ping}
Утилита ping посылает ICMP пакеты ECHO\_REQUEST на указанный узел и использует полученные (или неполученные) в ответ ICMP пакеты ECHO\_RESPONSE для определения доступности этого узла и затраченного времени.
\begin{plainlst}{}{}
% ping -c 3 informatics.by
PING informatics.by (91.149.157.152) 56(84) bytes of data.
64 bytes from vh24.hoster.by (91.149.157.152): icmp_req=1 ttl=59 time=403 ms
64 bytes from vh24.hoster.by (91.149.157.152): icmp_req=2 ttl=59 time=399 ms
64 bytes from vh24.hoster.by (91.149.157.152): icmp_req=3 ttl=59 time=267 ms

--- informatics.by ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1999ms
rtt min/avg/max/mdev = 267.651/356.916/403.512/63.140 ms
\end{plainlst}

\subsubsection{traceroute}
Утилита traceroute позволяет выяснить маршрут следования пакетов к узлу назначения. Для этого она посылает серию UDP пакетов c TTL от 1 до 30 (эти параметры можно менять) и получает ответы от промежуточных маршрутизаторов об истечении TTL (ICMP TIME\_EXCEEDED).
\begin{plainlst}{}{}
% traceroute informatics.by
traceroute to informatics.by (91.149.157.152), 30 hops max, 60 byte packets
 1  10.10.224.1 (10.10.224.1)  459.626 ms  679.630 ms  683.505 ms
 2  * * *
 3  77.74.33.114 (77.74.33.114)  687.141 ms  1246.943 ms  1250.856 ms
 4  as6697-2.by-ix.net (195.137.180.253)  1254.780 ms  1282.746 ms  1287.441 ms
 5  gi15-0-0.ne1-1-2.net.belpak.by (93.84.125.9)  1287.400 ms  1290.625 ms  1294.567 ms
 6  gw2.datacenter.beltelecom.by (93.84.125.165)  1294.530 ms  255.403 ms  327.064 ms
 7  vh24.hoster.by (91.149.157.152)  334.976 ms  386.862 ms  762.791 ms
\end{plainlst}

\subsubsection{route}
Выводит или изменяет таблицу маршрутизации IP-пакетов.
\begin{plainlst}{}{}
% route add -net 192.56.76.0 netmask 255.255.255.0 dev eth0
\end{plainlst}

\subsubsection{netstat}
Может напечатать список откртых сокетов, таблицу маршрутизации, таблицу сетевых интерфейсов, статистику по каждому протоколу и т.д.
\begin{plainlst}{}{}
% netstat -nr
Kernel IP routing table
Destination   Gateway    Genmask         Flags   MSS Window  irtt Iface
10.6.6.6      0.0.0.0    255.255.255.255 UH        0 0          0 ppp0
169.254.0.0   0.0.0.0    255.255.0.0     U         0 0          0 ppp0
0.0.0.0       10.6.6.6   0.0.0.0         UG        0 0          0 ppp0
\end{plainlst}

\subsubsection{ifconfig}
Команда ifconfig используется для конфигурирования сетевых интерфейсов ядра.

Если аргументы не переданы, ifconfig выдает информацию о состоянии активных интерфейсов. Если указан один аргумент интерфейс, выдается информация только о состоянии этого интерфейса; если указан один аргумент -a, выдается информация о состоянии всех интерфейсов, даже отключенных. Иначе команда конфигурирует указанный интерфейс.

\subsubsection{netcat}
Позволяет устанавливать соединения TCP и UDP, принимать данные и передавать их, сканировать порты. Аналог широкоизвестной утилиты cat для сетевого вводы/вывода.

\subsubsection{tcpdump}
Позволяет перехватывать и анализировать сетевой трафик. Для выполнения требует прав суперпользователя и прямой доступ к устройству.

\begin{plainlst}{Типичный вывод tcpdump}{}
% tcpdump -i lo
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on lo, link-type EN10MB (Ethernet), capture size 65535 bytes
22:02:04.021905 IP localhost.localdomain.43849 > localhost.localdomain.6600: Flags [P.], seq 2463307991:2463307998, ack 2463842528, win 770, options [nop,nop,TS val 12929880 ecr 12929629], length 7
22:02:04.022845 IP localhost.localdomain.6600 > localhost.localdomain.43849: Flags [P.], seq 1:156, ack 7, win 512, options [nop,nop,TS val 12929880 ecr 12929880], length 155
22:02:04.022878 IP localhost.localdomain.43849 > localhost.localdomain.6600: Flags [.], ack 156, win 770, options [nop,nop,TS val 12929880 ecr 12929880], length 0
^C
3 packets captured
6 packets received by filter
0 packets dropped by kernel
\end{plainlst}

\subsubsection{tcpreplay}
Позволяет перепосылает все пакеты из файла, полученного утилитой tcpdump. Скорость можно устанавливать.

\subsubsection{iperf}
Генератор TCP и UDP трафика для тестирования пропускной способности сети. Работает как по TCP, так и по UDP. Для работы должен быть запущен сервер на одном узле, и клиент на другом.

\subsubsection{sysctl}
Предназначена для управления отдельными параметрами ядра, безопасности, сетевой подсистемы. Позволяет определять и задавать такие параметры как размер сегмента разделяемой памяти, ограничение на число запущенных процессов.

Имеет конфигурационный файл \texttt{/etc/sysctl.conf}, в котором переопределяются необходимые параметры.

\begin{thebibliography}{9}

\bibitem{network:snader01}
  Й. Снейдер,
  \emph{Эффективное программирование TCP/IP}.
  Питер,
  2001.

\bibitem{network:stivens07}
  У. Р. Стивенс, Б. Феннер, Э. М. Рудофф,
  \emph{UNIX. Разработка сетевых приложений}.
  Питер,
  3-е изд.,
  2007.

\bibitem{network:camer02}
  Д. Э. Камер, Д. Л. Стивенс,
  \emph{Сети TCP/IP, том 3. Разработка приложений типа клиент/сервер для Linux/POSIX}.
  Вильямс,
  2002.

\end{thebibliography}
