\chapter{Сетевое программирование}
\label{ch:network}

\section{Протокол TCP}
\label{sec:tcp}
Он же \emph{протокол управления передачей}; он же \emph{Transmission Control Protocol}. Является протоколом, ориентированным на установление соединения и предоставляющим надежный двусторонний байтовый поток использующим его приложениям. TCP обеспечивает отправку и прием подтверждений, обработку тайм-оутов, повторную передачу и т.п.

Прежде всего, TCP обеспечивает установление соединений. Клиент TCP устанавливает соединение с выбранным сервером, обменивается с ним данными по этому соединению и затем разрывает его.

TCP надежен, но не магичен. Все отправленные данные должны быть подтверждены. Если этого нет, то данные автоматически пересылаются. Время ожидания подтверждения при этом увеличивается.

TCP может оценивать \emph{время обращения} (\emph{round-trip-time}, \emph{RTT}) между двумя узлами и таким образом определять необходимое время для получения подтверждения. TCP постоянно обновляет RTT.

TCP упорядочивает данные, связывая некоторый порядковый номер с каждым отправляемым им байтом. Пусть приложение записывает 2048 байт в сокет TCP, что приводит к отправке двух сегментов TCP. Первый из них содержит данные с порядковыми номерами 1--1024, второй --- с номерами 1025--2048. Если какой-либо сегмент приходит вне очереди, принимающий TCP заново упорядочит сегменты, основываясь на их порядковых номерах, перед тем как отправить данные принимающему приложению. Если TCP получает дублированные данные, он может определить, что они были дублированы, и они будут проигнорированы.

TCP обеспечивает \emph{управление потоком} (\emph{flow control}). TCP сообщает своему собеседнику, сколько именно байтов он хочет получить от него. Это называется объявлением \emph{окна} (\emph{window}).

\subsection{Трехэтапное рукопожатие}
\begin{enumerate}
  \item Сервер должен быть подготовлен для принятия входящего соединения. Это называется \emph{пассивным открытием} (\emph{passive open}).
  \item Клиент выполняет \emph{активное открытие} (\emph{active open}), то есть посылает сегмент SYN, чтобы сообщить серверу начальный порядковый номер данных. Этот сегмент содержит заголовок IP, заголовок TCP и параметры TCP.
  \item Сервер подтверждает получение клиентского сегмента SYN и вслед посылает свой собственный сегмент SYN, содержащий порядковый номер своих данных. SYN и ACK отсылаются в одном сегменте.
  \item Клиент подтверждает получение SYN сервера.
\end{enumerate}

\noindent
\begin{figure}[h!]
  \centering
  \begin{tikzpicture}
    \tikzstyle{tcpStep} = [];
    \node at (0,0) (client) {Клиент};
    \node at (4,0) (server) {Сервер};

    \draw[thick,->,-stealth] (client.south)  -- +(0,-4)
      node (client socket) [tcpStep,left,pos=.1] {\lstinline{socket}}
      node (connect) [tcpStep,left,pos=.35,text width=3.3cm, text justified] {\lstinline{connect}, блокировка, активное открытие}
      node (close connect) [tcpStep,left,pos=.75] {Завершение \lstinline{connect}};
    \draw[thick,->,-stealth] (server.south)  -- +(0,-4)
      node (server socket) [tcpStep,right,pos=.2] {\lstinline{socket, bind, listen}}
      node (accept) [tcpStep,,right,pos=.5] {\lstinline{accept}, блокировка}
      node (close accept) [tcpStep,right,pos=.85] {Завершение \lstinline{accept}};

    \draw[thick,->,-stealth] (connect) edge node [above,sloped] {SYN J} (accept);
    \draw[thick,->,-stealth] (accept) edge node [above,sloped] {SYN K, ACK J+1} (close connect);
    \draw[thick,->,-stealth] (close connect) edge node [above,sloped] {ACK K+1} (close accept);
  \end{tikzpicture}
  \caption{Трехэтапное рукопожатие TCP}
  \label{fig:tcp-handshake}
\end{figure}

Для подобного обмена нужно как минимум три пакета (cм. рис. \vref{fig:tcp-handshake}), поэтому он называется \emph{трехэтапным рукопожатием TCP} (\emph{TCP three-way handshake}).

\subsection{Параметры TCP}
Каждый сегмент SYN может содержать параметры TCP. Следом наиболее общеупотребительные:
\begin{itemize}
  \item \emph{Параметр MSS}. Позволяет объявить свой максимальный размер сегмента (maximum segment size, MSS) --- максимальное количество данных, которое он будет принимать в каждом сегмента TCP на этом соединении.
  \item \emph{Параметр масштабирования окна (Window scale option)}. Максимальный размер окна, который может быть установлен в заголовке TCP, равен $65535$, поскольку соответствующее поле занимает 16 бит. Но высокоскоростные соединения или линии с большой задержкой требуют большего размера окна для получения максимально возможной пропускной способности. Этот параметр определяет, что объявленная в заголовке TCP величина окна должна быть отмасштабирована --- сдвинута влево на 0--14 разрядов, предоставляя максимально возможное окно размером почти гигабайт ($65535 \times 2^{14}$).
  \item \emph{Временная метка (Timestamp option)}. Этот параметр необходим для высокоскоростных соединений, чтобы предотвратить возможное повреждение данных, вызванное приходом устаревших, задержавшихся и дублированных сегментов.
\end{itemize}

\subsection{Завершение соединения TCP}
Для завершения соединения требуется четыре сегмента.

\begin{enumerate}
  \item Один из сетевых узлов выполняет \emph{активное закрытие} (\emph{active close}). TCP этого узла отправляет сегмент FIN.
  \item Другой узел, получающий сегмент FIN, выполняет \emph{пассивное закрытие} (\emph{passive close}). Полученный сегмент FIN подтверждается TCP. Получение сегмента FIN передается приложению как признак конца файла.
  \item Через некоторое время после того, как приложение получило признак конца файла, оно закрывает свой сокет. TCP отправляет сегмент FIN первому узлу.
  \item Первый узел подтверждает получение сегмента FIN.
\end{enumerate}

Иногда первый FIN отправляется в сегменте вместе с данными. Также сегменты, отправляемые на шагах 2 и 3, могут быть объединены. Возможно, что между шагами 2 и 3 какие-то данные будут переданы от узла, выполняющего пассивное закрытие, к узлу, выполняющему активное закрытие. Это состояние называется \emph{частичным закрытием} (\emph{half-close}).

\subsection{Диаграмма состояний TCP}
Смотрите рис.~\ref{fig:tcp-states} на стр.~\pageref{fig:tcp-states}.
% взята с http://www.texample.net/tikz/examples/tcp-state-machine/
\noindent
\begin{figure}[t!]
  \centering
  \begin{tikzpicture}[>=latex]
    %
    % Styles for states, and state edges
    %
    \tikzstyle{state} = [draw, very thick, fill=white, rectangle, minimum height=3em, minimum width=6em, node distance=6.5em, font={\sffamily\bfseries\footnotesize}]
    \tikzstyle{stateEdgePortion} = [black,thick];
    \tikzstyle{stateEdge} = [stateEdgePortion,->];
    \tikzstyle{edgeLabel} = [pos=0.5, text centered, font={\sffamily\small}];

    %
    % Position States
    %
    \node[state, name=closedStart] {CLOSED};
    \node[state, name=listen, below of=closedStart] {LISTEN};
    \node[state, name=synSent, below of=listen, right of=listen, xshift=7em] {SYN\_SENT};
    \node[state, name=synRcvd, below of=listen, left of=listen, xshift=-7em] {SYN\_RCVD};
    \node[state, name=established, below of=listen, node distance=14em] {ESTABLISHED};
    \node[state, name=finWait1, below of=established, left of=established, node distance=6em, xshift=-7.5em] {FIN\_WAIT\_1};
    \node[state, name=finWait2, below of=finWait1] {FIN\_WAIT\_2};
    \node[state, name=closeWait, below of=established, right of=established, node distance=6em, xshift=6.5em] {CLOSE\_WAIT};
    \node[state, name=closing, below of=established, node distance=14em] {CLOSING};
    \node[state, name=lastAck, below of=closeWait] {LAST\_ACK};
    \node[state, name=timeWait, below of=closing] {TIME\_WAIT};

    %
    % Connect States via edges
    %
    \draw ($(closedStart.south) + (-.5em,0)$)
        edge[stateEdge] node[edgeLabel, xshift=-3em]{\emph{Passive open}}
        ($(listen.north) + (-.5em,0)$);
    \draw ($(listen.north) + (.5em,0)$)
        edge[stateEdge] node[edgeLabel, xshift=2em]{\emph{Close}}
        ($(closedStart.south) + (.5em,0)$);

    \draw ($(listen.south) + (-1em,0)$)
        edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-2em, yshift=1em]{SYN/SYN + ACK}
        ($(synRcvd.east) + (0,1em)$);
    \draw ($(listen.south) + (1em,0)$)
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=1em, yshift=1em]{\emph{Send}/SYN}
        ($(synSent.west) + (0,1em)$);

    \draw ($(synRcvd.north) + (.5em,0)$)
        edge[stateEdge, bend left=45] node[edgeLabel,xshift=-4em]{\emph{Timeout}/RST}
        ($(closedStart.west) + (0,-.5em)$);

    \draw ($(synSent.north) + (-.5em,0)$)
        edge[stateEdge, bend right=45] node[edgeLabel,xshift=-1em, yshift=-1em]{\emph{Close}}
        ($(closedStart.east) + (0,-.5em)$);
    \draw ($(closedStart.east) + (0,.5em)$)
        edge[stateEdge, bend left=45] node[edgeLabel,xshift=4em,sloped,above]{\emph{Active open}/SYN}
        ($(synSent.north) + (.5em,0)$);

    \draw (synSent.west)
        edge[stateEdge] node[edgeLabel, yshift=1em]{SYN/SYN + ACK}
        (synRcvd.east);
    \draw (synRcvd)
        edge[stateEdge] node[edgeLabel, xshift=-2.5em]{\emph{Close}/FIN}
        (finWait1);

    \draw ($(synRcvd.east) + (0,-1em)$)
        edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-1em, yshift=-1em]{ACK}
        ($(established.north) + (-1em,0)$);
    \draw ($(synSent.west) + (0,-1em)$)
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=3em, yshift=-1em]{SYN + ACK/ACK}
        ($(established.north) + (1em,0)$);

    \draw ($(established.south) + (-1em,0)$)
        edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-1em, yshift=1em]{\emph{Close}/FIN}
        ($(finWait1.east) + (0,.5em)$);
    \draw ($(established.south) + (1em,0)$)
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=1em, yshift=1em]{FIN/ACK}
        ($(closeWait.west) + (0,1em)$);

    \draw (finWait1.south)
        edge[stateEdge] node[edgeLabel, xshift=-2em]{ACK}
        (finWait2.north);
    \draw ($(finWait1.east) + (0,-.5em)$)
        edge[stateEdge, bend left=22.5] node[edgeLabel, yshift=1em]{ACK}
        (closing.north);
    \draw (finWait1.south east)
        edge[stateEdge] node[edgeLabel, xshift=1em, yshift=2em, text width=3em]{FIN + ACK/ACK}
        (timeWait.north west);

    \draw (finWait2.south)
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=-2em, yshift=-1em]{FIN/ACK}
        (timeWait.west);

    \draw (closing)
        edge[stateEdge] node[edgeLabel, xshift=-2em]{ACK}
        (timeWait);

    \draw (closeWait)
        edge[stateEdge] node[edgeLabel,xshift=2.5em]{\emph{Close}/FIN}
        (lastAck);

    %
    % Connect lastAck to closed is slightly more complicated
    % no direct line-of-sight, so we need to take the scenic route
    %
    \coordinate (lastAck2ClosedA) at ($(lastAck.east) + (2em,0)$);
    \coordinate (lastAck2ClosedB) at ($(closedStart.north -| lastAck.east) + (2em,1em)$);
    \coordinate (lastAck2ClosedC) at ($(closedStart.north) + (0.5em,1em)$);
    \draw (lastAck.east) edge[stateEdgePortion] (lastAck2ClosedA);
    \draw (lastAck2ClosedA) edge[stateEdgePortion] node[edgeLabel,xshift=-1.5em, yshift=-4em]{ACK} (lastAck2ClosedB);
    \draw (lastAck2ClosedB) edge[stateEdgePortion] (lastAck2ClosedC);
    \draw (lastAck2ClosedC) edge[stateEdge] ($(closedStart.north) + (0.5em,0)$);

    %
    % likewise for timeWait to closed
    %
    \coordinate (timeWait2ClosedA) at ($(timeWait.south) + (0,-1em)$);
    \coordinate (timeWait2ClosedB) at ($(timeWait.south -| finWait2.west) + (-2em,-1em)$);
    \coordinate (timeWait2ClosedC) at ($(closedStart.north -| finWait2.west) + (-2em,1em)$);
    \coordinate (timeWait2ClosedD) at ($(closedStart.north) + (-0.5em,1em)$);
    \draw (timeWait.south) edge[stateEdgePortion] (timeWait2ClosedA);
    \draw (timeWait2ClosedA) edge[stateEdgePortion] (timeWait2ClosedB);
    \draw (timeWait2ClosedB) edge[stateEdgePortion] (timeWait2ClosedC);
    \draw (timeWait2ClosedC) edge[stateEdgePortion]
      node[edgeLabel, text width=12.25em, yshift=1.5em]{\emph{Timeout after two maximum segment lifetimes (2*MSL)}}
        (timeWait2ClosedD);
    \draw (timeWait2ClosedD) edge[stateEdge] ($(closedStart.north) + (-0.5em,0)$);

    % draw dotted lines around passive and active closes
    \begin{pgfonlayer}{background}
      \draw [join=round,black,dotted] ($(closeWait.north west) + (-1em, -1em)$) rectangle ($(lastAck.south east) + (1em, 1em)$);
      \draw [join=round,black,dotted] ($(finWait1.north west) + (-1em, -1em)$) rectangle ($(timeWait.south east) + (1em, 1em)$);
    \end{pgfonlayer}
  \end{tikzpicture}
  \caption{Диаграмма состояний TCP}
  \label{fig:tcp-states}
\end{figure}

\subsection{Состояние TIME\_WAIT}
Оно же --- время ожидания. Узел, выполняющий активное закрытие, проходит это состояние. Его продолжительность равно двум \emph{MSL} (\emph{maximum segment lifetime --- максимальное время жизни сегмента}). MSL --- это максимальное время, в течение которого дейтаграмма IP может оставаться в сети. Каждая дейтаграмма содержит 8-разрядное поле \emph{предельного количества прыжков} (\emph{hop limit}), максимальное значение которого равно 255. Считается, что пакет с максимальным значением этого пределеа не может существовать в сети более MSL секунд.

Причины существования состояния TIME\_WAIT:
\begin{itemize}
  \item необходимо обеспечить надежность разрыва двустороннего соединения TCP;
  \item необходимо подождать, когда истечет время жизни в сети старых дублированных сегментов.
\end{itemize}

Предположим, что последний сегмент ACK потерян. Сервер еще раз отправит свой последний сегмент FIN, поэтому клиент должен сохранять информацию о своем состоянии, что отправить завершающее подтверждение ACK повторно. Если бы клиент не сохранял информацию о состоянии, он ответил бы серверу сегментом RST, что сервер интерпретировал бы как ошибку.

Предположим, что только что завершилось соединение между двумя узлами, и через некоторое время снова создается соединение с теми же оконечными точками. TCP должен предотвратить появление старых дубликатов в новом соединении. Чтобы гарантировать это, TCP запрещает установление нового соединения, если старое соединение находится в состоянии TIME\_WAIT.

\section{Протокол UDP}
\label{sec:udp}
Он же \emph{протокол пользовательских дейтаграмм}; он же \emph{User Datagram Protocol}. Является протоколом, не ориентированным на установление соединения. Не гарантирует доставку дейтаграмм.

Приложение записывает в сокет UDP дейтаграмму, которая упаковывается в дейтаграмму IP и затем посылается в пункт назначения. Ее доставка не гарантируется. Если требуются какие-либо гарантии, вы сами должны реализовать их в своем приложении. Каждая дейтаграмма имеет длину, поэтому ее можно рассматривать как \emph{запись} (\emph{record}). В отличии от TCP, который является потоковым протоколом, без каких бы то ни было границ записей.

Если дейтаграмма UDP дублируется в сети, на принимающий узел могут быть доставлены два экземпляра. Также, если клиент UDP отправляет две дейтаграммы в одно и то же место назначения, их порядок может быть изменен сетью.

UDP не обеспечивает управления потоком. Быстрый отправитель UDP может передавать дейтаграммы с такой скоростью, с которой не может работать получатель UDP.

\section{Организация сетей и адресация}
\label{sec:network-setup}

Размер IPv4-адреса --- 32 бита. Адреса принято записывать в десятичной нотации, например, 17.52.86.120. Все IP-адреса подразделены на пять классов: A, B, C, D и E. Адреса класса D используются для группового вещания, а класс E зарезервирован для будущих расширений. Остальные классы предназначены для адресации конкретных сетей и узлов.

Первая часть любого адреса представляет собой идентификатор сети, вторая --- идентификатор узла внутри этой сети. Адрес узла из одних единиц, --- это широковещательный адрес. IP-дейтаграммы, посланные по этому адресу, доставляются всем узлам сети. Адрес 0 означает ``этот узел''. Например, в сети 192.168.1.0/24 адрес 192.168.1.255 --- широковещательный, а 192.168.1.0 --- ``этот узел''. Адрес сети 0 означает ``эта сеть''. Адрес сети 127 --- это адрес ``собственной'' сети узла. Дейтаграммы, адресованные сети 127, не должны покидать узел-отправитель.

\noindent
\begin{figure}[h!]
  \centering
  \begin{tikzpicture}
    \tikzstyle{host} = [draw, thick, fill=white, rectangle, minimum height=2.5em, minimum width=4em, node distance=3em, font={\bfseries}]
    \tikzstyle{router} = [host, rounded corners]
    \tikzstyle{hostConnect} = [draw, |-, very thick]

    \draw [very thick] (0,-1) -- node [right=5.1cm] {Сегмент 1} +(10,0);

    \node [host, name=H1] at (1,0) {H1};
    \node [host, name=H2, right=of H1] {H2};
    \node [router, name=R2, right=of H2] {R2};
    \draw [very thick,|->] (R2.north) -- node [above=0.5em] {Интернет} +(0,0.5);

    \draw [hostConnect] let \p1=(H1.south) in
      (H1.south) -- (\x1, -1);
    \draw [hostConnect] let \p1=(H2.south) in
      (H2.south) -- (\x1, -1);
    \draw [hostConnect] let \p1=(R2.south) in
      (R2.south) -- (\x1, -1);

    \draw [very thick] (0,-3) -- node [right=5.1cm] {Сегмент 2} +(10,0);

    \node [host, name=H3] at (1,-2) {H3};
    \node [host, name=H4, right=of H3] {H4};
    \node [host, name=H5, right=of H4] {H5};
    \node [router, name=R1, right=of H5] {R1};

    \draw [hostConnect] let \p1=(H3.south) in
      (H3.south) -- (\x1, -3);
    \draw [hostConnect] let \p1=(H4.south) in
      (H4.south) -- (\x1, -3);
    \draw [hostConnect] let \p1=(H5.south) in
      (H5.south) -- (\x1, -3);
    \draw [hostConnect] let \p1=(R1.south) in
      (R1.south) -- (\x1, -3);
    \draw [hostConnect] let \p1=(R1.north) in
      (R1.north) -- (\x1, -1);
  \end{tikzpicture}
  \caption{Сеть из двух сегментов}
\end{figure}

Если узлу H1 нужно обратиться к узлу H2, то он получает адрес, соответсвующий IP-адресу H2, и помещает дейтаграмму ``на провод''.

Если узлу H1 нужно обратиться к узлу H3, то H1 должен отправить дейтаграмму через маршрутизатор R1. Если у двух сегментов разные идентификаторы сетей, то H1 по своей маршрутной таблице определяет, что пакеты, адресованные сенменту 2, обрабатываются маршрутизатором R1, и отправляет ему дейтаграмму в предположении, что тот переправит ее узлу H3.

Из вышесказанного следует, что один из способов организовать сети с несколькими сегментами --- это назначить каждому сегменту свой идентификатор сети. Но у этого решения есть недостатки. Во-первых, при этом возможна потеря многих адресов в каждой сети. Во-вторых, маршрутная таблица любого узла, который направляет дейтаграммы напрямую в комбинированную сеть, должна содержать по одной записи для каждого сегмента.

\subsection{Подсети}
У механизма подсетей есть следующие достоинства:
\begin{itemize}
  \item Небольшие маршрутные таблицы и эффективное использование адресного пространства.
  \item Простая маршрутизация.
\end{itemize}

Так как внешние узлы, чтобы выбрать маршрут, используют только идентификатор сети, то можно распределять идентификаторы узлов по своему усмотрению. Разделение на подсети осуществляется по следующему принципу. Одна часть идентификатора узла служит для определения сегмента (то есть подсети), в состав которого входит узел, а другая --- для определения конкретного узла.

\noindent
\begin{figure}[h!]
  \centering
  \begin{tikzpicture}
    \tikzstyle{part} = [draw, thick, fill=white, rectangle, minimum height=2.5em, minimum width=6em, node distance=0]
    \tikzstyle{number} = [node distance=0]

    \node[part,name=net,minimum width=12em] {Идентификатор сети};
    \node[part,right=of net,xshift=-1,name=subnet] {Подсеть};
    \node[part,right=of subnet,xshift=-1,name=host] {Номер хоста};

    \node[number,above=of net,xshift=-6em] {0};
    \node[number,above=of net,xshift=5.1em] {15};
    \node[number,above=of subnet,xshift=-2.3em] {16};
    \node[number,above=of subnet,xshift=2.1em] {23};
    \node[number,above=of host,xshift=-2.3em] {24};
    \node[number,above=of host,xshift=2.1em] {31};
  \end{tikzpicture}
  \caption{Возможная интерпретация адреса}
\end{figure}

На подсети можно разбивать, конечно, же и не по границе байта. С каждой подсетью ассоциируется \emph{маска подсети}, которой определяется, какая часть адреса отведена под идентификаторы сети и подсети, а какая --- под номер узла.

\subsection{Вещание}
\begin{itemize}
  \item \emph{Ограниченное вещание}. Адрес для ограниченного вещания --- 255.255.255.255. Вещание называется ограниченным, так как дейтаграммы, посланные на этот адрес, не уходят дальше маршрутизатора.
  \item \emph{Вещание на сеть}. В адресе для вещания на сеть идентификатор сети определяет адрес этой сети, а идентификатор узла состоит из одних единиц.
  \item \emph{Вещание на подсеть}. В адресе для вещания на подсеть идентификаторы сети и подсети определяют соответствующие адреса, а идентификатор узла состоит из одних единиц. Необходимо знать маску подсети, чтобы опознать вещание на подсеть.
  \item \emph{Вещание на все подсети}. В адресе для вещания на все подсети задан идентификатор сети, а адреса подсети и узла состоят из одних единиц. Как и при вещании на подсеть, для опознания того адреса надо знать маску подсети.
\end{itemize}

\subsection{Бесклассовая междоменная маршрутизация}
Она же \emph{Classless Inter-Domain Routing} (\emph{CIDR}). CIDR --- это механизм подсетей ``наизнанку''. Вместо увеличения CIDR уменьшает длину идентификатора сети в IP-адресе.

Пусть некоторой организации нужно 1000 IP-адресов. Ей выделяют четыре соседних идентификатора сетей класса C с общим префиксом от 200.10.4.0 до 200.10.7.0. Первые 22 бита этих идентификаторов одинаковы и представляют номер агрегированной сети, в данном случае 200.10.4.0. Как и для подсетей, для идентификации сетевой части IP-адреса используется маска сети. В данном случае она равна 255.255.252.0.

\subsection{Частные сети и NAT}
В настоящее время для частных сетей не выбирается произвольный блок IP-адресов. В RFC 1918 определены три блока адресов, которые не будут выделяться:
\begin{itemize}
  \item 10.0.0.0--10.255.255.255 (префикс 10/8);
  \item 172.16.0.0--172.31.255.255 (префикс 172.16/12);
  \item 192.168.0.0--192.168.255.255 (префикс 192.168/16).
\end{itemize}

Если использовать для своей сети один из этих блоков, то любой узел сможет обратиться к другому узлу в этой же сети, не опасаясь кофликта с глобально выделенным IP-адресом. Если нужен выход во внешний мир, то следует использовать \emph{преобразование сетевых адресов} (\emph{NAT}, \emph{Network Address Translation}). Принцип работы заключается в преобразовании между частными сетевыми адресами и одним или несколькими гобально выделенными IP-адресами. Большинство устройств с поддержкой NAT можно сконфигурировать в трех режимах:
\begin{itemize}
  \item \emph{Статический}. Адреса всех или некоторых узлов в частной сети отображаются на один и тот же фиксированный, глобально выделенный адрес.
  \item \emph{Выбор из пула}. Устройство с поддержкой NAT имеет пул глобально выделенных IP-адресов и динамически назначает один из них узлу, которому нужно связаться с узлом во внешней сети.
  \item \emph{PAT (Port Address Translation, преобразование адресов портов)}. Этот метод применяется, когда есть единственный глобально выделенный адрес. При этом каждый частный адрес отображается на один и тот же внешний адрес, но номер порта исходящего пакета заменяется уникальными значением, которое в дальнейшем используется для направления входящих пакетов на частный сетевой адрес.
\end{itemize}

\subsection{DHCP}
Он же \emph{Dynamic Host Configuration Protocol} (\emph{протокол динамической настройки узла}). Сетевой протокол, позволяющий компьютерам автоматически получать IP-адрес. Помимо адреса, DHCP также может сообщить клиенту дополнительные параметры, необходимые для работы в сети. Вот некоторые из часто используемых опций:
\begin{itemize}
  \item IP-адрес сетевого шлюза по умолчанию;
  \item маска подсети;
  \item адреса серверов DNS;
  \item доменное имя.
\end{itemize}

Протокол DHCP является клиент-серверным, использует протокол UDP. При этом сервер принимает сообщения на порту 67 и отправляет сообщения клиентам на порт 68.

Изначально клиент выполняет широковещательный запрос по всей сети с целью обнаружить доступные DHCP-серверы, при этом в качестве адреса источника указывается 0.0.0.0, а в качестве адреса назначения --- широковещательный адрес 255.255.255.255.

\subsection{DNS}
Она же \emph{Domain Name System} (\emph{система доменных имён}). Компьютерная распределенная система для получения информации о доменных именах. Чаще всего используется для получения IP-адреса по имени узла. Но также может и использоваться и для получения имени по адресу.

Основой DNS является представление об иерархической структуре доменного имени и \emph{зонах}. Каждый сервер, отвечающий за имя, может переложить ответственность за дальнейшую часть домена другому серверу.

Имя и IP-адрес не соответствуют друг другу взаимооднозначно. Например, одному адресу может быть сопоставлено несколько имен, что позволяет организовывать виртуальный хостинг. И наоборот --- одному имени может быть сопоставлено множество адресов, что позволяет балансировать нагрузку.

\subsubsection{Записи DNS}
Единицы хранения и передачи информации в DNS. Каждая запись состоит из следующих полей:

\begin{center}
  \begin{tabular}{lp{9cm}}
    \toprule
    Имя поля & Объяснение \\
    \midrule
    NAME & доменное имя, к которому привязана данная запись \\
    TTL (Time To Live) & допустимое время хранения записи в неответственном DNS-сервере \\
    TYPE & формат и назначение записи \\
    CLASS & тип сети \\
    RDLEN & длина поля данных \\
    RDATA & поле данных, формат и содержание которого зависит от типа \\
    \bottomrule
  \end{tabular}
\end{center}

Некоторые типы записей:
\begin{itemize}
  \item \emph{A} (\emph{address record}). Запись адреса связывает имя узла с адресом IP.
  \item \emph{AAAA} (\emph{IPv6 address record}). Связывает имя узла с адресом IPv6.
  \item \emph{CNAME} (\emph{canonical name record}). Запись канонического имени. Используется для перенаправление на другое имя.
  \item \emph{MX} (\emph{mail exchange}). Указывает почтовые серверы для данного домена.
  \item \emph{NS} (\emph{name server}). DNS-сервер для данного домена.
  \item \emph{PTR} (\emph{pointer}). Связывает IP-адрес узла с его каноническим именем.
\end{itemize}

Всю эту информацию (и не только) можно узнать, использую утилиту \emph{nslookup}.

\section{Дополнительные вопросы}
\label{sec:network-addition}

\subsection{Организация тайм-аута}
Существует три способа установки тайм-аута для операции ввода-вывода через сокета:
\begin{enumerate}
  \item Вызов функции \lstinline{alarm}, которая генерирует сингал \lstinline{SIGALRM}, когда истекает заданное время.
  \item Блокирование при ожидании ввода-вывода в функции \lstinline{select}, имеющей встроенное ограничение времени, вместо блокирования в вызове функций \lstinline{read} или \lstinline{write}.
  \item Использование параметров сокетов \lstinline{SO_RCVTIMEO} и \lstinline{SO_SNDTIMEO}.
\end{enumerate}

Все три варианта можно использовать с функциями ввода/вывода, но также нужно возможность работы с функцией \lstinline{connect}, поскольку процесс соединения TCP может занять длительное время (обычно 75 с).

\subsection{Алгоритм Нейгла}
\label{sec:nagle-algorithm}
Алгоритм был разработан для более эффективного использования сетевого канала. Так как минимальный размер сегмента TCP без данных равен 40 байт, то накладные расходы при посылке одного байта в сегменте составляет $4000\%$.

Соединение считается простаивающем, если в нем нет неподтвержденных данных. Новые данные от приложения не посылаются, пока соединение не перейдет в состояние простоя. RFC 1122 ослабляет это требование, разрешая посылать данные, если их хватает для заполнения целого сегмента. Условие Нейгла при этом выполняется: в соединении находится не более одного небольшого неподтвержденного сегмента.

Алгоритм Нейгла может плохо взаимодейстовать с другой возможностью TCP --- отложенным подтверждением. Когда прибывает сегмент от удаленного узла, TCP задерживает отправку ACK в предположении, что приложение скоро ответит на только что полученные данные. Поэтому ACK можно будет объединить с данными.

Если через $T_P$ обозначить время, необходимое серверу для обработки запроса и отправки ответа, но на каждую пару запрос/ответ уйдет $RTT + T_P$ мс. Если клиент посылает свой запрос в виде двух последовательных операций записи, то алгоритмы взаимодействуют так, что число сегментов, необходимых для получения ответа от сервера, равно четырем. Поэтому время, необходимое для получения логического ответа, может быть значительным.
