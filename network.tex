\chapter{Сетевое программирование}
\label{ch:network}

\section{Протокол TCP}
\label{sec:tcp}
Он же \emph{протокол управления передачей}; он же \emph{Transmission Control Protocol}. Является протоколом, ориентированным на установление соединения и предоставляющим надежный двусторонний байтовый поток использующим его приложениям. TCP обеспечивает отправку и прием подтверждений, обработку тайм-оутов, повторную передачу и т.п.

Прежде всего, TCP обеспечивает установление соединений. Клиент TCP устанавливает соединение с выбранным сервером, обменивается с ним данными по этому соединению и затем разрывает его.

TCP надежен, но не магичен. Все отправленные данные должны быть подтверждены. Если этого нет, то данные автоматически пересылаются. Время ожидания подтверждения при этом увеличивается.

TCP может оценивать \emph{время обращения} (\emph{round-trip-time}, \emph{RTT}) между двумя узлами и таким образом определять необходимое время для получения подтверждения. TCP постоянно обновляет RTT.

TCP упорядочивает данные, связывая некоторый порядковый номер с каждым отправляемым им байтом. Пусть приложение записывает 2048 байт в сокет TCP, что приводит к отправке двух сегментов TCP. Первый из них содержит данные с порядковыми номерами 1--1024, второй --- с номерами 1025--2048. Если какой-либо сегмент приходит вне очереди, принимающий TCP заново упорядочит сегменты, основываясь на их порядковых номерах, перед тем как отправить данные принимающему приложению. Если TCP получает дублированные данные, он может определить, что они были дублированы, и они будут проигнорированы.

TCP обеспечивает \emph{управление потоком} (\emph{flow control}). TCP сообщает своему собеседнику, сколько именно байтов он хочет получить от него. Это называется объявлением \emph{окна} (\emph{window}).

\subsection{Трехэтапное рукопожатие}
\begin{enumerate}
  \item Сервер должен быть подготовлен для принятия входящего соединения. Это называется \emph{пассивным открытием} (\emph{passive open}).
  \item Клиент выполняет \emph{активное открытие} (\emph{active open}), то есть посылает сегмент SYN, чтобы сообщить серверу начальный порядковый номер данных. Этот сегмент содержит заголовок IP, заголовок TCP и параметры TCP.
  \item Сервер подтверждает получение клиентского сегмента SYN и вслед посылает свой собственный сегмент SYN, содержащий порядковый номер своих данных. SYN и ACK отсылаются в одном сегменте.
  \item Клиент подтверждает получение SYN сервера.
\end{enumerate}

\begin{center}
  \begin{tikzpicture}
    \tikzstyle{tcpStep} = [];
    \node at (0,0) (client) {Клиент};
    \node at (4,0) (server) {Сервер};

    \draw[thick,->,-stealth] (client.south)  -- +(0,-4)
      node (client socket) [tcpStep,left,pos=.1] {\lstinline{socket}}
      node (connect) [tcpStep,left,pos=.35,text width=3.3cm, text justified] {\lstinline{connect}, блокировка, активное открытие}
      node (close connect) [tcpStep,left,pos=.75] {Завершение \lstinline{connect}};
    \draw[thick,->,-stealth] (server.south)  -- +(0,-4)
      node (server socket) [tcpStep,right,pos=.2] {\lstinline{socket, bind, listen}}
      node (accept) [tcpStep,,right,pos=.5] {\lstinline{accept}, блокировка}
      node (close accept) [tcpStep,right,pos=.85] {Завершение \lstinline{accept}};

    \draw[thick,->,-stealth] (connect) edge node [above,sloped] {SYN J} (accept);
    \draw[thick,->,-stealth] (accept) edge node [above,sloped] {SYN K, ACK J+1} (close connect);
    \draw[thick,->,-stealth] (close connect) edge node [above,sloped] {ACK K+1} (close accept);
  \end{tikzpicture}
\end{center}

Для подобного обмена нужно как минимум три пакета, поэтому он называется \emph{трехэтапным рукопожатием TCP} (\emph{TCP three-way handshake}).

\subsection{Параметры TCP}
Каждый сегмент SYN может содержать параметры TCP. Следом наиболее общеупотребительные:
\begin{itemize}
  \item \emph{Параметр MSS}. Позволяет объявить свой максимальный размер сегмента (maximum segment size, MSS) --- максимальное количество данных, которое он будет принимать в каждом сегмента TCP на этом соединении.
  \item \emph{Параметр масштабирования окна (Window scale option)}. Максимальный размер окна, который может быть установлен в заголовке TCP, равен $65535$, поскольку соответствующее поле занимает 16 бит. Но высокоскоростные соединения или линии с большой задержкой требуют большего размера окна для получения максимально возможной пропускной способности. Этот параметр определяет, что объявленная в заголовке TCP величина окна должна быть отмасштабирована --- сдвинута влево на 0--14 разрядов, предоставляя максимально возможное окно размером почти гигабайт ($65535 \times 2^{14}$).
  \item \emph{Временная метка (Timestamp option)}. Этот параметр необходим для высокоскоростных соединений, чтобы предотвратить возможное повреждение данных, вызванное приходом устаревших, задержавшихся и дублированных сегментов.
\end{itemize}

\subsection{Завершение соединения TCP}
Для завершения соединения требуется четыре сегмента.

\begin{enumerate}
  \item Один из сетевых узлов выполняет \emph{активное закрытие} (\emph{active close}). TCP этого узла отправляет сегмент FIN.
  \item Другой узел, получающий сегмент FIN, выполняет \emph{пассивное закрытие} (\emph{passive close}). Полученный сегмент FIN подтверждается TCP. Получение сегмента FIN передается приложению как признак конца файла.
  \item Через некоторое время после того, как приложение получило признак конца файла, оно закрывает свой сокет. TCP отправляет сегмент FIN первому узлу.
  \item Первый узел подтверждает получение сегмента FIN.
\end{enumerate}

Иногда первый FIN отправляется в сегменте вместе с данными. Также сегменты, отправляемые на шагах 2 и 3, могут быть объединены. Возможно, что между шагами 2 и 3 какие-то данные будут переданы от узла, выполняющего пассивное закрытие, к узлу, выполняющему активное закрытие. Это состояние называется \emph{частичным закрытием} (\emph{half-close}).

\subsection{Диаграмма состояний TCP}

% взята с http://www.texample.net/tikz/examples/tcp-state-machine/

\noindent
\begin{tikzpicture}[>=latex]

  %
  % Styles for states, and state edges
  %
  \tikzstyle{state} = [draw, very thick, fill=white, rectangle, minimum height=3em, minimum width=7em, node distance=8em, font={\sffamily\bfseries}]
  \tikzstyle{stateEdgePortion} = [black,thick];
  \tikzstyle{stateEdge} = [stateEdgePortion,->];
  \tikzstyle{edgeLabel} = [pos=0.5, text centered, font={\sffamily\small}];

  %
  % Position States
  %
  \node[state, name=closedStart] {CLOSED};
  \node[state, name=listen, below of=closedStart] {LISTEN};
  \node[state, name=synSent, below of=listen, right of=listen, xshift=8em] {SYN\_SENT};
  \node[state, name=synRcvd, below of=listen, left of=listen, xshift=-8em] {SYN\_RCVD};
  \node[state, name=established, below of=listen, node distance=14em] {ESTABLISHED};
  \node[state, name=finWait1, below of=established, left of=established, node distance=7em, xshift=-9em] {FIN\_WAIT\_1};
  \node[state, name=finWait2, below of=finWait1] {FIN\_WAIT\_2};
  \node[state, name=closeWait, below of=established, right of=established, node distance=7em, xshift=9em] {CLOSE\_WAIT};
  \node[state, name=closing, below of=established, node distance=14em] {CLOSING};
  \node[state, name=lastAck, below of=closeWait] {LAST\_ACK};
  \node[state, name=timeWait, below of=closing] {TIME\_WAIT};

  %
  % Connect States via edges
  %
  \draw ($(closedStart.south) + (-.5em,0)$)
      edge[stateEdge] node[edgeLabel, xshift=-3em]{\emph{Passive open}}
      ($(listen.north) + (-.5em,0)$);
  \draw ($(listen.north) + (.5em,0)$)
      edge[stateEdge] node[edgeLabel, xshift=2em]{\emph{Close}}
      ($(closedStart.south) + (.5em,0)$);

  \draw ($(listen.south) + (-1em,0)$)
      edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-2em, yshift=1em]{SYN/SYN + ACK}
      ($(synRcvd.east) + (0,1em)$);
  \draw ($(listen.south) + (1em,0)$)
      edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=1em, yshift=1em]{\emph{Send}/SYN}
      ($(synSent.west) + (0,1em)$);

  \draw ($(synRcvd.north) + (.5em,0)$)
      edge[stateEdge, bend left=45] node[edgeLabel,xshift=-4em]{\emph{Timeout}/RST}
      ($(closedStart.west) + (0,-.5em)$);

  \draw ($(synSent.north) + (-.5em,0)$)
      edge[stateEdge, bend right=45] node[edgeLabel,xshift=-1em, yshift=-1em]{\emph{Close}}
      ($(closedStart.east) + (0,-.5em)$);
  \draw ($(closedStart.east) + (0,.5em)$)
      edge[stateEdge, bend left=45] node[edgeLabel,xshift=4em]{\emph{Active open}/SYN}
      ($(synSent.north) + (.5em,0)$);

  \draw (synSent.west)
      edge[stateEdge] node[edgeLabel, yshift=1em]{SYN/SYN + ACK}
      (synRcvd.east);
  \draw (synRcvd)
      edge[stateEdge] node[edgeLabel, xshift=-2.5em]{\emph{Close}/FIN}
      (finWait1);

  \draw ($(synRcvd.east) + (0,-1em)$)
      edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-1em, yshift=-1em]{ACK}
      ($(established.north) + (-1em,0)$);
  \draw ($(synSent.west) + (0,-1em)$)
      edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=3em, yshift=-1em]{SYN + ACK/ACK}
      ($(established.north) + (1em,0)$);

  \draw ($(established.south) + (-1em,0)$)
      edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-1em, yshift=1em]{\emph{Close}/FIN}
      ($(finWait1.east) + (0,.5em)$);
  \draw ($(established.south) + (1em,0)$)
      edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=1em, yshift=1em]{FIN/ACK}
      ($(closeWait.west) + (0,1em)$);

  \draw (finWait1.south)
      edge[stateEdge] node[edgeLabel, xshift=-2em]{ACK}
      (finWait2.north);
  \draw ($(finWait1.east) + (0,-.5em)$)
      edge[stateEdge, bend left=22.5] node[edgeLabel, yshift=1em]{ACK}
      (closing.north);
  \draw (finWait1.south east)
      edge[stateEdge] node[edgeLabel, xshift=1em, yshift=2em, text width=3em]{FIN + ACK/ACK}
      (timeWait.north west);

  \draw (finWait2.south)
      edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=-2em, yshift=-1em]{FIN/ACK}
      (timeWait.west);

  \draw (closing)
      edge[stateEdge] node[edgeLabel, xshift=-2em]{ACK}
      (timeWait);

  \draw (closeWait)
      edge[stateEdge] node[edgeLabel,xshift=2.5em]{\emph{Close}/FIN}
      (lastAck);

  %
  % Connect lastAck to closed is slightly more complicated
  % no direct line-of-sight, so we need to take the scenic route
  %
  \coordinate (lastAck2ClosedA) at ($(lastAck.east) + (2em,0)$);
  \coordinate (lastAck2ClosedB) at ($(closedStart.north -| lastAck.east) + (2em,1em)$);
  \coordinate (lastAck2ClosedC) at ($(closedStart.north) + (0.5em,1em)$);
  \draw (lastAck.east) edge[stateEdgePortion] (lastAck2ClosedA);
  \draw (lastAck2ClosedA) edge[stateEdgePortion] node[edgeLabel,xshift=-1.5em, yshift=-4em]{ACK} (lastAck2ClosedB);
  \draw (lastAck2ClosedB) edge[stateEdgePortion] (lastAck2ClosedC);
  \draw (lastAck2ClosedC) edge[stateEdge] ($(closedStart.north) + (0.5em,0)$);

  %
  % likewise for timeWait to closed
  %
  \coordinate (timeWait2ClosedA) at ($(timeWait.south) + (0,-1em)$);
  \coordinate (timeWait2ClosedB) at ($(timeWait.south -| finWait2.west) + (-2em,-1em)$);
  \coordinate (timeWait2ClosedC) at ($(closedStart.north -| finWait2.west) + (-2em,1em)$);
  \coordinate (timeWait2ClosedD) at ($(closedStart.north) + (-0.5em,1em)$);
  \draw (timeWait.south) edge[stateEdgePortion] (timeWait2ClosedA);
  \draw (timeWait2ClosedA) edge[stateEdgePortion] (timeWait2ClosedB);
  \draw (timeWait2ClosedB) edge[stateEdgePortion] (timeWait2ClosedC);
  \draw (timeWait2ClosedC) edge[stateEdgePortion]
    node[edgeLabel, text width=12.25em, yshift=1.5em]{\emph{Timeout after two maximum segment lifetimes (2*MSL)}}
    (timeWait2ClosedD);
  \draw (timeWait2ClosedD) edge[stateEdge] ($(closedStart.north) + (-0.5em,0)$);

  % draw dotted lines around passive and active closes
  \begin{pgfonlayer}{background}
    \draw [join=round,black,dotted] ($(closeWait.north west) + (-1em, -1em)$) rectangle ($(lastAck.south east) + (1em, 1em)$);
    \draw [join=round,black,dotted] ($(finWait1.north west) + (-1em, -1em)$) rectangle ($(timeWait.south east) + (1em, 1em)$);
  \end{pgfonlayer}

\end{tikzpicture}

\section{Протокол UDP}
\label{sec:udp}
Он же \emph{протокол пользовательских дейтаграмм}; он же \emph{User Datagram Protocol}. Является протоколом, не ориентированным на установление соединения. Не гарантирует доставку дейтаграмм.

Приложение записывает в сокет UDP дейтаграмму, которая упаковывается в дейтаграмму IP и затем посылается в пункт назначения. Ее доставка не гарантируется. Если требуются какие-либо гарантии, вы сами должны реализовать их в своем приложении. Каждая дейтаграмма имеет длину, поэтому ее можно рассматривать как \emph{запись} (\emph{record}). В отличии от TCP, который является потоковым протоколом, без каких бы то ни было границ записей.

Если дейтаграмма UDP дублируется в сети, на принимающий узел могут быть доставлены два экземпляра. Также, если клиент UDP отправляет две дейтаграммы в одно и то же место назначения, их порядок может быть изменен сетью.

UDP не обеспечивает управления потоком. Быстрый отправитель UDP может передавать дейтаграммы с такой скоростью, с которой не может работать получатель UDP.

\section{Дополнительные вопросы}
\label{sec:network-addition}

\subsection{Организация таймаута}
Существует три способа установки тайм-аута для операции ввода-вывода через сокета:
\begin{enumerate}
  \item Вызов функции \lstinline{alarm}, которая генерирует сингал \lstinline{SIGALRM}, когда истекает заданное время.
  \item Блокирование при ожидании ввода-вывода в функции \lstinline{select}, имеющей встроенное ограничение времени, вместо блокирования в вызове функций \lstinline{read} или \lstinline{write}.
  \item Использование параметров сокетов \lstinline{SO_RCVTIMEO} и \lstinline{SO_SNDTIMEO}.
\end{enumerate}

Все три варианта можно использовать с функциями ввода/вывода, но также нужно возможность работы с функцией \lstinline{connect}, поскольку процесс соединения TCP может занять длительное время (обычно 75 с).
